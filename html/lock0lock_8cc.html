<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/lock/lock0lock.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('lock0lock_8cc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">lock0lock.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The transaction lock system.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="service__thd__engine__lock_8h_source.html">mysql/service_thd_engine_lock.h</a>&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
<code>#include &lt;set&gt;</code><br />
<code>#include &lt;unordered_map&gt;</code><br />
<code>#include &lt;unordered_set&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
<code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="current__thd_8h_source.html">current_thd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="debug__sync_8h_source.html">debug_sync.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0boot_8h_source.html">dict0boot.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0mem_8h_source.html">dict0mem.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ha__prototypes_8h_source.html">ha_prototypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0priv_8h_source.html">lock0priv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pars0pars_8h_source.html">pars0pars.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0mysql_8h_source.html">row0mysql.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0sel_8h_source.html">row0sel.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0mon_8h_source.html">srv0mon.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0purge_8h_source.html">trx0purge.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0sys_8h_source.html">trx0sys.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="usr0sess_8h_source.html">usr0sess.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0new_8h_source.html">ut0new.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0vec_8h_source.html">ut0vec.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__dbug_8h_source.html">my_dbug.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__psi__config_8h_source.html">my_psi_config.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="include_2mysql_2plugin_8h_source.html">mysql/plugin.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="psi_2psi__thread_8h_source.html">mysql/psi/psi_thread.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDeadlock__notifier.html">Deadlock_notifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A static class for reporting notifications about deadlocks.  <a href="classDeadlock__notifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTableLockGetNode.html">TableLockGetNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for accessing the embedded node within a table lock.  <a href="structTableLockGetNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPrintNotStarted.html">PrintNotStarted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor to print not-started transaction from the mysql_trx_list.  <a href="structPrintNotStarted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrxLockIterator.html">TrxLockIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over a transaction's locks.  <a href="classTrxLockIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrxListIterator.html">TrxListIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This iterates over both the RW and RO trx_sys lists.  <a href="classTrxListIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacelocksys"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html">locksys</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a390c44e3d017379682adbfa150f2c631"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a390c44e3d017379682adbfa150f2c631">LOCK_MODULE_IMPLEMENTATION</a></td></tr>
<tr class="separator:a390c44e3d017379682adbfa150f2c631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b942151a21e8458664d68a9ccfc491"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ac6b942151a21e8458664d68a9ccfc491">IS_LOCK_S_OR_X</a>(lock)&#160;&#160;&#160;(<a class="el" href="lock0priv_8h.html#ae4ba4d837532fb8eaf414d1cbaaf6d90">lock_get_mode</a>(lock) == <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013a7c98d16ae81460b73cc836948b622480">LOCK_S</a> || <a class="el" href="lock0priv_8h.html#ae4ba4d837532fb8eaf414d1cbaaf6d90">lock_get_mode</a>(lock) == <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013aa7ba6be447ffbfa3ac8e35268f622de6">LOCK_X</a>)</td></tr>
<tr class="separator:ac6b942151a21e8458664d68a9ccfc491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af8bca88f299c70144b65640de56f8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a3af8bca88f299c70144b65640de56f8f">PRINT_NUM_OF_LOCK_STRUCTS</a></td></tr>
<tr class="separator:a3af8bca88f299c70144b65640de56f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1fb6f2451b04d818cb23a0e04608e54d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1fb6f2451b04d818cb23a0e04608e54d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a1fb6f2451b04d818cb23a0e04608e54d">Locks</a> = std::vector&lt; T, <a class="el" href="classmem__heap__allocator.html">mem_heap_allocator</a>&lt; T &gt; &gt;</td></tr>
<tr class="separator:a1fb6f2451b04d818cb23a0e04608e54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa1c13b29c0950883c716f2195fcaca15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#aa1c13b29c0950883c716f2195fcaca15">locksys::owns_exclusive_global_latch</a> ()</td></tr>
<tr class="memdesc:aa1c13b29c0950883c716f2195fcaca15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if lock_sys latch is exclusively owned by the current thread.  <a href="namespacelocksys.html#aa1c13b29c0950883c716f2195fcaca15">More...</a><br /></td></tr>
<tr class="separator:aa1c13b29c0950883c716f2195fcaca15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b658001706cfd23bc39aa8b5854adb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#a75b658001706cfd23bc39aa8b5854adb">locksys::owns_shared_global_latch</a> ()</td></tr>
<tr class="memdesc:a75b658001706cfd23bc39aa8b5854adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if lock_sys latch is owned in shared mode by the current thread.  <a href="namespacelocksys.html#a75b658001706cfd23bc39aa8b5854adb">More...</a><br /></td></tr>
<tr class="separator:a75b658001706cfd23bc39aa8b5854adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f6f08b62f3525ce41e225523a004f5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#a2f6f08b62f3525ce41e225523a004f5b">locksys::owns_page_shard</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:a2f6f08b62f3525ce41e225523a004f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if given page shard can be safely accessed by the current thread.  <a href="namespacelocksys.html#a2f6f08b62f3525ce41e225523a004f5b">More...</a><br /></td></tr>
<tr class="separator:a2f6f08b62f3525ce41e225523a004f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb712cc63a48c9031f3c9af257bcf29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#a6bb712cc63a48c9031f3c9af257bcf29">locksys::owns_table_shard</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> &amp;table)</td></tr>
<tr class="memdesc:a6bb712cc63a48c9031f3c9af257bcf29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if given table shard can be safely accessed by the current thread.  <a href="namespacelocksys.html#a6bb712cc63a48c9031f3c9af257bcf29">More...</a><br /></td></tr>
<tr class="separator:a6bb712cc63a48c9031f3c9af257bcf29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9dc7c8edd2e37a5c20ae2672c28f27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#a9e9dc7c8edd2e37a5c20ae2672c28f27">locksys::owns_lock_shard</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a9e9dc7c8edd2e37a5c20ae2672c28f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if shard which contains lock is latched (or that an exclusive latch on whole lock_sys is held) by current thread.  <a href="namespacelocksys.html#a9e9dc7c8edd2e37a5c20ae2672c28f27">More...</a><br /></td></tr>
<tr class="separator:a9e9dc7c8edd2e37a5c20ae2672c28f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaaf94eb0978b4f4623a40bd8a2a376d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#acaaf94eb0978b4f4623a40bd8a2a376d">lock_rec_validate_page</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:acaaf94eb0978b4f4623a40bd8a2a376d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the record lock queues on a page.  <a href="#acaaf94eb0978b4f4623a40bd8a2a376d">More...</a><br /></td></tr>
<tr class="separator:acaaf94eb0978b4f4623a40bd8a2a376d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac881161276c0dfc1994b2af6d22f3ea5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ac881161276c0dfc1994b2af6d22f3ea5">lock_report_trx_id_insanity</a> (<a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> max_trx_id)</td></tr>
<tr class="memdesc:ac881161276c0dfc1994b2af6d22f3ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports that a transaction id is insensible, i.e., in the future.  <a href="#ac881161276c0dfc1994b2af6d22f3ea5">More...</a><br /></td></tr>
<tr class="separator:ac881161276c0dfc1994b2af6d22f3ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ca4cfe4edd613e4bf2f2880d5e6a7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ab0ca4cfe4edd613e4bf2f2880d5e6a7e">lock_check_trx_id_sanity</a> (<a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> trx_id, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets)</td></tr>
<tr class="memdesc:ab0ca4cfe4edd613e4bf2f2880d5e6a7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that a transaction id is sensible, i.e., not in the future.  <a href="#ab0ca4cfe4edd613e4bf2f2880d5e6a7e">More...</a><br /></td></tr>
<tr class="separator:ab0ca4cfe4edd613e4bf2f2880d5e6a7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c0eec427989825525fd4b4b9cffc1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a02c0eec427989825525fd4b4b9cffc1b">lock_clust_rec_cons_read_sees</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, <a class="el" href="classReadView.html">ReadView</a> *view)</td></tr>
<tr class="memdesc:a02c0eec427989825525fd4b4b9cffc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that a record is seen in a consistent read.  <a href="#a02c0eec427989825525fd4b4b9cffc1b">More...</a><br /></td></tr>
<tr class="separator:a02c0eec427989825525fd4b4b9cffc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a7181a1b37cd5b082c7b41f816e7be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a53a7181a1b37cd5b082c7b41f816e7be">lock_sec_rec_cons_read_sees</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="classReadView.html">ReadView</a> *view)</td></tr>
<tr class="memdesc:a53a7181a1b37cd5b082c7b41f816e7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that a non-clustered index record is seen in a consistent read.  <a href="#a53a7181a1b37cd5b082c7b41f816e7be">More...</a><br /></td></tr>
<tr class="separator:a53a7181a1b37cd5b082c7b41f816e7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b61b8949e0116857ff488de16509d4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a6b61b8949e0116857ff488de16509d4d">lock_sys_create</a> (ulint n_cells)</td></tr>
<tr class="memdesc:a6b61b8949e0116857ff488de16509d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the lock system at database start.  <a href="#a6b61b8949e0116857ff488de16509d4d">More...</a><br /></td></tr>
<tr class="separator:a6b61b8949e0116857ff488de16509d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48374d73d24053ebce5038781703e13a"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a48374d73d24053ebce5038781703e13a">lock_rec_lock_fold</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a48374d73d24053ebce5038781703e13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the fold value of a lock: used in migrating the hash table.  <a href="#a48374d73d24053ebce5038781703e13a">More...</a><br /></td></tr>
<tr class="separator:a48374d73d24053ebce5038781703e13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6032b9d467a2fa36b3a6b1532df30a33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a6032b9d467a2fa36b3a6b1532df30a33">lock_sys_resize</a> (ulint n_cells)</td></tr>
<tr class="memdesc:a6032b9d467a2fa36b3a6b1532df30a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize the lock hash tables.  <a href="#a6032b9d467a2fa36b3a6b1532df30a33">More...</a><br /></td></tr>
<tr class="separator:a6032b9d467a2fa36b3a6b1532df30a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127c8053fd0338b4d796d0c0de0272dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a127c8053fd0338b4d796d0c0de0272dd">lock_sys_close</a> (void)</td></tr>
<tr class="memdesc:a127c8053fd0338b4d796d0c0de0272dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the lock system at database shutdown.  <a href="#a127c8053fd0338b4d796d0c0de0272dd">More...</a><br /></td></tr>
<tr class="separator:a127c8053fd0338b4d796d0c0de0272dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478c022c5f5da29524207004cfc5325d"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a478c022c5f5da29524207004cfc5325d">lock_get_size</a> (void)</td></tr>
<tr class="memdesc:a478c022c5f5da29524207004cfc5325d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of a lock struct.  <a href="#a478c022c5f5da29524207004cfc5325d">More...</a><br /></td></tr>
<tr class="separator:a478c022c5f5da29524207004cfc5325d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0110e6281abe4ae1837ce04ff99279a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ae0110e6281abe4ae1837ce04ff99279a">lock_set_lock_and_trx_wait</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:ae0110e6281abe4ae1837ce04ff99279a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the wait flag of a lock and the back pointer in trx to lock.  <a href="#ae0110e6281abe4ae1837ce04ff99279a">More...</a><br /></td></tr>
<tr class="separator:ae0110e6281abe4ae1837ce04ff99279a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419d78b85193924e945f2313a60f7ccf"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a419d78b85193924e945f2313a60f7ccf">lock_rec_get_gap</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a419d78b85193924e945f2313a60f7ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the gap flag of a record lock.  <a href="#a419d78b85193924e945f2313a60f7ccf">More...</a><br /></td></tr>
<tr class="separator:a419d78b85193924e945f2313a60f7ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea241051962fafa069de83516f0df01"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a8ea241051962fafa069de83516f0df01">lock_rec_get_rec_not_gap</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a8ea241051962fafa069de83516f0df01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the LOCK_REC_NOT_GAP flag of a record lock.  <a href="#a8ea241051962fafa069de83516f0df01">More...</a><br /></td></tr>
<tr class="separator:a8ea241051962fafa069de83516f0df01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc4fc3dd2500ccd00e4139c4ccba75a"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aedc4fc3dd2500ccd00e4139c4ccba75a">lock_rec_get_insert_intention</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:aedc4fc3dd2500ccd00e4139c4ccba75a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the waiting insert flag of a record lock.  <a href="#aedc4fc3dd2500ccd00e4139c4ccba75a">More...</a><br /></td></tr>
<tr class="separator:aedc4fc3dd2500ccd00e4139c4ccba75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eed8028e8450e8856921546fa518253"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a0eed8028e8450e8856921546fa518253">lock_rec_has_to_wait</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *trx, ulint type_mode, const <a class="el" href="structlock__t.html">lock_t</a> *lock2, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_is_on_supremum)</td></tr>
<tr class="memdesc:a0eed8028e8450e8856921546fa518253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a lock request for a new lock has to wait for request lock2.  <a href="#a0eed8028e8450e8856921546fa518253">More...</a><br /></td></tr>
<tr class="separator:a0eed8028e8450e8856921546fa518253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cec654a8d71e13f4113aa36dd0d78f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ae9cec654a8d71e13f4113aa36dd0d78f">lock_has_to_wait</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock1, const <a class="el" href="structlock__t.html">lock_t</a> *lock2)</td></tr>
<tr class="memdesc:ae9cec654a8d71e13f4113aa36dd0d78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a lock request lock1 has to wait for request lock2.  <a href="#ae9cec654a8d71e13f4113aa36dd0d78f">More...</a><br /></td></tr>
<tr class="separator:ae9cec654a8d71e13f4113aa36dd0d78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ccba69e261b79e8c7ab7d83cb41319"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ad7ccba69e261b79e8c7ab7d83cb41319">lock_rec_find_set_bit</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:ad7ccba69e261b79e8c7ab7d83cb41319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for a set bit in a record lock bitmap.  <a href="#ad7ccba69e261b79e8c7ab7d83cb41319">More...</a><br /></td></tr>
<tr class="separator:ad7ccba69e261b79e8c7ab7d83cb41319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c73150ff49ff33364b8dfe57796bac2"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a6c73150ff49ff33364b8dfe57796bac2">lock_rec_find_next_set_bit</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock, ulint heap_no)</td></tr>
<tr class="memdesc:a6c73150ff49ff33364b8dfe57796bac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for the next set bit in the record lock bitmap.  <a href="#a6c73150ff49ff33364b8dfe57796bac2">More...</a><br /></td></tr>
<tr class="separator:a6c73150ff49ff33364b8dfe57796bac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ddd74f278136a863417a7fcafecceb"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ad1ddd74f278136a863417a7fcafecceb">lock_rec_reset_nth_bit</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock, ulint i)</td></tr>
<tr class="memdesc:ad1ddd74f278136a863417a7fcafecceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the nth bit of a record lock.  <a href="#ad1ddd74f278136a863417a7fcafecceb">More...</a><br /></td></tr>
<tr class="separator:ad1ddd74f278136a863417a7fcafecceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc396ea6e4e953a9400b711b2d57230f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#adc396ea6e4e953a9400b711b2d57230f">lock_rec_trx_wait</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock, ulint i, ulint type)</td></tr>
<tr class="memdesc:adc396ea6e4e953a9400b711b2d57230f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the nth bit of a record lock.  <a href="#adc396ea6e4e953a9400b711b2d57230f">More...</a><br /></td></tr>
<tr class="separator:adc396ea6e4e953a9400b711b2d57230f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105a61c935f6765bbc78ddbf40203a4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a105a61c935f6765bbc78ddbf40203a4f">lock_rec_expl_exist_on_page</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:a105a61c935f6765bbc78ddbf40203a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if there are explicit record locks on a page.  <a href="#a105a61c935f6765bbc78ddbf40203a4f">More...</a><br /></td></tr>
<tr class="separator:a105a61c935f6765bbc78ddbf40203a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a11bee90995105efe9a0942e37b6349"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a3a11bee90995105efe9a0942e37b6349">lock_rec_bitmap_reset</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a3a11bee90995105efe9a0942e37b6349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the record lock bitmap to zero.  <a href="#a3a11bee90995105efe9a0942e37b6349">More...</a><br /></td></tr>
<tr class="separator:a3a11bee90995105efe9a0942e37b6349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179a520c4a10f93bc52ed52b9abb8a81"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a179a520c4a10f93bc52ed52b9abb8a81">lock_rec_copy</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a179a520c4a10f93bc52ed52b9abb8a81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a record lock to heap.  <a href="#a179a520c4a10f93bc52ed52b9abb8a81">More...</a><br /></td></tr>
<tr class="separator:a179a520c4a10f93bc52ed52b9abb8a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9398c6b6d42fd740b9fa25ae4be1f660"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a9398c6b6d42fd740b9fa25ae4be1f660">lock_rec_get_prev</a> (const <a class="el" href="structlock__t.html">lock_t</a> *in_lock, ulint heap_no)</td></tr>
<tr class="memdesc:a9398c6b6d42fd740b9fa25ae4be1f660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the previous record lock set on a record.  <a href="#a9398c6b6d42fd740b9fa25ae4be1f660">More...</a><br /></td></tr>
<tr class="separator:a9398c6b6d42fd740b9fa25ae4be1f660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b72e4f9774ec637cf85a44ad8239635"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a9b72e4f9774ec637cf85a44ad8239635">lock_rec_has_expl</a> (ulint precise_mode, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint heap_no, const <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a9b72e4f9774ec637cf85a44ad8239635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a transaction has a GRANTED explicit lock on rec stronger or equal to precise_mode.  <a href="#a9b72e4f9774ec637cf85a44ad8239635">More...</a><br /></td></tr>
<tr class="separator:a9b72e4f9774ec637cf85a44ad8239635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ffee781817efb3882d42cfc9f0014a"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a76ffee781817efb3882d42cfc9f0014a">lock_rec_other_has_expl_req</a> (<a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> wait, ulint heap_no, const <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a76ffee781817efb3882d42cfc9f0014a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if some other transaction has a lock request in the queue.  <a href="#a76ffee781817efb3882d42cfc9f0014a">More...</a><br /></td></tr>
<tr class="separator:a76ffee781817efb3882d42cfc9f0014a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753371bcba42ef61e86fd97596bcf8d7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a753371bcba42ef61e86fd97596bcf8d7">lock_rec_other_has_conflicting</a> (ulint mode, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint heap_no, const <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a753371bcba42ef61e86fd97596bcf8d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if some other transaction has a conflicting explicit lock request in the queue, so that we have to wait.  <a href="#a753371bcba42ef61e86fd97596bcf8d7">More...</a><br /></td></tr>
<tr class="separator:a753371bcba42ef61e86fd97596bcf8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51fc9d5d1a77f69b4fb7a4cbdbfa036"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ad51fc9d5d1a77f69b4fb7a4cbdbfa036">lock_sec_rec_some_has_impl</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets)</td></tr>
<tr class="memdesc:ad51fc9d5d1a77f69b4fb7a4cbdbfa036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if some transaction has an implicit x-lock on a record in a secondary index.  <a href="#ad51fc9d5d1a77f69b4fb7a4cbdbfa036">More...</a><br /></td></tr>
<tr class="separator:ad51fc9d5d1a77f69b4fb7a4cbdbfa036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4a26d2631c27149ddf0ee924420083"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a5e4a26d2631c27149ddf0ee924420083">lock_rec_other_trx_holds_expl</a> (ulint precise_mode, const <a class="el" href="structtrx__t.html">trx_t</a> *trx, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a5e4a26d2631c27149ddf0ee924420083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if some transaction, other than given trx_id, has an explicit lock on the given rec, in the given precise_mode.  <a href="#a5e4a26d2631c27149ddf0ee924420083">More...</a><br /></td></tr>
<tr class="separator:a5e4a26d2631c27149ddf0ee924420083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ab5b5a29bf12d5dfd022fc0ee5d815"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#af0ab5b5a29bf12d5dfd022fc0ee5d815">lock_number_of_rows_locked</a> (const <a class="el" href="structtrx__lock__t.html">trx_lock_t</a> *trx_lock)</td></tr>
<tr class="memdesc:af0ab5b5a29bf12d5dfd022fc0ee5d815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return approximate number or record locks (bits set in the bitmap) for this transaction.  <a href="#af0ab5b5a29bf12d5dfd022fc0ee5d815">More...</a><br /></td></tr>
<tr class="separator:af0ab5b5a29bf12d5dfd022fc0ee5d815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9f940afda7bc372f6b78a23ed1aa37"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a8a9f940afda7bc372f6b78a23ed1aa37">lock_number_of_tables_locked</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a8a9f940afda7bc372f6b78a23ed1aa37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of table locks for a transaction.  <a href="#a8a9f940afda7bc372f6b78a23ed1aa37">More...</a><br /></td></tr>
<tr class="separator:a8a9f940afda7bc372f6b78a23ed1aa37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad9479e72fd3c0f3ebef965a098a241"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a8ad9479e72fd3c0f3ebef965a098a241">lock_rec_insert_to_waiting</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *lock_hash, <a class="el" href="structlock__t.html">lock_t</a> *lock, const <a class="el" href="structRecID.html">RecID</a> &amp;rec_id)</td></tr>
<tr class="memdesc:a8ad9479e72fd3c0f3ebef965a098a241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert lock record to the tail of the queue where the WAITING locks reside.  <a href="#a8ad9479e72fd3c0f3ebef965a098a241">More...</a><br /></td></tr>
<tr class="separator:a8ad9479e72fd3c0f3ebef965a098a241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3f55305a03daf27987ec050d0610ed"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a2c3f55305a03daf27987ec050d0610ed">lock_rec_insert_to_granted</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *lock_hash, <a class="el" href="structlock__t.html">lock_t</a> *lock, const <a class="el" href="structRecID.html">RecID</a> &amp;rec_id)</td></tr>
<tr class="memdesc:a2c3f55305a03daf27987ec050d0610ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert lock record to the head of the queue where the GRANTED locks reside.  <a href="#a2c3f55305a03daf27987ec050d0610ed">More...</a><br /></td></tr>
<tr class="separator:a2c3f55305a03daf27987ec050d0610ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c093cb543c5dfeabe1aa641becc8ca"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#a44c093cb543c5dfeabe1aa641becc8ca">locksys::add_to_trx_locks</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a44c093cb543c5dfeabe1aa641becc8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the lock to the list of trx's locks.  <a href="namespacelocksys.html#a44c093cb543c5dfeabe1aa641becc8ca">More...</a><br /></td></tr>
<tr class="separator:a44c093cb543c5dfeabe1aa641becc8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176352af0cb2b4c752940728ddf8031d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#a176352af0cb2b4c752940728ddf8031d">locksys::remove_from_trx_locks</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a176352af0cb2b4c752940728ddf8031d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the lock from the list of trx's locks.  <a href="namespacelocksys.html#a176352af0cb2b4c752940728ddf8031d">More...</a><br /></td></tr>
<tr class="separator:a176352af0cb2b4c752940728ddf8031d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef58d7d99fb0accf1b297a6aed865f2d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aef58d7d99fb0accf1b297a6aed865f2d">lock_mark_trx_for_rollback</a> (<a class="el" href="trx0types_8h.html#a13121c5e3c7e683afe964f2903433257">hit_list_t</a> &amp;hit_list, <a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> hp_trx_id, <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:aef58d7d99fb0accf1b297a6aed865f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the transactions that will need to be rolled back asynchronously.  <a href="#aef58d7d99fb0accf1b297a6aed865f2d">More...</a><br /></td></tr>
<tr class="separator:aef58d7d99fb0accf1b297a6aed865f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0dd80770fca2c7770cb33edc695fbf5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#af0dd80770fca2c7770cb33edc695fbf5">lock_create_wait_for_edge</a> (<a class="el" href="structtrx__t.html">trx_t</a> *waiter, <a class="el" href="structtrx__t.html">trx_t</a> *blocker)</td></tr>
<tr class="memdesc:af0dd80770fca2c7770cb33edc695fbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new edge in wait-for graph, from waiter to blocker.  <a href="#af0dd80770fca2c7770cb33edc695fbf5">More...</a><br /></td></tr>
<tr class="separator:af0dd80770fca2c7770cb33edc695fbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce283c05fa456105b955a306434a6af"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a0ce283c05fa456105b955a306434a6af">lock_rec_move_granted_to_front</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock, const <a class="el" href="structRecID.html">RecID</a> &amp;rec_id)</td></tr>
<tr class="memdesc:a0ce283c05fa456105b955a306434a6af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a granted lock to the front of the queue for a given record by removing it adding it to the front.  <a href="#a0ce283c05fa456105b955a306434a6af">More...</a><br /></td></tr>
<tr class="separator:a0ce283c05fa456105b955a306434a6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef553dad30bea9338835b3762320248"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a3ef553dad30bea9338835b3762320248">lock_rec_find_similar_on_page</a> (uint32_t type_mode, size_t heap_no, <a class="el" href="structlock__t.html">lock_t</a> *lock, const <a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> &amp;found_waiter_before_lock)</td></tr>
<tr class="memdesc:a3ef553dad30bea9338835b3762320248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks for a suitable type record lock struct by the same trx on the same page.  <a href="#a3ef553dad30bea9338835b3762320248">More...</a><br /></td></tr>
<tr class="separator:a3ef553dad30bea9338835b3762320248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0547aaa70bdb71c2550b71985da395b5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a0547aaa70bdb71c2550b71985da395b5">lock_rec_add_to_queue</a> (ulint type_mode, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const ulint heap_no, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structtrx__t.html">trx_t</a> *trx, const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> we_own_trx_mutex=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:a0547aaa70bdb71c2550b71985da395b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a record lock request in the record queue.  <a href="#a0547aaa70bdb71c2550b71985da395b5">More...</a><br /></td></tr>
<tr class="separator:a0547aaa70bdb71c2550b71985da395b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bd08791fbcb3c4372fd1679a9a7003"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="lock0priv_8h.html#aaa98e1bd917f95280993475788ea6c5b">lock_rec_req_status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ae9bd08791fbcb3c4372fd1679a9a7003">lock_rec_lock_fast</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> impl, ulint mode, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint heap_no, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:ae9bd08791fbcb3c4372fd1679a9a7003"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a fast routine for locking a record in the most common cases: there are no explicit locks on the page, or there is just one lock, owned by this transaction, and of the right type_mode.  <a href="#ae9bd08791fbcb3c4372fd1679a9a7003">More...</a><br /></td></tr>
<tr class="separator:ae9bd08791fbcb3c4372fd1679a9a7003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cec2831a61b0f4e9e4d54647fcd66e9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a0cec2831a61b0f4e9e4d54647fcd66e9">lock_reuse_for_next_key_lock</a> (const <a class="el" href="structlock__t.html">lock_t</a> *held_lock, ulint mode, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint heap_no, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a0cec2831a61b0f4e9e4d54647fcd66e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function for lock_rec_lock_slow(), which grants a Next Key Lock (either LOCK_X or LOCK_S as specified by <code>mode</code>) on &lt;<code>block</code>,<code>heap_no</code>&gt; in the <code>index</code> to the <code>trx</code>, assuming that it already has a granted <code>held_lock</code>, which is at least as strong as mode|LOCK_REC_NOT_GAP.  <a href="#a0cec2831a61b0f4e9e4d54647fcd66e9">More...</a><br /></td></tr>
<tr class="separator:a0cec2831a61b0f4e9e4d54647fcd66e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45076e7e4e028081383d502247e0953"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#af45076e7e4e028081383d502247e0953">lock_rec_lock_slow</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> impl, <a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a> sel_mode, ulint mode, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint heap_no, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:af45076e7e4e028081383d502247e0953"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the general, and slower, routine for locking a record.  <a href="#af45076e7e4e028081383d502247e0953">More...</a><br /></td></tr>
<tr class="separator:af45076e7e4e028081383d502247e0953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f9d4188fafaaf5d9dbdb95d6532e0c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#af9f9d4188fafaaf5d9dbdb95d6532e0c">lock_rec_lock</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> impl, <a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a> sel_mode, ulint mode, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint heap_no, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:af9f9d4188fafaaf5d9dbdb95d6532e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to lock the specified record in the mode requested.  <a href="#af9f9d4188fafaaf5d9dbdb95d6532e0c">More...</a><br /></td></tr>
<tr class="separator:af9f9d4188fafaaf5d9dbdb95d6532e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac354a74731c3f15924faea730a70f71a"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ac354a74731c3f15924faea730a70f71a">lock_rec_has_to_wait_in_queue</a> (const <a class="el" href="structlock__t.html">lock_t</a> *wait_lock, const <a class="el" href="structtrx__t.html">trx_t</a> *blocking_trx=<a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a>)</td></tr>
<tr class="memdesc:ac354a74731c3f15924faea730a70f71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a waiting record lock request still has to wait in a queue.  <a href="#ac354a74731c3f15924faea730a70f71a">More...</a><br /></td></tr>
<tr class="separator:ac354a74731c3f15924faea730a70f71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81303597fbce84d2814fb10f02a75cb4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a81303597fbce84d2814fb10f02a75cb4">lock_grant</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a81303597fbce84d2814fb10f02a75cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grants a lock to a waiting lock request and releases the waiting transaction.  <a href="#a81303597fbce84d2814fb10f02a75cb4">More...</a><br /></td></tr>
<tr class="separator:a81303597fbce84d2814fb10f02a75cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1140afd70eacb9aaae522805ac1f2270"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a1140afd70eacb9aaae522805ac1f2270">lock_make_trx_hit_list</a> (<a class="el" href="structtrx__t.html">trx_t</a> *hp_trx, <a class="el" href="trx0types_8h.html#a13121c5e3c7e683afe964f2903433257">hit_list_t</a> &amp;hit_list)</td></tr>
<tr class="memdesc:a1140afd70eacb9aaae522805ac1f2270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over the granted locks which conflict with trx-&gt;lock.wait_lock and prepare the hit list for ASYNC Rollback.  <a href="#a1140afd70eacb9aaae522805ac1f2270">More...</a><br /></td></tr>
<tr class="separator:a1140afd70eacb9aaae522805ac1f2270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa77b9fe490eac4349341da3a689dad"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a7aa77b9fe490eac4349341da3a689dad">lock_rec_cancel</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a7aa77b9fe490eac4349341da3a689dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels a waiting record lock request and releases the waiting transaction that requested it.  <a href="#a7aa77b9fe490eac4349341da3a689dad">More...</a><br /></td></tr>
<tr class="separator:a7aa77b9fe490eac4349341da3a689dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcc1f9fe684413ac1f7a92879666500"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#acfcc1f9fe684413ac1f7a92879666500">lock_update_wait_for_edge</a> (const <a class="el" href="structlock__t.html">lock_t</a> *waiting_lock, const <a class="el" href="structlock__t.html">lock_t</a> *blocking_lock)</td></tr>
<tr class="memdesc:acfcc1f9fe684413ac1f7a92879666500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a waiting_lock, and blocking_lock which is the reason it has to wait, makes sure that the (only) edge in the wait-for graph outgoing from the waiting_lock-&gt;trx points to blocking_lock-&gt;trx.  <a href="#acfcc1f9fe684413ac1f7a92879666500">More...</a><br /></td></tr>
<tr class="separator:acfcc1f9fe684413ac1f7a92879666500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac472658729904fde01384fc8722df156"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ac472658729904fde01384fc8722df156"><td class="memTemplItemLeft" align="right" valign="top">static const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ac472658729904fde01384fc8722df156">lock_rec_has_to_wait_for_granted</a> (const typename Container::value_type &amp;wait_lock, const Container &amp;granted, const size_t new_granted_index)</td></tr>
<tr class="memdesc:ac472658729904fde01384fc8722df156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a waiting record lock request still has to wait for granted locks.  <a href="#ac472658729904fde01384fc8722df156">More...</a><br /></td></tr>
<tr class="separator:ac472658729904fde01384fc8722df156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ee8ae5537f4080b9f3e7e092e35830"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a01ee8ae5537f4080b9f3e7e092e35830">lock_rec_grant_by_heap_no</a> (<a class="el" href="structlock__t.html">lock_t</a> *in_lock, ulint heap_no)</td></tr>
<tr class="memdesc:a01ee8ae5537f4080b9f3e7e092e35830"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grant a lock to waiting transactions.  <a href="#a01ee8ae5537f4080b9f3e7e092e35830">More...</a><br /></td></tr>
<tr class="separator:a01ee8ae5537f4080b9f3e7e092e35830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f79d0aaea95b1e11de40c0c0356936"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ac2f79d0aaea95b1e11de40c0c0356936">lock_has_to_wait_in_queue</a> (const <a class="el" href="structlock__t.html">lock_t</a> *wait_lock, const <a class="el" href="structtrx__t.html">trx_t</a> *blocking_trx)</td></tr>
<tr class="memdesc:ac2f79d0aaea95b1e11de40c0c0356936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a waiting lock request still has to wait in a queue.  <a href="#ac2f79d0aaea95b1e11de40c0c0356936">More...</a><br /></td></tr>
<tr class="separator:ac2f79d0aaea95b1e11de40c0c0356936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b96cb9271b055ba84eea36f6dc4fcd1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a7b96cb9271b055ba84eea36f6dc4fcd1">lock_grant_or_update_wait_for_edge</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a7b96cb9271b055ba84eea36f6dc4fcd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a lock, which was found in waiting queue, checks if it still has to wait in queue, and either grants it, or makes sure that the reason it has to wait is reflected in the wait-for graph.  <a href="#a7b96cb9271b055ba84eea36f6dc4fcd1">More...</a><br /></td></tr>
<tr class="separator:a7b96cb9271b055ba84eea36f6dc4fcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866c94e4b9e292db1ec60ad8de3e07d9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a866c94e4b9e292db1ec60ad8de3e07d9">lock_grant_or_update_wait_for_edge_if_waiting</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock, const <a class="el" href="structtrx__t.html">trx_t</a> *releasing_trx)</td></tr>
<tr class="memdesc:a866c94e4b9e292db1ec60ad8de3e07d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a lock, and a transaction which is releasing another lock from the same queue, makes sure that if the lock was waiting for this transaction, then it will either be granted, or another reason for waiting is reflected in the wait-for graph.  <a href="#a866c94e4b9e292db1ec60ad8de3e07d9">More...</a><br /></td></tr>
<tr class="separator:a866c94e4b9e292db1ec60ad8de3e07d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7d42b1e15b49c2d55413e7c8d62107"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#afe7d42b1e15b49c2d55413e7c8d62107">lock_rec_grant</a> (<a class="el" href="structlock__t.html">lock_t</a> *in_lock)</td></tr>
<tr class="memdesc:afe7d42b1e15b49c2d55413e7c8d62107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grant lock to waiting requests that no longer conflicts.  <a href="#afe7d42b1e15b49c2d55413e7c8d62107">More...</a><br /></td></tr>
<tr class="separator:afe7d42b1e15b49c2d55413e7c8d62107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400624ff6ae565a75b2894787172c809"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a400624ff6ae565a75b2894787172c809">lock_rec_dequeue_from_page</a> (<a class="el" href="structlock__t.html">lock_t</a> *in_lock)</td></tr>
<tr class="memdesc:a400624ff6ae565a75b2894787172c809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a record lock request, waiting or granted, from the queue and grants locks to other transactions in the queue if they now are entitled to a lock.  <a href="#a400624ff6ae565a75b2894787172c809">More...</a><br /></td></tr>
<tr class="separator:a400624ff6ae565a75b2894787172c809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb40b46c0751e5e8f8d6d9b841251a64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aeb40b46c0751e5e8f8d6d9b841251a64">lock_rec_discard</a> (<a class="el" href="structlock__t.html">lock_t</a> *in_lock)</td></tr>
<tr class="memdesc:aeb40b46c0751e5e8f8d6d9b841251a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a record lock request, waiting or granted, from the queue.  <a href="#aeb40b46c0751e5e8f8d6d9b841251a64">More...</a><br /></td></tr>
<tr class="separator:aeb40b46c0751e5e8f8d6d9b841251a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c487adb53263bd8c6e2e0c16f1022d5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a7c487adb53263bd8c6e2e0c16f1022d5">lock_rec_free_all_from_discard_page_low</a> (<a class="el" href="classpage__id__t.html">page_id_t</a> page_id, <a class="el" href="structhash__table__t.html">hash_table_t</a> *lock_hash)</td></tr>
<tr class="memdesc:a7c487adb53263bd8c6e2e0c16f1022d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes record lock objects set on an index page which is discarded.  <a href="#a7c487adb53263bd8c6e2e0c16f1022d5">More...</a><br /></td></tr>
<tr class="separator:a7c487adb53263bd8c6e2e0c16f1022d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9c55d69db3ad92b4af176625eac460"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a5f9c55d69db3ad92b4af176625eac460">lock_rec_free_all_from_discard_page</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a5f9c55d69db3ad92b4af176625eac460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes record lock objects set on an index page which is discarded.  <a href="#a5f9c55d69db3ad92b4af176625eac460">More...</a><br /></td></tr>
<tr class="separator:a5f9c55d69db3ad92b4af176625eac460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c38c5e5e038b3ff28600a1e1f81718f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a3c38c5e5e038b3ff28600a1e1f81718f">lock_rec_reset_and_release_wait_low</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *<a class="el" href="innodb__memcache_2cache-src_2hash_8h.html#a1c12edaae63f2e86a5b276a18475f863">hash</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint heap_no)</td></tr>
<tr class="memdesc:a3c38c5e5e038b3ff28600a1e1f81718f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the lock bits for a single record.  <a href="#a3c38c5e5e038b3ff28600a1e1f81718f">More...</a><br /></td></tr>
<tr class="separator:a3c38c5e5e038b3ff28600a1e1f81718f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a39c043b7a0da7ad896f9c8b1784d19"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a6a39c043b7a0da7ad896f9c8b1784d19">lock_rec_reset_and_release_wait</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint heap_no)</td></tr>
<tr class="memdesc:a6a39c043b7a0da7ad896f9c8b1784d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the lock bits for a single record.  <a href="#a6a39c043b7a0da7ad896f9c8b1784d19">More...</a><br /></td></tr>
<tr class="separator:a6a39c043b7a0da7ad896f9c8b1784d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9025c7188f98ef88d223591eb7fe0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aca9025c7188f98ef88d223591eb7fe0d">lock_on_statement_end</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:aca9025c7188f98ef88d223591eb7fe0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called to inform lock-sys that a statement processing for a trx has just finished.  <a href="#aca9025c7188f98ef88d223591eb7fe0d">More...</a><br /></td></tr>
<tr class="separator:aca9025c7188f98ef88d223591eb7fe0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0885d07165117fecfb5fc51ea0ae9d3b"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a0885d07165117fecfb5fc51ea0ae9d3b">lock_protect_locks_till_statement_end</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="separator:a0885d07165117fecfb5fc51ea0ae9d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad71a1e16ac85a11e9ac1f3111f707439"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ad71a1e16ac85a11e9ac1f3111f707439">lock_rec_inherit_to_gap</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *heir_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint heir_heap_no, ulint heap_no)</td></tr>
<tr class="memdesc:ad71a1e16ac85a11e9ac1f3111f707439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a record to inherit the locks (except LOCK_INSERT_INTENTION type) of another record as gap type locks, but does not reset the lock bits of the other record.  <a href="#ad71a1e16ac85a11e9ac1f3111f707439">More...</a><br /></td></tr>
<tr class="separator:ad71a1e16ac85a11e9ac1f3111f707439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb009afd28d954b9ba74693b823b4ad3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#acb009afd28d954b9ba74693b823b4ad3">lock_rec_inherit_to_gap_if_gap_lock</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint heir_heap_no, ulint heap_no)</td></tr>
<tr class="memdesc:acb009afd28d954b9ba74693b823b4ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a record to inherit the gap locks (except LOCK_INSERT_INTENTION type) of another record as gap type locks, but does not reset the lock bits of the other record.  <a href="#acb009afd28d954b9ba74693b823b4ad3">More...</a><br /></td></tr>
<tr class="separator:acb009afd28d954b9ba74693b823b4ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cabdc623d14c7e334fefb0771123f02"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a6cabdc623d14c7e334fefb0771123f02">lock_rec_move_low</a> (<a class="el" href="structhash__table__t.html">hash_table_t</a> *lock_hash, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *receiver, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *donator, ulint receiver_heap_no, ulint donator_heap_no)</td></tr>
<tr class="memdesc:a6cabdc623d14c7e334fefb0771123f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the locks of a record to another record and resets the lock bits of the donating record.  <a href="#a6cabdc623d14c7e334fefb0771123f02">More...</a><br /></td></tr>
<tr class="separator:a6cabdc623d14c7e334fefb0771123f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c347ac8a8ae8fb5353860412258b447"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a8c347ac8a8ae8fb5353860412258b447">lock_move_granted_locks_to_front</a> (<a class="el" href="row0mysql_8cc.html#aa70fd829bdc7a3b8160bef3726810973">UT_LIST_BASE_NODE_T</a>(<a class="el" href="structlock__t.html">lock_t</a>) &amp;lock_list)</td></tr>
<tr class="memdesc:a8c347ac8a8ae8fb5353860412258b447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move all the granted locks to the front of the given lock list.  <a href="#a8c347ac8a8ae8fb5353860412258b447">More...</a><br /></td></tr>
<tr class="separator:a8c347ac8a8ae8fb5353860412258b447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36451e4190af50f249bd167316ed50d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ac36451e4190af50f249bd167316ed50d">lock_rec_move</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *receiver, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *donator, ulint receiver_heap_no, ulint donator_heap_no)</td></tr>
<tr class="memdesc:ac36451e4190af50f249bd167316ed50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the locks of a record to another record and resets the lock bits of the donating record.  <a href="#ac36451e4190af50f249bd167316ed50d">More...</a><br /></td></tr>
<tr class="separator:ac36451e4190af50f249bd167316ed50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb133e68ef2953ee54049f280eff17af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#acb133e68ef2953ee54049f280eff17af">lock_move_reorganize_page</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *oblock)</td></tr>
<tr class="memdesc:acb133e68ef2953ee54049f280eff17af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when we have reorganized a page.  <a href="#acb133e68ef2953ee54049f280eff17af">More...</a><br /></td></tr>
<tr class="separator:acb133e68ef2953ee54049f280eff17af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a4bca65fd7f08390fbe370ab09fe24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a72a4bca65fd7f08390fbe370ab09fe24">lock_move_rec_list_end</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *new_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec)</td></tr>
<tr class="memdesc:a72a4bca65fd7f08390fbe370ab09fe24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the explicit locks on user records to another page if a record list end is moved to another page.  <a href="#a72a4bca65fd7f08390fbe370ab09fe24">More...</a><br /></td></tr>
<tr class="separator:a72a4bca65fd7f08390fbe370ab09fe24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856b4f10d6691a2c3446378525c1a9f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a856b4f10d6691a2c3446378525c1a9f2">lock_move_rec_list_start</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *new_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *old_end)</td></tr>
<tr class="memdesc:a856b4f10d6691a2c3446378525c1a9f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the explicit locks on user records to another page if a record list start is moved to another page.  <a href="#a856b4f10d6691a2c3446378525c1a9f2">More...</a><br /></td></tr>
<tr class="separator:a856b4f10d6691a2c3446378525c1a9f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fefbca8fe9d4d308d925eff524b4f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a47fefbca8fe9d4d308d925eff524b4f8">lock_rtr_move_rec_list</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *new_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="gis0type_8h.html#a2d71af64b5717827d5581da7a7b4a180">rtr_rec_move_t</a> *rec_move, ulint num_move)</td></tr>
<tr class="memdesc:a47fefbca8fe9d4d308d925eff524b4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the explicit locks on user records to another page if a record list start is moved to another page.  <a href="#a47fefbca8fe9d4d308d925eff524b4f8">More...</a><br /></td></tr>
<tr class="separator:a47fefbca8fe9d4d308d925eff524b4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af01b85f0aa5d1e2d0e026044673110"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a9af01b85f0aa5d1e2d0e026044673110">lock_update_split_right</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block)</td></tr>
<tr class="memdesc:a9af01b85f0aa5d1e2d0e026044673110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when a page is split to the right.  <a href="#a9af01b85f0aa5d1e2d0e026044673110">More...</a><br /></td></tr>
<tr class="separator:a9af01b85f0aa5d1e2d0e026044673110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d987baa574ae26300c02c38d3297aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a98d987baa574ae26300c02c38d3297aa">lock_update_merge_right</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *orig_succ, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block)</td></tr>
<tr class="memdesc:a98d987baa574ae26300c02c38d3297aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when a page is merged to the right.  <a href="#a98d987baa574ae26300c02c38d3297aa">More...</a><br /></td></tr>
<tr class="separator:a98d987baa574ae26300c02c38d3297aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60bc5af0ffa9cbef92444c2f36cbca0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aa60bc5af0ffa9cbef92444c2f36cbca0">lock_update_root_raise</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *root)</td></tr>
<tr class="memdesc:aa60bc5af0ffa9cbef92444c2f36cbca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when the root page is copied to another in btr_root_raise_and_insert.  <a href="#aa60bc5af0ffa9cbef92444c2f36cbca0">More...</a><br /></td></tr>
<tr class="separator:aa60bc5af0ffa9cbef92444c2f36cbca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d530560f93577d1c8b2865251a3a47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a72d530560f93577d1c8b2865251a3a47">lock_update_copy_and_discard</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *new_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a72d530560f93577d1c8b2865251a3a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when a page is copied to another and the original page is removed from the chain of leaf pages, except if page is the root!  <a href="#a72d530560f93577d1c8b2865251a3a47">More...</a><br /></td></tr>
<tr class="separator:a72d530560f93577d1c8b2865251a3a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c056f069cb338691dafe4665b8a4435"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a0c056f069cb338691dafe4665b8a4435">lock_update_split_left</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block)</td></tr>
<tr class="memdesc:a0c056f069cb338691dafe4665b8a4435"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when a page is split to the left.  <a href="#a0c056f069cb338691dafe4665b8a4435">More...</a><br /></td></tr>
<tr class="separator:a0c056f069cb338691dafe4665b8a4435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa151b0e44c3fd7542ef9441ac2125988"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aa151b0e44c3fd7542ef9441ac2125988">lock_update_merge_left</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *left_block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *orig_pred, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *right_block)</td></tr>
<tr class="memdesc:aa151b0e44c3fd7542ef9441ac2125988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when a page is merged to the left.  <a href="#aa151b0e44c3fd7542ef9441ac2125988">More...</a><br /></td></tr>
<tr class="separator:aa151b0e44c3fd7542ef9441ac2125988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a13c16488466902242a906b82422a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ad5a13c16488466902242a906b82422a7">lock_rec_reset_and_inherit_gap_locks</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *heir_block, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint heir_heap_no, ulint heap_no)</td></tr>
<tr class="memdesc:ad5a13c16488466902242a906b82422a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the original locks on heir and replaces them with gap type locks inherited from rec.  <a href="#ad5a13c16488466902242a906b82422a7">More...</a><br /></td></tr>
<tr class="separator:ad5a13c16488466902242a906b82422a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c59f431194af5e5f6a6842bfe50344"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a11c59f431194af5e5f6a6842bfe50344">lock_update_discard</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *heir_block, ulint heir_heap_no, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a11c59f431194af5e5f6a6842bfe50344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when a page is discarded.  <a href="#a11c59f431194af5e5f6a6842bfe50344">More...</a><br /></td></tr>
<tr class="separator:a11c59f431194af5e5f6a6842bfe50344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de1c790f6a289f4b803acab127b3755"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a3de1c790f6a289f4b803acab127b3755">lock_update_insert</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec)</td></tr>
<tr class="memdesc:a3de1c790f6a289f4b803acab127b3755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when a new user record is inserted.  <a href="#a3de1c790f6a289f4b803acab127b3755">More...</a><br /></td></tr>
<tr class="separator:a3de1c790f6a289f4b803acab127b3755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d9fef0df1b551f23c7da52fd68accd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aa2d9fef0df1b551f23c7da52fd68accd">lock_update_delete</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec)</td></tr>
<tr class="memdesc:aa2d9fef0df1b551f23c7da52fd68accd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the lock table when a record is removed.  <a href="#aa2d9fef0df1b551f23c7da52fd68accd">More...</a><br /></td></tr>
<tr class="separator:aa2d9fef0df1b551f23c7da52fd68accd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e2620fd1f715019989f11107c2de47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a63e2620fd1f715019989f11107c2de47">lock_rec_store_on_page_infimum</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec)</td></tr>
<tr class="memdesc:a63e2620fd1f715019989f11107c2de47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores on the page infimum record the explicit locks of another record.  <a href="#a63e2620fd1f715019989f11107c2de47">More...</a><br /></td></tr>
<tr class="separator:a63e2620fd1f715019989f11107c2de47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70020e803cb615546ffde6384bb8505"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ae70020e803cb615546ffde6384bb8505">lock_rec_restore_from_page_infimum</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *donator)</td></tr>
<tr class="memdesc:ae70020e803cb615546ffde6384bb8505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores the state of explicit lock requests on a single record, where the state was stored on the infimum of the page.  <a href="#ae70020e803cb615546ffde6384bb8505">More...</a><br /></td></tr>
<tr class="separator:ae70020e803cb615546ffde6384bb8505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184b272b7c4a2c9e49e7e973fbb2d4ed"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a184b272b7c4a2c9e49e7e973fbb2d4ed">lock_table_create</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ulint type_mode, <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a184b272b7c4a2c9e49e7e973fbb2d4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table lock object and adds it as the last in the lock queue of the table.  <a href="#a184b272b7c4a2c9e49e7e973fbb2d4ed">More...</a><br /></td></tr>
<tr class="separator:a184b272b7c4a2c9e49e7e973fbb2d4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae88eb4bd1862004641853bdac32e3da"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aae88eb4bd1862004641853bdac32e3da">lock_table_pop_autoinc_locks</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:aae88eb4bd1862004641853bdac32e3da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops autoinc lock requests from the transaction's autoinc_locks.  <a href="#aae88eb4bd1862004641853bdac32e3da">More...</a><br /></td></tr>
<tr class="separator:aae88eb4bd1862004641853bdac32e3da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678cd8514367bc1b2b43d3df58ce5325"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a678cd8514367bc1b2b43d3df58ce5325">lock_table_remove_autoinc_lock</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock, <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a678cd8514367bc1b2b43d3df58ce5325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an autoinc lock request from the transaction's autoinc_locks.  <a href="#a678cd8514367bc1b2b43d3df58ce5325">More...</a><br /></td></tr>
<tr class="separator:a678cd8514367bc1b2b43d3df58ce5325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3ef5a97ef26d0edfffcca4f4d413ed"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aab3ef5a97ef26d0edfffcca4f4d413ed">lock_table_remove_low</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:aab3ef5a97ef26d0edfffcca4f4d413ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a table lock request from the queue and the trx list of locks; this is a low-level function which does NOT check if waiting requests can now be granted.  <a href="#aab3ef5a97ef26d0edfffcca4f4d413ed">More...</a><br /></td></tr>
<tr class="separator:aab3ef5a97ef26d0edfffcca4f4d413ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc404f482d9124b4450bc71d73e69c6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aadc404f482d9124b4450bc71d73e69c6">lock_table_enqueue_waiting</a> (ulint mode, <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:aadc404f482d9124b4450bc71d73e69c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues a waiting request for a table lock which cannot be granted immediately.  <a href="#aadc404f482d9124b4450bc71d73e69c6">More...</a><br /></td></tr>
<tr class="separator:aadc404f482d9124b4450bc71d73e69c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd493385965cf18a23b428ffca184ca"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aebd493385965cf18a23b428ffca184ca">lock_table_other_has_incompatible</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *trx, ulint wait, const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode)</td></tr>
<tr class="memdesc:aebd493385965cf18a23b428ffca184ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if other transactions have an incompatible mode lock request in the lock queue.  <a href="#aebd493385965cf18a23b428ffca184ca">More...</a><br /></td></tr>
<tr class="separator:aebd493385965cf18a23b428ffca184ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a3a3e111f874ce25075882ef35dfd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ae1a3a3e111f874ce25075882ef35dfd9">lock_table</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:ae1a3a3e111f874ce25075882ef35dfd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the specified database table in the mode given.  <a href="#ae1a3a3e111f874ce25075882ef35dfd9">More...</a><br /></td></tr>
<tr class="separator:ae1a3a3e111f874ce25075882ef35dfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1d4aaa7d211a0b5fa98edcf3b7c09b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a8b1d4aaa7d211a0b5fa98edcf3b7c09b">lock_table_ix_resurrect</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a8b1d4aaa7d211a0b5fa98edcf3b7c09b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a table IX lock object for a resurrected transaction.  <a href="#a8b1d4aaa7d211a0b5fa98edcf3b7c09b">More...</a><br /></td></tr>
<tr class="separator:a8b1d4aaa7d211a0b5fa98edcf3b7c09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d214bf5c5587f08c7f0a24134ff138"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a00d214bf5c5587f08c7f0a24134ff138">lock_table_has_to_wait_in_queue</a> (const <a class="el" href="structlock__t.html">lock_t</a> *wait_lock, const <a class="el" href="structtrx__t.html">trx_t</a> *blocking_trx=<a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a>)</td></tr>
<tr class="memdesc:a00d214bf5c5587f08c7f0a24134ff138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a waiting table lock request still has to wait in a queue.  <a href="#a00d214bf5c5587f08c7f0a24134ff138">More...</a><br /></td></tr>
<tr class="separator:a00d214bf5c5587f08c7f0a24134ff138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10e4db7d11e1b4a0a5d3afd17467334"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aa10e4db7d11e1b4a0a5d3afd17467334">lock_table_dequeue</a> (<a class="el" href="structlock__t.html">lock_t</a> *in_lock)</td></tr>
<tr class="memdesc:aa10e4db7d11e1b4a0a5d3afd17467334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a table lock request, waiting or granted, from the queue and grants locks to other transactions in the queue, if they now are entitled to a lock.  <a href="#aa10e4db7d11e1b4a0a5d3afd17467334">More...</a><br /></td></tr>
<tr class="separator:aa10e4db7d11e1b4a0a5d3afd17467334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f8b30188b58505e53584a7c428a95d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a94f8b30188b58505e53584a7c428a95d">lock_table_for_trx</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structtrx__t.html">trx_t</a> *trx, enum <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode)</td></tr>
<tr class="memdesc:a94f8b30188b58505e53584a7c428a95d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a lock on a table based on the given mode.  <a href="#a94f8b30188b58505e53584a7c428a95d">More...</a><br /></td></tr>
<tr class="separator:a94f8b30188b58505e53584a7c428a95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ed500b53a738294018138bbebc18d5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aa0ed500b53a738294018138bbebc18d5">lock_rec_release</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock, ulint heap_no)</td></tr>
<tr class="memdesc:aa0ed500b53a738294018138bbebc18d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grant a lock to waiting transactions.  <a href="#aa0ed500b53a738294018138bbebc18d5">More...</a><br /></td></tr>
<tr class="separator:aa0ed500b53a738294018138bbebc18d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385872f00cebe85ef57ac1ee1d1a9ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a385872f00cebe85ef57ac1ee1d1a9ec5">lock_rec_unlock</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>)</td></tr>
<tr class="memdesc:a385872f00cebe85ef57ac1ee1d1a9ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a granted record lock of a transaction from the queue and grants locks to other transactions waiting in the queue if they now are entitled to a lock.  <a href="#a385872f00cebe85ef57ac1ee1d1a9ec5">More...</a><br /></td></tr>
<tr class="separator:a385872f00cebe85ef57ac1ee1d1a9ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dd528e3d441f569e6d841e63515163"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a63dd528e3d441f569e6d841e63515163">lock_release_gap_lock</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a63dd528e3d441f569e6d841e63515163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the GAP Lock part of a Next Key Lock and grant it to waiters (if any)  <a href="#a63dd528e3d441f569e6d841e63515163">More...</a><br /></td></tr>
<tr class="separator:a63dd528e3d441f569e6d841e63515163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af277e85e3615915a087ab2ad35ff58c9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#af277e85e3615915a087ab2ad35ff58c9">lock_release_read_lock</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> only_gap)</td></tr>
<tr class="memdesc:af277e85e3615915a087ab2ad35ff58c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to release a lock during PREPARE.  <a href="#af277e85e3615915a087ab2ad35ff58c9">More...</a><br /></td></tr>
<tr class="separator:af277e85e3615915a087ab2ad35ff58c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da402d07739d1d099f98afb05344482"><td class="memTemplParams" colspan="2">template&lt;typename S , typename F &gt; </td></tr>
<tr class="memitem:a1da402d07739d1d099f98afb05344482"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#a1da402d07739d1d099f98afb05344482">locksys::try_relatch_trx_and_shard_and_do</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *const trx, const S &amp;shard, F &amp;&amp;f)</td></tr>
<tr class="memdesc:a1da402d07739d1d099f98afb05344482"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function which solves a chicken-and-egg problem occurring when one needs to iterate over trx's locks and perform some actions on them.  <a href="namespacelocksys.html#a1da402d07739d1d099f98afb05344482">More...</a><br /></td></tr>
<tr class="separator:a1da402d07739d1d099f98afb05344482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a88ff4c19bb1ed119e34098acbf1b6"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a27a88ff4c19bb1ed119e34098acbf1b6"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#a27a88ff4c19bb1ed119e34098acbf1b6">locksys::try_relatch_trx_and_shard_and_do</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock, F &amp;&amp;f)</td></tr>
<tr class="memdesc:a27a88ff4c19bb1ed119e34098acbf1b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function which solves a chicken-and-egg problem occurring when one needs to iterate over trx's locks and perform some actions on them.  <a href="namespacelocksys.html#a27a88ff4c19bb1ed119e34098acbf1b6">More...</a><br /></td></tr>
<tr class="separator:a27a88ff4c19bb1ed119e34098acbf1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5111ef8b4eb131b61de48ae3b7a0145d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#a5111ef8b4eb131b61de48ae3b7a0145d">locksys::try_release_read_locks_in_s_mode</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> only_gap)</td></tr>
<tr class="memdesc:a5111ef8b4eb131b61de48ae3b7a0145d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to release read locks of a transaction without latching the whole lock sys.  <a href="namespacelocksys.html#a5111ef8b4eb131b61de48ae3b7a0145d">More...</a><br /></td></tr>
<tr class="separator:a5111ef8b4eb131b61de48ae3b7a0145d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adabe4366256b19cd9b6dd50e530d6b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a8adabe4366256b19cd9b6dd50e530d6b">lock_trx_release_read_locks_in_x_mode</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> only_gap)</td></tr>
<tr class="memdesc:a8adabe4366256b19cd9b6dd50e530d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release read locks of a transacion latching the whole lock-sys in exclusive mode, which is a bit too expensive to do by default.  <a href="#a8adabe4366256b19cd9b6dd50e530d6b">More...</a><br /></td></tr>
<tr class="separator:a8adabe4366256b19cd9b6dd50e530d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837664214700c0a21ff9c6ab1085fa76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a837664214700c0a21ff9c6ab1085fa76">lock_trx_release_read_locks</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> only_gap)</td></tr>
<tr class="memdesc:a837664214700c0a21ff9c6ab1085fa76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release read locks of a transaction.  <a href="#a837664214700c0a21ff9c6ab1085fa76">More...</a><br /></td></tr>
<tr class="separator:a837664214700c0a21ff9c6ab1085fa76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8eda56dfbfc87c40fc55a96c779b32"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#add8eda56dfbfc87c40fc55a96c779b32">lock_release</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:add8eda56dfbfc87c40fc55a96c779b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases transaction locks, and releases possible other transactions waiting because of these locks.  <a href="#add8eda56dfbfc87c40fc55a96c779b32">More...</a><br /></td></tr>
<tr class="separator:add8eda56dfbfc87c40fc55a96c779b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abfdceec128a59cd3c1ad2569bb3eaf"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a7abfdceec128a59cd3c1ad2569bb3eaf">lock_trx_table_locks_remove</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock_to_remove)</td></tr>
<tr class="memdesc:a7abfdceec128a59cd3c1ad2569bb3eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes lock_to_remove from lock_to_remove-&gt;trx-&gt;lock.table_locks.  <a href="#a7abfdceec128a59cd3c1ad2569bb3eaf">More...</a><br /></td></tr>
<tr class="separator:a7abfdceec128a59cd3c1ad2569bb3eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c114fec902791921c84d744e35e6f20"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a2c114fec902791921c84d744e35e6f20">lock_remove_all_on_table_for_trx</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, <a class="el" href="structtrx__t.html">trx_t</a> *trx, ibool remove_also_table_sx_locks)</td></tr>
<tr class="memdesc:a2c114fec902791921c84d744e35e6f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes locks of a transaction on a table to be dropped.  <a href="#a2c114fec902791921c84d744e35e6f20">More...</a><br /></td></tr>
<tr class="separator:a2c114fec902791921c84d744e35e6f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0441a5473b53bfbed8aeec335812c381"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a0441a5473b53bfbed8aeec335812c381">lock_remove_recovered_trx_record_locks</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a0441a5473b53bfbed8aeec335812c381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove any explicit record locks held by recovering transactions on the table.  <a href="#a0441a5473b53bfbed8aeec335812c381">More...</a><br /></td></tr>
<tr class="separator:a0441a5473b53bfbed8aeec335812c381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef596f4d04a32dc7eeea3e7a8481341"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a2ef596f4d04a32dc7eeea3e7a8481341">lock_remove_all_on_table</a> (<a class="el" href="structdict__table__t.html">dict_table_t</a> *table, ibool remove_also_table_sx_locks)</td></tr>
<tr class="memdesc:a2ef596f4d04a32dc7eeea3e7a8481341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes locks on a table to be dropped.  <a href="#a2ef596f4d04a32dc7eeea3e7a8481341">More...</a><br /></td></tr>
<tr class="separator:a2ef596f4d04a32dc7eeea3e7a8481341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3916adee88293aa3f29a6e3994248d93"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a3916adee88293aa3f29a6e3994248d93">lock_table_print</a> (FILE *file, const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a3916adee88293aa3f29a6e3994248d93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints info of a table lock.  <a href="#a3916adee88293aa3f29a6e3994248d93">More...</a><br /></td></tr>
<tr class="separator:a3916adee88293aa3f29a6e3994248d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84aa5902c8064caabb3ba36dd65c7903"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a84aa5902c8064caabb3ba36dd65c7903">lock_rec_print</a> (FILE *file, const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a84aa5902c8064caabb3ba36dd65c7903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints info of a record lock.  <a href="#a84aa5902c8064caabb3ba36dd65c7903">More...</a><br /></td></tr>
<tr class="separator:a84aa5902c8064caabb3ba36dd65c7903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371526911982293902d4239c71ae59b3"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a371526911982293902d4239c71ae59b3">lock_get_n_rec_locks</a> (void)</td></tr>
<tr class="memdesc:a371526911982293902d4239c71ae59b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the number of record lock structs in the record lock hash table.  <a href="#a371526911982293902d4239c71ae59b3">More...</a><br /></td></tr>
<tr class="separator:a371526911982293902d4239c71ae59b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396c1bdffc5e098c024ad929ba594dd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a396c1bdffc5e098c024ad929ba594dd8">lock_print_info_summary</a> (FILE *file)</td></tr>
<tr class="memdesc:a396c1bdffc5e098c024ad929ba594dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints info of locks for all transactions.  <a href="#a396c1bdffc5e098c024ad929ba594dd8">More...</a><br /></td></tr>
<tr class="separator:a396c1bdffc5e098c024ad929ba594dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b2ef62b3cd2784b7d3d3c442d9a320"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aa4b2ef62b3cd2784b7d3d3c442d9a320">lock_trx_print_wait_and_mvcc_state</a> (FILE *file, const <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:aa4b2ef62b3cd2784b7d3d3c442d9a320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints transaction lock wait and MVCC state.  <a href="#aa4b2ef62b3cd2784b7d3d3c442d9a320">More...</a><br /></td></tr>
<tr class="separator:aa4b2ef62b3cd2784b7d3d3c442d9a320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d0bb8788b9f644fe80225afb07af43"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a11d0bb8788b9f644fe80225afb07af43">lock_rec_fetch_page</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a11d0bb8788b9f644fe80225afb07af43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the page containing the record protected by the given lock.  <a href="#a11d0bb8788b9f644fe80225afb07af43">More...</a><br /></td></tr>
<tr class="separator:a11d0bb8788b9f644fe80225afb07af43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61a28220b173b01cf7ca52d7e056ec4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#af61a28220b173b01cf7ca52d7e056ec4">lock_trx_print_locks</a> (FILE *file, const <a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="classTrxLockIterator.html">TrxLockIterator</a> &amp;iter, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> load_block)</td></tr>
<tr class="memdesc:af61a28220b173b01cf7ca52d7e056ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints info of locks for a transaction.  <a href="#af61a28220b173b01cf7ca52d7e056ec4">More...</a><br /></td></tr>
<tr class="separator:af61a28220b173b01cf7ca52d7e056ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc5c7b8bef35ee70ba968607a22fb24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#abdc5c7b8bef35ee70ba968607a22fb24">lock_print_info_all_transactions</a> (FILE *file)</td></tr>
<tr class="memdesc:abdc5c7b8bef35ee70ba968607a22fb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints info of locks for each transaction.  <a href="#abdc5c7b8bef35ee70ba968607a22fb24">More...</a><br /></td></tr>
<tr class="separator:abdc5c7b8bef35ee70ba968607a22fb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad933826c1fceedca17c0491ff82e24"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aaad933826c1fceedca17c0491ff82e24">lock_trx_table_locks_find</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *trx, const <a class="el" href="structlock__t.html">lock_t</a> *find_lock)</td></tr>
<tr class="memdesc:aaad933826c1fceedca17c0491ff82e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the lock exists in the trx_t::trx_lock_t::table_locks vector.  <a href="#aaad933826c1fceedca17c0491ff82e24">More...</a><br /></td></tr>
<tr class="separator:aaad933826c1fceedca17c0491ff82e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad446d238fbe34e26616c0bec50c1cb7d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ad446d238fbe34e26616c0bec50c1cb7d">lock_table_queue_validate</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:ad446d238fbe34e26616c0bec50c1cb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the lock queue on a table.  <a href="#ad446d238fbe34e26616c0bec50c1cb7d">More...</a><br /></td></tr>
<tr class="separator:ad446d238fbe34e26616c0bec50c1cb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1668fe06bde62612ac9befffccb9a648"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#a1668fe06bde62612ac9befffccb9a648">locksys::rec_queue_validate_latched</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets)</td></tr>
<tr class="memdesc:a1668fe06bde62612ac9befffccb9a648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the lock queue on a single record.  <a href="namespacelocksys.html#a1668fe06bde62612ac9befffccb9a648">More...</a><br /></td></tr>
<tr class="separator:a1668fe06bde62612ac9befffccb9a648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75de06625a0a151b8b232e45ebca39d3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#a75de06625a0a151b8b232e45ebca39d3">locksys::rec_queue_latch_and_validate</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets)</td></tr>
<tr class="memdesc:a75de06625a0a151b8b232e45ebca39d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the lock queue on a single record.  <a href="namespacelocksys.html#a75de06625a0a151b8b232e45ebca39d3">More...</a><br /></td></tr>
<tr class="separator:a75de06625a0a151b8b232e45ebca39d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09144fa2bf618dd1bb20130333d37a88"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelocksys.html#a09144fa2bf618dd1bb20130333d37a88">locksys::rec_queue_latch_and_validate</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a09144fa2bf618dd1bb20130333d37a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the lock queue on a single record.  <a href="namespacelocksys.html#a09144fa2bf618dd1bb20130333d37a88">More...</a><br /></td></tr>
<tr class="separator:a09144fa2bf618dd1bb20130333d37a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cdc6c7c0c17d28163ffaa415e177ad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a56cdc6c7c0c17d28163ffaa415e177ad">lock_validate_table_locks</a> (const trx_ut_list_t *trx_list)</td></tr>
<tr class="memdesc:a56cdc6c7c0c17d28163ffaa415e177ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the table locks.  <a href="#a56cdc6c7c0c17d28163ffaa415e177ad">More...</a><br /></td></tr>
<tr class="separator:a56cdc6c7c0c17d28163ffaa415e177ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2621d11a343f8fcb24b1b93a9a90541"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ab2621d11a343f8fcb24b1b93a9a90541">lock_rec_block_validate</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id)</td></tr>
<tr class="memdesc:ab2621d11a343f8fcb24b1b93a9a90541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a record lock's block.  <a href="#ab2621d11a343f8fcb24b1b93a9a90541">More...</a><br /></td></tr>
<tr class="separator:ab2621d11a343f8fcb24b1b93a9a90541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aba7196cfa609a25581a9c37537b697"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a4aba7196cfa609a25581a9c37537b697">lock_validate</a> ()</td></tr>
<tr class="memdesc:a4aba7196cfa609a25581a9c37537b697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the lock system.  <a href="#a4aba7196cfa609a25581a9c37537b697">More...</a><br /></td></tr>
<tr class="separator:a4aba7196cfa609a25581a9c37537b697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d6fd7d2966684cc39668db595f5c3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#af3d6fd7d2966684cc39668db595f5c3a">lock_rec_insert_check_and_lock</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, ibool *inherit)</td></tr>
<tr class="memdesc:af3d6fd7d2966684cc39668db595f5c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if locks of other transactions prevent an immediate insert of a record.  <a href="#af3d6fd7d2966684cc39668db595f5c3a">More...</a><br /></td></tr>
<tr class="separator:af3d6fd7d2966684cc39668db595f5c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dd65c796e749fff4fedd4b8ecec98b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a65dd65c796e749fff4fedd4b8ecec98b">lock_rec_convert_impl_to_expl_for_trx</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, <a class="el" href="structtrx__t.html">trx_t</a> *trx, ulint heap_no)</td></tr>
<tr class="memdesc:a65dd65c796e749fff4fedd4b8ecec98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an explicit record lock for a running transaction that currently only has an implicit lock on the record.  <a href="#a65dd65c796e749fff4fedd4b8ecec98b">More...</a><br /></td></tr>
<tr class="separator:a65dd65c796e749fff4fedd4b8ecec98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6872a342e01b3ae5cc2132301afec259"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a6872a342e01b3ae5cc2132301afec259">lock_rec_convert_impl_to_expl</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets)</td></tr>
<tr class="memdesc:a6872a342e01b3ae5cc2132301afec259"><td class="mdescLeft">&#160;</td><td class="mdescRight">If a transaction has an implicit x-lock on a record, but no explicit x-lock set on the record, sets one for it.  <a href="#a6872a342e01b3ae5cc2132301afec259">More...</a><br /></td></tr>
<tr class="separator:a6872a342e01b3ae5cc2132301afec259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98fb0ca09acc1516e030769b0ba8358"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ac98fb0ca09acc1516e030769b0ba8358">lock_rec_convert_active_impl_to_expl</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, <a class="el" href="structtrx__t.html">trx_t</a> *trx, ulint heap_no)</td></tr>
<tr class="memdesc:ac98fb0ca09acc1516e030769b0ba8358"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is kind of wrapper to lock_rec_convert_impl_to_expl_for_trx() function with functionailty added to facilitate lock conversion from implicit to explicit for partial rollback cases.  <a href="#ac98fb0ca09acc1516e030769b0ba8358">More...</a><br /></td></tr>
<tr class="separator:ac98fb0ca09acc1516e030769b0ba8358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf66df1ce4412d6d621cdc8b77859e81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aaf66df1ce4412d6d621cdc8b77859e81">lock_clust_rec_modify_check_and_lock</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:aaf66df1ce4412d6d621cdc8b77859e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if locks of other transactions prevent an immediate modify (update, delete mark, or delete unmark) of a clustered index record.  <a href="#aaf66df1ce4412d6d621cdc8b77859e81">More...</a><br /></td></tr>
<tr class="separator:aaf66df1ce4412d6d621cdc8b77859e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00980a4b5a19525a76a41633a5acfb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ae00980a4b5a19525a76a41633a5acfb2">lock_sec_rec_modify_check_and_lock</a> (ulint <a class="el" href="mi__test1_8cc.html#a6eec09a91807e20d7b3d6ef3da594067">flags</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ae00980a4b5a19525a76a41633a5acfb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if locks of other transactions prevent an immediate modify (delete mark or delete unmark) of a secondary index record.  <a href="#ae00980a4b5a19525a76a41633a5acfb2">More...</a><br /></td></tr>
<tr class="separator:ae00980a4b5a19525a76a41633a5acfb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad964d7dd2bf2a24e44069405e7ef1011"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ad964d7dd2bf2a24e44069405e7ef1011">lock_sec_rec_read_check_and_lock</a> (const <a class="el" href="lock0lock_8h.html#adfd720ce09a7e9babfd890d6a3c3d0a3">lock_duration_t</a> duration, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, const <a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a> sel_mode, const <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode, const ulint gap_mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:ad964d7dd2bf2a24e44069405e7ef1011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like lock_clust_rec_read_check_and_lock(), but reads a secondary index record.  <a href="#ad964d7dd2bf2a24e44069405e7ef1011">More...</a><br /></td></tr>
<tr class="separator:ad964d7dd2bf2a24e44069405e7ef1011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e524b2ce5982cf66b3227d12c89f8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a76e524b2ce5982cf66b3227d12c89f8c">lock_clust_rec_read_check_and_lock</a> (const <a class="el" href="lock0lock_8h.html#adfd720ce09a7e9babfd890d6a3c3d0a3">lock_duration_t</a> duration, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, const <a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a> sel_mode, const <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode, const ulint gap_mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a76e524b2ce5982cf66b3227d12c89f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if locks of other transactions prevent an immediate read, or passing over by a read cursor, of a clustered index record.  <a href="#a76e524b2ce5982cf66b3227d12c89f8c">More...</a><br /></td></tr>
<tr class="separator:a76e524b2ce5982cf66b3227d12c89f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57805d4a0fcad73101c822963168dca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a57805d4a0fcad73101c822963168dca0">lock_clust_rec_read_check_and_lock_alt</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a> mode, ulint gap_mode, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a57805d4a0fcad73101c822963168dca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if locks of other transactions prevent an immediate read, or passing over by a read cursor, of a clustered index record.  <a href="#a57805d4a0fcad73101c822963168dca0">More...</a><br /></td></tr>
<tr class="separator:a57805d4a0fcad73101c822963168dca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a50f54e8700cb44a27c398426a6308"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a92a50f54e8700cb44a27c398426a6308">lock_release_autoinc_last_lock</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a92a50f54e8700cb44a27c398426a6308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the last lock from the transaction's autoinc locks.  <a href="#a92a50f54e8700cb44a27c398426a6308">More...</a><br /></td></tr>
<tr class="separator:a92a50f54e8700cb44a27c398426a6308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9583aff22e270def04a7697faaa1e9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aed9583aff22e270def04a7697faaa1e9">lock_trx_holds_autoinc_locks</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:aed9583aff22e270def04a7697faaa1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a transaction holds any autoinc locks.  <a href="#aed9583aff22e270def04a7697faaa1e9">More...</a><br /></td></tr>
<tr class="separator:aed9583aff22e270def04a7697faaa1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0586798d137559b27f00d9212a565ed7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a0586798d137559b27f00d9212a565ed7">lock_release_autoinc_locks</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a0586798d137559b27f00d9212a565ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release all the transaction's autoinc locks.  <a href="#a0586798d137559b27f00d9212a565ed7">More...</a><br /></td></tr>
<tr class="separator:a0586798d137559b27f00d9212a565ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a374b98595a50acd2ec82df4e1952d51e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a374b98595a50acd2ec82df4e1952d51e">lock_get_type</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a374b98595a50acd2ec82df4e1952d51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of a lock.  <a href="#a374b98595a50acd2ec82df4e1952d51e">More...</a><br /></td></tr>
<tr class="separator:a374b98595a50acd2ec82df4e1952d51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0570cd0fb05c95af79ac66dcea8c636b"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a0570cd0fb05c95af79ac66dcea8c636b">lock_get_trx_immutable_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a0570cd0fb05c95af79ac66dcea8c636b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the immutable id of the transaction owning a lock.  <a href="#a0570cd0fb05c95af79ac66dcea8c636b">More...</a><br /></td></tr>
<tr class="separator:a0570cd0fb05c95af79ac66dcea8c636b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abecbf8e0ed8c9de8a425e360a40ac779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#abecbf8e0ed8c9de8a425e360a40ac779">lock_get_trx_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:abecbf8e0ed8c9de8a425e360a40ac779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the id of the transaction owning a lock.  <a href="#abecbf8e0ed8c9de8a425e360a40ac779">More...</a><br /></td></tr>
<tr class="separator:abecbf8e0ed8c9de8a425e360a40ac779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1dd693350e9ebc88a5f07f4a9236d4"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a0a1dd693350e9ebc88a5f07f4a9236d4">lock_get_immutable_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a0a1dd693350e9ebc88a5f07f4a9236d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the immutable id of this lock.  <a href="#a0a1dd693350e9ebc88a5f07f4a9236d4">More...</a><br /></td></tr>
<tr class="separator:a0a1dd693350e9ebc88a5f07f4a9236d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecc4ffef7bce145529de20c3ee12d36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#acecc4ffef7bce145529de20c3ee12d36">lock_get_psi_event</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *<a class="el" href="my__thr__init_8cc.html#a670cae2ed1025603c1d5b6712d264645">thread_id</a>, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *event_id)</td></tr>
<tr class="memdesc:acecc4ffef7bce145529de20c3ee12d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the performance schema event (thread_id, event_id) that created the lock.  <a href="#acecc4ffef7bce145529de20c3ee12d36">More...</a><br /></td></tr>
<tr class="separator:acecc4ffef7bce145529de20c3ee12d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d39383d7ac9dd4ca34a24f271a1baf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ac7d39383d7ac9dd4ca34a24f271a1baf">lock_get_first_trx_locks</a> (const <a class="el" href="structtrx__lock__t.html">trx_lock_t</a> *trx_lock)</td></tr>
<tr class="memdesc:ac7d39383d7ac9dd4ca34a24f271a1baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first lock of a trx lock list.  <a href="#ac7d39383d7ac9dd4ca34a24f271a1baf">More...</a><br /></td></tr>
<tr class="separator:ac7d39383d7ac9dd4ca34a24f271a1baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b99bda2e15de31f306979231d1f5436"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a5b99bda2e15de31f306979231d1f5436">lock_get_next_trx_locks</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a5b99bda2e15de31f306979231d1f5436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the next lock of a trx lock list.  <a href="#a5b99bda2e15de31f306979231d1f5436">More...</a><br /></td></tr>
<tr class="separator:a5b99bda2e15de31f306979231d1f5436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb165a7de4839caf9783cade418f7703"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aeb165a7de4839caf9783cade418f7703">lock_get_mode_str</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:aeb165a7de4839caf9783cade418f7703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the mode of a lock in a human readable string.  <a href="#aeb165a7de4839caf9783cade418f7703">More...</a><br /></td></tr>
<tr class="separator:aeb165a7de4839caf9783cade418f7703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae17fad2ea0c4abe3252d4089e6a6a5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a2ae17fad2ea0c4abe3252d4089e6a6a5">lock_get_type_str</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a2ae17fad2ea0c4abe3252d4089e6a6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the type of a lock in a human readable string.  <a href="#a2ae17fad2ea0c4abe3252d4089e6a6a5">More...</a><br /></td></tr>
<tr class="separator:a2ae17fad2ea0c4abe3252d4089e6a6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f90ccf6fab644d41a404db1d27e948"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a88f90ccf6fab644d41a404db1d27e948">lock_get_table</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a88f90ccf6fab644d41a404db1d27e948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the table on which the lock is.  <a href="#a88f90ccf6fab644d41a404db1d27e948">More...</a><br /></td></tr>
<tr class="separator:a88f90ccf6fab644d41a404db1d27e948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f014df68b9ac74600c80de96092b91c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dict0types_8h.html#ac877e05c194a7c04fa5921c88cdcb1f7">table_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a7f014df68b9ac74600c80de96092b91c">lock_get_table_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a7f014df68b9ac74600c80de96092b91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the id of the table on which the lock is.  <a href="#a7f014df68b9ac74600c80de96092b91c">More...</a><br /></td></tr>
<tr class="separator:a7f014df68b9ac74600c80de96092b91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd305f10c527e77d4f78fbb758b89b6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structtable__name__t.html">table_name_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#acfd305f10c527e77d4f78fbb758b89b6">lock_get_table_name</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:acfd305f10c527e77d4f78fbb758b89b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine which table a lock is associated with.  <a href="#acfd305f10c527e77d4f78fbb758b89b6">More...</a><br /></td></tr>
<tr class="separator:acfd305f10c527e77d4f78fbb758b89b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489f292f2abfd59464a820e4ef3efdf6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a489f292f2abfd59464a820e4ef3efdf6">lock_rec_get_index</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a489f292f2abfd59464a820e4ef3efdf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a record lock, gets the index on which the lock is.  <a href="#a489f292f2abfd59464a820e4ef3efdf6">More...</a><br /></td></tr>
<tr class="separator:a489f292f2abfd59464a820e4ef3efdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07cae5f235e5f095fb70d92c8d2e0bc6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a07cae5f235e5f095fb70d92c8d2e0bc6">lock_rec_get_index_name</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:a07cae5f235e5f095fb70d92c8d2e0bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a record lock, gets the name of the index on which the lock is.  <a href="#a07cae5f235e5f095fb70d92c8d2e0bc6">More...</a><br /></td></tr>
<tr class="separator:a07cae5f235e5f095fb70d92c8d2e0bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa95ea09f1777797a5e22cb63720d483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpage__id__t.html">page_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aaa95ea09f1777797a5e22cb63720d483">lock_rec_get_page_id</a> (const <a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:aaa95ea09f1777797a5e22cb63720d483"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a record lock, gets the tablespace number and page number on which the lock is.  <a href="#aaa95ea09f1777797a5e22cb63720d483">More...</a><br /></td></tr>
<tr class="separator:aaa95ea09f1777797a5e22cb63720d483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca77337242c4af78b916e503a81b57e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aca77337242c4af78b916e503a81b57e2">lock_cancel_waiting_and_release</a> (<a class="el" href="structlock__t.html">lock_t</a> *lock)</td></tr>
<tr class="memdesc:aca77337242c4af78b916e503a81b57e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancels a waiting lock request and releases possible other transactions waiting behind it.  <a href="#aca77337242c4af78b916e503a81b57e2">More...</a><br /></td></tr>
<tr class="separator:aca77337242c4af78b916e503a81b57e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af6183a5555e7a95a366be8aaa7f280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a5af6183a5555e7a95a366be8aaa7f280">lock_unlock_table_autoinc</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a5af6183a5555e7a95a366be8aaa7f280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks AUTO_INC type locks that were possibly reserved by a trx.  <a href="#a5af6183a5555e7a95a366be8aaa7f280">More...</a><br /></td></tr>
<tr class="separator:a5af6183a5555e7a95a366be8aaa7f280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbb256f6d14ba050d686b9ba1d007b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a0fbb256f6d14ba050d686b9ba1d007b0">lock_trx_release_locks</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:a0fbb256f6d14ba050d686b9ba1d007b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases a transaction's locks, and releases possible other transactions waiting because of these locks.  <a href="#a0fbb256f6d14ba050d686b9ba1d007b0">More...</a><br /></td></tr>
<tr class="separator:a0fbb256f6d14ba050d686b9ba1d007b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefbced8febccb3e8ab67e20ee33b0b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aeefbced8febccb3e8ab67e20ee33b0b4">lock_trx_handle_wait</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:aeefbced8febccb3e8ab67e20ee33b0b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether the transaction has already been rolled back because it was selected as a deadlock victim, or if it has to wait then cancel the wait lock.  <a href="#aeefbced8febccb3e8ab67e20ee33b0b4">More...</a><br /></td></tr>
<tr class="separator:aeefbced8febccb3e8ab67e20ee33b0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1fa8e49263ea226696d339f29a685f"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#aca1fa8e49263ea226696d339f29a685f">lock_table_locks_lookup</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const trx_ut_list_t *trx_list)</td></tr>
<tr class="memdesc:aca1fa8e49263ea226696d339f29a685f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do an exhaustive check for any locks (table or rec) against the table.  <a href="#aca1fa8e49263ea226696d339f29a685f">More...</a><br /></td></tr>
<tr class="separator:aca1fa8e49263ea226696d339f29a685f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7271bf61ea0010a2552e9343dad624c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a7271bf61ea0010a2552e9343dad624c3">lock_table_has_locks</a> (const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a7271bf61ea0010a2552e9343dad624c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there are any locks (table or rec) against table.  <a href="#a7271bf61ea0010a2552e9343dad624c3">More...</a><br /></td></tr>
<tr class="separator:a7271bf61ea0010a2552e9343dad624c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df4975363491df12966baa045ea3546"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a8df4975363491df12966baa045ea3546">lock_table_lock_list_init</a> (<a class="el" href="dict0mem_8h.html#a47e92c93f6a5c35342487951b263812d">table_lock_list_t</a> *lock_list)</td></tr>
<tr class="memdesc:a8df4975363491df12966baa045ea3546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the table lock list.  <a href="#a8df4975363491df12966baa045ea3546">More...</a><br /></td></tr>
<tr class="separator:a8df4975363491df12966baa045ea3546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f5f27eeb669c559bcf49469cbe3d16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a82f5f27eeb669c559bcf49469cbe3d16">lock_trx_lock_list_init</a> (trx_lock_list_t *lock_list)</td></tr>
<tr class="memdesc:a82f5f27eeb669c559bcf49469cbe3d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the trx lock list.  <a href="#a82f5f27eeb669c559bcf49469cbe3d16">More...</a><br /></td></tr>
<tr class="separator:a82f5f27eeb669c559bcf49469cbe3d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ba28814c32fc40e4c71c8a32f6fdba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#af0ba28814c32fc40e4c71c8a32f6fdba">lock_set_timeout_event</a> ()</td></tr>
<tr class="memdesc:af0ba28814c32fc40e4c71c8a32f6fdba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the lock system timeout event.  <a href="#af0ba28814c32fc40e4c71c8a32f6fdba">More...</a><br /></td></tr>
<tr class="separator:af0ba28814c32fc40e4c71c8a32f6fdba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99887080ffdb266d6f94b5938ab423d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a99887080ffdb266d6f94b5938ab423d2">lock_trx_has_rec_x_lock</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, const <a class="el" href="structdict__table__t.html">dict_table_t</a> *table, const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint heap_no)</td></tr>
<tr class="memdesc:a99887080ffdb266d6f94b5938ab423d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the transaction holds an exclusive lock on a record.  <a href="#a99887080ffdb266d6f94b5938ab423d2">More...</a><br /></td></tr>
<tr class="separator:a99887080ffdb266d6f94b5938ab423d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd23066177e056191e90bae4f14215e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#afd23066177e056191e90bae4f14215e0">lock_trx_alloc_locks</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:afd23066177e056191e90bae4f14215e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate cached locks for the transaction.  <a href="#afd23066177e056191e90bae4f14215e0">More...</a><br /></td></tr>
<tr class="separator:afd23066177e056191e90bae4f14215e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9b9cd959650891d83421c521909b88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a1f9b9cd959650891d83421c521909b88">lock_notify_about_deadlock</a> (const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; const <a class="el" href="structtrx__t.html">trx_t</a> *&gt; &amp;trxs_on_cycle, const <a class="el" href="structtrx__t.html">trx_t</a> *victim_trx)</td></tr>
<tr class="memdesc:a1f9b9cd959650891d83421c521909b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles writing the information about found deadlock to the log files and caches it for future lock_latest_err_file() calls (for example used by SHOW ENGINE INNODB STATUS)  <a href="#a1f9b9cd959650891d83421c521909b88">More...</a><br /></td></tr>
<tr class="separator:a1f9b9cd959650891d83421c521909b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a81d550ee42c724c84fb023128ce80147"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a81d550ee42c724c84fb023128ce80147">innobase_deadlock_detect</a> = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></td></tr>
<tr class="separator:a81d550ee42c724c84fb023128ce80147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810550c97af735417d7903a97f95631d"><td class="memItemLeft" align="right" valign="top">static const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a810550c97af735417d7903a97f95631d">REC_LOCK_CACHE</a> = 8</td></tr>
<tr class="memdesc:a810550c97af735417d7903a97f95631d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of cached record locks.  <a href="#a810550c97af735417d7903a97f95631d">More...</a><br /></td></tr>
<tr class="separator:a810550c97af735417d7903a97f95631d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93dc6084a46cc48951a63a6f9371e91"><td class="memItemLeft" align="right" valign="top">static const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ae93dc6084a46cc48951a63a6f9371e91">REC_LOCK_SIZE</a> = sizeof(ib_lock_t) + 256</td></tr>
<tr class="memdesc:ae93dc6084a46cc48951a63a6f9371e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum record lock size in bytes.  <a href="#ae93dc6084a46cc48951a63a6f9371e91">More...</a><br /></td></tr>
<tr class="separator:ae93dc6084a46cc48951a63a6f9371e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0acd94573600dde7c95c7f385edd12"><td class="memItemLeft" align="right" valign="top">static const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a5c0acd94573600dde7c95c7f385edd12">TABLE_LOCK_CACHE</a> = 8</td></tr>
<tr class="memdesc:a5c0acd94573600dde7c95c7f385edd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total number of cached table locks.  <a href="#a5c0acd94573600dde7c95c7f385edd12">More...</a><br /></td></tr>
<tr class="separator:a5c0acd94573600dde7c95c7f385edd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59eb2cc0c5b0180e9dcedfb8507bf3c7"><td class="memItemLeft" align="right" valign="top">static const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a59eb2cc0c5b0180e9dcedfb8507bf3c7">TABLE_LOCK_SIZE</a> = sizeof(ib_lock_t)</td></tr>
<tr class="memdesc:a59eb2cc0c5b0180e9dcedfb8507bf3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size in bytes, of the table lock instance.  <a href="#a59eb2cc0c5b0180e9dcedfb8507bf3c7">More...</a><br /></td></tr>
<tr class="separator:a59eb2cc0c5b0180e9dcedfb8507bf3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0872da603ecd1de7f39c8beaa8b71e1"><td class="memItemLeft" align="right" valign="top">static const std::map&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>, const char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#af0872da603ecd1de7f39c8beaa8b71e1">lock_constant_names</a></td></tr>
<tr class="memdesc:af0872da603ecd1de7f39c8beaa8b71e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by lock_get_mode_str to build a lock mode description.  <a href="#af0872da603ecd1de7f39c8beaa8b71e1">More...</a><br /></td></tr>
<tr class="separator:af0872da603ecd1de7f39c8beaa8b71e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f9f4beca353dd655536095ea4d2ad7"><td class="memItemLeft" align="right" valign="top">static std::unordered_map&lt; <a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>, const char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a82f9f4beca353dd655536095ea4d2ad7">lock_cached_lock_mode_names</a></td></tr>
<tr class="memdesc:a82f9f4beca353dd655536095ea4d2ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by lock_get_mode_str to cache results.  <a href="#a82f9f4beca353dd655536095ea4d2ad7">More...</a><br /></td></tr>
<tr class="separator:a82f9f4beca353dd655536095ea4d2ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5399aad1a992cb27e897fc806570ba0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlock__sys__t.html">lock_sys_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ac5399aad1a992cb27e897fc806570ba0">lock_sys</a> = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td></tr>
<tr class="memdesc:ac5399aad1a992cb27e897fc806570ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lock system.  <a href="#ac5399aad1a992cb27e897fc806570ba0">More...</a><br /></td></tr>
<tr class="separator:ac5399aad1a992cb27e897fc806570ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5127cf175e520ae462dd6282c06ab3dd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#a5127cf175e520ae462dd6282c06ab3dd">lock_deadlock_found</a> = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></td></tr>
<tr class="memdesc:a5127cf175e520ae462dd6282c06ab3dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">We store info on the latest deadlock error to this buffer.  <a href="#a5127cf175e520ae462dd6282c06ab3dd">More...</a><br /></td></tr>
<tr class="separator:a5127cf175e520ae462dd6282c06ab3dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58b635675c25066d014d44908f3a487"><td class="memItemLeft" align="right" valign="top">static FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="lock0lock_8cc.html#ab58b635675c25066d014d44908f3a487">lock_latest_err_file</a></td></tr>
<tr class="memdesc:ab58b635675c25066d014d44908f3a487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Only created if !srv_read_only_mode.  <a href="#ab58b635675c25066d014d44908f3a487">More...</a><br /></td></tr>
<tr class="separator:ab58b635675c25066d014d44908f3a487"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The transaction lock system. </p>
<p>Created 5/7/1996 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac6b942151a21e8458664d68a9ccfc491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b942151a21e8458664d68a9ccfc491">&#9670;&nbsp;</a></span>IS_LOCK_S_OR_X</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IS_LOCK_S_OR_X</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">lock</td><td>)</td>
          <td>&#160;&#160;&#160;(<a class="el" href="lock0priv_8h.html#ae4ba4d837532fb8eaf414d1cbaaf6d90">lock_get_mode</a>(lock) == <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013a7c98d16ae81460b73cc836948b622480">LOCK_S</a> || <a class="el" href="lock0priv_8h.html#ae4ba4d837532fb8eaf414d1cbaaf6d90">lock_get_mode</a>(lock) == <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013aa7ba6be447ffbfa3ac8e35268f622de6">LOCK_X</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a390c44e3d017379682adbfa150f2c631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390c44e3d017379682adbfa150f2c631">&#9670;&nbsp;</a></span>LOCK_MODULE_IMPLEMENTATION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_MODULE_IMPLEMENTATION</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3af8bca88f299c70144b65640de56f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af8bca88f299c70144b65640de56f8f">&#9670;&nbsp;</a></span>PRINT_NUM_OF_LOCK_STRUCTS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PRINT_NUM_OF_LOCK_STRUCTS</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a1fb6f2451b04d818cb23a0e04608e54d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb6f2451b04d818cb23a0e04608e54d">&#9670;&nbsp;</a></span>Locks</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="lock0lock_8cc.html#a1fb6f2451b04d818cb23a0e04608e54d">Locks</a> =  std::vector&lt;T, <a class="el" href="classmem__heap__allocator.html">mem_heap_allocator</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aca77337242c4af78b916e503a81b57e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca77337242c4af78b916e503a81b57e2">&#9670;&nbsp;</a></span>lock_cancel_waiting_and_release()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_cancel_waiting_and_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cancels a waiting lock request and releases possible other transactions waiting behind it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>Waiting lock request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0ca4cfe4edd613e4bf2f2880d5e6a7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ca4cfe4edd613e4bf2f2880d5e6a7e">&#9670;&nbsp;</a></span>lock_check_trx_id_sanity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_check_trx_id_sanity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that a transaction id is sensible, i.e., not in the future. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx_id</td><td>in: trx id </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02c0eec427989825525fd4b4b9cffc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c0eec427989825525fd4b4b9cffc1b">&#9670;&nbsp;</a></span>lock_clust_rec_cons_read_sees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_clust_rec_cons_read_sees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classReadView.html">ReadView</a> *&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that a record is seen in a consistent read. </p>
<dl class="section return"><dt>Returns</dt><dd>true if sees, or false if an earlier version of the record should be retrieved </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: user record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">view</td><td>in: consistent read view </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf66df1ce4412d6d621cdc8b77859e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf66df1ce4412d6d621cdc8b77859e81">&#9670;&nbsp;</a></span>lock_clust_rec_modify_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_clust_rec_modify_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if locks of other transactions prevent an immediate modify (update, delete mark, or delete unmark) of a clustered index record. </p>
<p>If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a record x-lock to the lock queue. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or DB_DEADLOCK </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record which should be modified </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76e524b2ce5982cf66b3227d12c89f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e524b2ce5982cf66b3227d12c89f8c">&#9670;&nbsp;</a></span>lock_clust_rec_read_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_clust_rec_read_check_and_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lock0lock_8h.html#adfd720ce09a7e9babfd890d6a3c3d0a3">lock_duration_t</a>&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a>&#160;</td>
          <td class="paramname"><em>sel_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>gap_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if locks of other transactions prevent an immediate read, or passing over by a read cursor, of a clustered index record. </p>
<p>If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a record lock to the lock queue. Sets the requested mode lock on the record. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">duration</td><td>If equal to AT_LEAST_STATEMENT, then makes sure that the lock will be kept around and inherited for at least the duration of current statement. If equal to REGULAR the life-cycle of the lock will depend on isolation level rules. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block of rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>user record or page supremum record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>secondary index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sel_mode</td><td>select mode: SELECT_ORDINARY, SELECT_SKIP_LOKCED, or SELECT_NO_WAIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>mode of the lock which the read cursor should set on records: LOCK_S or LOCK_X; the latter is possible in SELECT FOR UPDATE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gap_mode</td><td>LOCK_ORDINARY, LOCK_GAP, or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thr</td><td>query thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, DB_LOCK_WAIT, DB_DEADLOCK, DB_SKIP_LOCKED, or DB_LOCK_NOWAIT </dd></dl>

</div>
</div>
<a id="a57805d4a0fcad73101c822963168dca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57805d4a0fcad73101c822963168dca0">&#9670;&nbsp;</a></span>lock_clust_rec_read_check_and_lock_alt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_clust_rec_read_check_and_lock_alt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>gap_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if locks of other transactions prevent an immediate read, or passing over by a read cursor, of a clustered index record. </p>
<p>If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a record lock to the lock queue. Sets the requested mode lock on the record. This is an alternative version of lock_clust_rec_read_check_and_lock() that does not require the parameter "offsets". </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or DB_DEADLOCK </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record or page supremum record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">mode</td><td>in: mode of the lock which the read cursor should set on records: LOCK_S or LOCK_X; the latter is possible in SELECT FOR UPDATE </td></tr>
    <tr><td class="paramname">gap_mode</td><td>in: LOCK_ORDINARY, LOCK_GAP, or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0dd80770fca2c7770cb33edc695fbf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0dd80770fca2c7770cb33edc695fbf5">&#9670;&nbsp;</a></span>lock_create_wait_for_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_create_wait_for_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>waiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>blocker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new edge in wait-for graph, from waiter to blocker. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">waiter</td><td>The transaction that has to wait for blocker </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocker</td><td>The transaction which causes waiter to wait </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7d39383d7ac9dd4ca34a24f271a1baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d39383d7ac9dd4ca34a24f271a1baf">&#9670;&nbsp;</a></span>lock_get_first_trx_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structlock__t.html">lock_t</a>* lock_get_first_trx_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__lock__t.html">trx_lock_t</a> *&#160;</td>
          <td class="paramname"><em>trx_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the first lock of a trx lock list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_lock</td><td>the trx lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first lock </dd></dl>

</div>
</div>
<a id="a0a1dd693350e9ebc88a5f07f4a9236d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1dd693350e9ebc88a5f07f4a9236d4">&#9670;&nbsp;</a></span>lock_get_immutable_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lock_get_immutable_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the immutable id of this lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock we are interested in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The lock's immutable id </dd></dl>

</div>
</div>
<a id="aeb165a7de4839caf9783cade418f7703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb165a7de4839caf9783cade418f7703">&#9670;&nbsp;</a></span>lock_get_mode_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lock_get_mode_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the mode of a lock in a human readable string. </p>
<p>The string should not be free()'d or modified. This functions is a bit complex for following reasons:</p><ul>
<li>the way it is used in performance schema requires that the memory pointed by the return value is accessible for a long time</li>
<li>the caller never frees the memory</li>
<li>so, we need to maintain a pool of these strings or use string literals</li>
<li>there are many possible combinations of flags and thus it is impractical to maintain the list of all possible literals and if/else logic</li>
<li>moreover, sometimes performance_schema.data_locks is used precisely to investigate some unexpected situation, thus limiting output of this function only to expected combinations of flags might be misleading <dl class="section return"><dt>Returns</dt><dd>lock mode </dd></dl>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a371526911982293902d4239c71ae59b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a371526911982293902d4239c71ae59b3">&#9670;&nbsp;</a></span>lock_get_n_rec_locks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint lock_get_n_rec_locks </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the number of record lock structs in the record lock hash table. </p>
<dl class="section return"><dt>Returns</dt><dd>number of record locks </dd></dl>

</div>
</div>
<a id="a5b99bda2e15de31f306979231d1f5436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b99bda2e15de31f306979231d1f5436">&#9670;&nbsp;</a></span>lock_get_next_trx_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structlock__t.html">lock_t</a>* lock_get_next_trx_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the next lock of a trx lock list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>the current lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next lock </dd></dl>

</div>
</div>
<a id="acecc4ffef7bce145529de20c3ee12d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecc4ffef7bce145529de20c3ee12d36">&#9670;&nbsp;</a></span>lock_get_psi_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_get_psi_event </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *&#160;</td>
          <td class="paramname"><em>thread_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *&#160;</td>
          <td class="paramname"><em>event_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the performance schema event (thread_id, event_id) that created the lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>Lock </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">thread_id</td><td>Thread ID that created the lock </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">event_id</td><td>Event ID that created the lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a478c022c5f5da29524207004cfc5325d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a478c022c5f5da29524207004cfc5325d">&#9670;&nbsp;</a></span>lock_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint lock_get_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of a lock struct. </p>
<dl class="section return"><dt>Returns</dt><dd>size in bytes </dd></dl>

</div>
</div>
<a id="a88f90ccf6fab644d41a404db1d27e948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f90ccf6fab644d41a404db1d27e948">&#9670;&nbsp;</a></span>lock_get_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structdict__table__t.html">dict_table_t</a>* lock_get_table </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the table on which the lock is. </p>
<dl class="section return"><dt>Returns</dt><dd>table </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f014df68b9ac74600c80de96092b91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f014df68b9ac74600c80de96092b91c">&#9670;&nbsp;</a></span>lock_get_table_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dict0types_8h.html#ac877e05c194a7c04fa5921c88cdcb1f7">table_id_t</a> lock_get_table_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the id of the table on which the lock is. </p>
<dl class="section return"><dt>Returns</dt><dd>id of the table </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfd305f10c527e77d4f78fbb758b89b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd305f10c527e77d4f78fbb758b89b6">&#9670;&nbsp;</a></span>lock_get_table_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structtable__name__t.html">table_name_t</a>&amp; lock_get_table_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine which table a lock is associated with. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>the lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name of the table </dd></dl>

</div>
</div>
<a id="abecbf8e0ed8c9de8a425e360a40ac779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abecbf8e0ed8c9de8a425e360a40ac779">&#9670;&nbsp;</a></span>lock_get_trx_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a> lock_get_trx_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the id of the transaction owning a lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>A lock of the transaction we are interested in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transaction's id </dd></dl>

</div>
</div>
<a id="a0570cd0fb05c95af79ac66dcea8c636b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0570cd0fb05c95af79ac66dcea8c636b">&#9670;&nbsp;</a></span>lock_get_trx_immutable_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t lock_get_trx_immutable_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the immutable id of the transaction owning a lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>A lock of the transaction we are interested in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the transaction's immutable id </dd></dl>

</div>
</div>
<a id="a374b98595a50acd2ec82df4e1952d51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a374b98595a50acd2ec82df4e1952d51e">&#9670;&nbsp;</a></span>lock_get_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t lock_get_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the type of a lock. </p>
<p>Non-inline version for using outside of the lock module. </p><dl class="section return"><dt>Returns</dt><dd>LOCK_TABLE or LOCK_REC </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ae17fad2ea0c4abe3252d4089e6a6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae17fad2ea0c4abe3252d4089e6a6a5">&#9670;&nbsp;</a></span>lock_get_type_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lock_get_type_str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the type of a lock in a human readable string. </p>
<p>The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>lock type </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81303597fbce84d2814fb10f02a75cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81303597fbce84d2814fb10f02a75cb4">&#9670;&nbsp;</a></span>lock_grant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_grant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Grants a lock to a waiting lock request and releases the waiting transaction. </p>
<p>The caller must hold lock_sys latch for the shard containing the lock, but not the lock-&gt;trx-&gt;mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>waiting lock request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b96cb9271b055ba84eea36f6dc4fcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b96cb9271b055ba84eea36f6dc4fcd1">&#9670;&nbsp;</a></span>lock_grant_or_update_wait_for_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_grant_or_update_wait_for_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a lock, which was found in waiting queue, checks if it still has to wait in queue, and either grants it, or makes sure that the reason it has to wait is reflected in the wait-for graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>A lock in WAITING state, which perhaps can be granted now </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a866c94e4b9e292db1ec60ad8de3e07d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866c94e4b9e292db1ec60ad8de3e07d9">&#9670;&nbsp;</a></span>lock_grant_or_update_wait_for_edge_if_waiting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_grant_or_update_wait_for_edge_if_waiting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>releasing_trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a lock, and a transaction which is releasing another lock from the same queue, makes sure that if the lock was waiting for this transaction, then it will either be granted, or another reason for waiting is reflected in the wait-for graph. </p>

</div>
</div>
<a id="ae9cec654a8d71e13f4113aa36dd0d78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9cec654a8d71e13f4113aa36dd0d78f">&#9670;&nbsp;</a></span>lock_has_to_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_has_to_wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a lock request lock1 has to wait for request lock2. </p>
<dl class="section return"><dt>Returns</dt><dd>true if lock1 has to wait for lock2 to be removed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock1</td><td>in: waiting lock </td></tr>
    <tr><td class="paramname">lock2</td><td>in: another lock; NOTE that it is assumed that this has a lock bit set on the same record as in lock1 if the locks are record locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2f79d0aaea95b1e11de40c0c0356936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f79d0aaea95b1e11de40c0c0356936">&#9670;&nbsp;</a></span>lock_has_to_wait_in_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structlock__t.html">lock_t</a> * lock_has_to_wait_in_queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>wait_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>blocking_trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a waiting lock request still has to wait in a queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_lock</td><td>Waiting lock </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocking_trx</td><td>If not nullptr, it restricts the search to only the locks held by the blocking_trx, which is useful in case when there might be multiple reasons for waiting in queue, but we need to report the specific one. Useful when reporting a deadlock cycle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The conflicting lock which is the reason wait_lock has to wait or nullptr if it can be granted now </dd></dl>

</div>
</div>
<a id="a1140afd70eacb9aaae522805ac1f2270"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1140afd70eacb9aaae522805ac1f2270">&#9670;&nbsp;</a></span>lock_make_trx_hit_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_make_trx_hit_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a13121c5e3c7e683afe964f2903433257">hit_list_t</a> &amp;&#160;</td>
          <td class="paramname"><em>hit_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over the granted locks which conflict with trx-&gt;lock.wait_lock and prepare the hit list for ASYNC Rollback. </p>
<p>If the transaction is waiting for some other lock then wake up with deadlock error. Currently we don't mark following transactions for ASYNC Rollback.</p>
<ol type="1">
<li>Read only transactions</li>
<li>Background transactions</li>
<li>Other High priority transactions <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>High Priority transaction </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hit_list</td><td>List of transactions which need to be rolled back </td></tr>
  </table>
  </dd>
</dl>
</li>
</ol>

</div>
</div>
<a id="aef58d7d99fb0accf1b297a6aed865f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef58d7d99fb0accf1b297a6aed865f2d">&#9670;&nbsp;</a></span>lock_mark_trx_for_rollback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_mark_trx_for_rollback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a13121c5e3c7e683afe964f2903433257">hit_list_t</a> &amp;&#160;</td>
          <td class="paramname"><em>hit_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>hp_trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect the transactions that will need to be rolled back asynchronously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">hit_list</td><td>The list of transactions to be rolled back, to which the trx should be appended. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hp_trx_id</td><td>The id of the blocked High Priority Transaction </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trx</td><td>The blocking transaction to be rolled back </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c347ac8a8ae8fb5353860412258b447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c347ac8a8ae8fb5353860412258b447">&#9670;&nbsp;</a></span>lock_move_granted_locks_to_front()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_move_granted_locks_to_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="row0mysql_8cc.html#aa70fd829bdc7a3b8160bef3726810973">UT_LIST_BASE_NODE_T</a>(<a class="el" href="structlock__t.html">lock_t</a>) &amp;&#160;</td>
          <td class="paramname"><em>lock_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move all the granted locks to the front of the given lock list. </p>
<p>All the waiting locks will be at the end of the list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock_list</td><td>the given lock list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72a4bca65fd7f08390fbe370ab09fe24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a4bca65fd7f08390fbe370ab09fe24">&#9670;&nbsp;</a></span>lock_move_rec_list_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_move_rec_list_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the explicit locks on user records to another page if a record list end is moved to another page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_block</td><td>Index page to move to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Index page </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rec</td><td>Record on page: this is the first record moved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a856b4f10d6691a2c3446378525c1a9f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856b4f10d6691a2c3446378525c1a9f2">&#9670;&nbsp;</a></span>lock_move_rec_list_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_move_rec_list_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>old_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the explicit locks on user records to another page if a record list start is moved to another page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_block</td><td>Index page to move to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Index page </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rec</td><td>Record on page: this is the first record not copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">old_end</td><td>Old previous-to-last record on new_page before the records were copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb133e68ef2953ee54049f280eff17af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb133e68ef2953ee54049f280eff17af">&#9670;&nbsp;</a></span>lock_move_reorganize_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_move_reorganize_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>oblock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when we have reorganized a page. </p>
<p>NOTE: we copy also the locks set on the infimum of the page; the infimum may carry locks if an update of a record is occurring on the page, and its locks were temporarily stored on the infimum. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: old index page, now reorganized </td></tr>
    <tr><td class="paramname">oblock</td><td>in: copy of the old, not reorganized page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f9b9cd959650891d83421c521909b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9b9cd959650891d83421c521909b88">&#9670;&nbsp;</a></span>lock_notify_about_deadlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_notify_about_deadlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceut.html#aa7abb0ab07329e68a6ec29d191da1e58">ut::vector</a>&lt; const <a class="el" href="structtrx__t.html">trx_t</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>trxs_on_cycle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>victim_trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handles writing the information about found deadlock to the log files and caches it for future lock_latest_err_file() calls (for example used by SHOW ENGINE INNODB STATUS) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trxs_on_cycle</td><td>trxs causing deadlock, i-th waits for i+1-th </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">victim_trx</td><td>the trx from trx_on_cycle which will be rolled back </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0ab5b5a29bf12d5dfd022fc0ee5d815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ab5b5a29bf12d5dfd022fc0ee5d815">&#9670;&nbsp;</a></span>lock_number_of_rows_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint lock_number_of_rows_locked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__lock__t.html">trx_lock_t</a> *&#160;</td>
          <td class="paramname"><em>trx_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return approximate number or record locks (bits set in the bitmap) for this transaction. </p>
<p>Since delete-marked records may be removed, the record count will not be precise. The caller must be holding exclusive global lock_sys latch. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_lock</td><td>transaction locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a9f940afda7bc372f6b78a23ed1aa37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9f940afda7bc372f6b78a23ed1aa37">&#9670;&nbsp;</a></span>lock_number_of_tables_locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint lock_number_of_tables_locked </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of table locks for a transaction. </p>
<p>The caller must be holding trx-&gt;mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>the transaction for which we want the number of table locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca9025c7188f98ef88d223591eb7fe0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9025c7188f98ef88d223591eb7fe0d">&#9670;&nbsp;</a></span>lock_on_statement_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_on_statement_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called to inform lock-sys that a statement processing for a trx has just finished. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>transaction which has finished processing a statement </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdc5c7b8bef35ee70ba968607a22fb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc5c7b8bef35ee70ba968607a22fb24">&#9670;&nbsp;</a></span>lock_print_info_all_transactions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_print_info_all_transactions </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints info of locks for each transaction. </p>
<p>This function assumes that the caller holds the exclusive global latch and more importantly it may release and reacquire it on behalf of the caller. (This should be fixed in the future). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">file</td><td>the file where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a396c1bdffc5e098c024ad929ba594dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396c1bdffc5e098c024ad929ba594dd8">&#9670;&nbsp;</a></span>lock_print_info_summary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_print_info_summary </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints info of locks for all transactions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>file where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0885d07165117fecfb5fc51ea0ae9d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0885d07165117fecfb5fc51ea0ae9d3b">&#9670;&nbsp;</a></span>lock_protect_locks_till_statement_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_protect_locks_till_statement_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0547aaa70bdb71c2550b71985da395b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0547aaa70bdb71c2550b71985da395b5">&#9670;&nbsp;</a></span>lock_rec_add_to_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_add_to_queue </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>we_own_trx_mutex</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a record lock request in the record queue. </p>
<p>The request is normally added as the last in the queue, but if the request to be added is not a waiting request, we can reuse a suitable record lock object already existing on the same page, just setting the appropriate bit in its bitmap. This is a low-level function which does NOT check for deadlocks or lock compatibility! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_mode</td><td>lock mode, wait, gap etc. flags; type is ignored and replaced by LOCK_REC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block containing the record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>heap number of the record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index of record </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trx</td><td>transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">we_own_trx_mutex</td><td>true iff the caller own trx-&gt;mutex (optional). Defaults to false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a11bee90995105efe9a0942e37b6349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a11bee90995105efe9a0942e37b6349">&#9670;&nbsp;</a></span>lock_rec_bitmap_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_bitmap_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the record lock bitmap to zero. </p>
<p>NOTE: does not touch the wait_lock pointer in the transaction! This function is used in lock object creation and resetting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2621d11a343f8fcb24b1b93a9a90541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2621d11a343f8fcb24b1b93a9a90541">&#9670;&nbsp;</a></span>lock_rec_block_validate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_block_validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validate a record lock's block. </p>

</div>
</div>
<a id="a7aa77b9fe490eac4349341da3a689dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa77b9fe490eac4349341da3a689dad">&#9670;&nbsp;</a></span>lock_rec_cancel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cancels a waiting record lock request and releases the waiting transaction that requested it. </p>
<p>NOTE: does NOT check if waiting lock requests behind this one can now be granted! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: waiting record lock request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac98fb0ca09acc1516e030769b0ba8358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98fb0ca09acc1516e030769b0ba8358">&#9670;&nbsp;</a></span>lock_rec_convert_active_impl_to_expl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rec_convert_active_impl_to_expl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is kind of wrapper to lock_rec_convert_impl_to_expl_for_trx() function with functionailty added to facilitate lock conversion from implicit to explicit for partial rollback cases. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block of rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>user record on page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index of record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trx</td><td>active transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>rec heap number to lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6872a342e01b3ae5cc2132301afec259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6872a342e01b3ae5cc2132301afec259">&#9670;&nbsp;</a></span>lock_rec_convert_impl_to_expl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_convert_impl_to_expl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If a transaction has an implicit x-lock on a record, but no explicit x-lock set on the record, sets one for it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block of rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>user record on page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index of record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>rec_get_offsets(rec, index) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65dd65c796e749fff4fedd4b8ecec98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65dd65c796e749fff4fedd4b8ecec98b">&#9670;&nbsp;</a></span>lock_rec_convert_impl_to_expl_for_trx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_convert_impl_to_expl_for_trx </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an explicit record lock for a running transaction that currently only has an implicit lock on the record. </p>
<p>The transaction instance must have a reference count &gt; 0 so that it can't be committed and freed before this function has completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: user record on page </td></tr>
    <tr><td class="paramname">index</td><td>in: index of record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramname">trx</td><td>in/out: active transaction </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: rec heap number to lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a179a520c4a10f93bc52ed52b9abb8a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179a520c4a10f93bc52ed52b9abb8a81">&#9670;&nbsp;</a></span>lock_rec_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a record lock to heap. </p>
<dl class="section return"><dt>Returns</dt><dd>copy of lock </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock </td></tr>
    <tr><td class="paramname">heap</td><td>in: memory heap </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a400624ff6ae565a75b2894787172c809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a400624ff6ae565a75b2894787172c809">&#9670;&nbsp;</a></span>lock_rec_dequeue_from_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_dequeue_from_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>in_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a record lock request, waiting or granted, from the queue and grants locks to other transactions in the queue if they now are entitled to a lock. </p>
<p>NOTE: all record locks contained in in_lock are removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">in_lock</td><td>record lock object: all record locks which are contained in this lock object are removed; transactions waiting behind will get their lock requests granted, if they are now qualified to it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb40b46c0751e5e8f8d6d9b841251a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb40b46c0751e5e8f8d6d9b841251a64">&#9670;&nbsp;</a></span>lock_rec_discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rec_discard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>in_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a record lock request, waiting or granted, from the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_lock</td><td>record lock object: all record locks which are contained in this lock object are removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a105a61c935f6765bbc78ddbf40203a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105a61c935f6765bbc78ddbf40203a4f">&#9670;&nbsp;</a></span>lock_rec_expl_exist_on_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_rec_expl_exist_on_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if there are explicit record locks on a page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>space id and page number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff an explicit record lock on the page exists </dd></dl>

</div>
</div>
<a id="a11d0bb8788b9f644fe80225afb07af43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d0bb8788b9f644fe80225afb07af43">&#9670;&nbsp;</a></span>lock_rec_fetch_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_rec_fetch_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the page containing the record protected by the given lock. </p>
<p>This function will temporarily release the exclusive global latch and the trx_sys_t::mutex if the page was read from disk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>the record lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a page was successfully read from the tablespace </dd></dl>

</div>
</div>
<a id="a6c73150ff49ff33364b8dfe57796bac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c73150ff49ff33364b8dfe57796bac2">&#9670;&nbsp;</a></span>lock_rec_find_next_set_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint lock_rec_find_next_set_bit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for the next set bit in the record lock bitmap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>record lock with at least one bit set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>current set bit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next bit index == heap number following heap_no, or ULINT_UNDEFINED if none found </dd></dl>

</div>
</div>
<a id="ad7ccba69e261b79e8c7ab7d83cb41319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ccba69e261b79e8c7ab7d83cb41319">&#9670;&nbsp;</a></span>lock_rec_find_set_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint lock_rec_find_set_bit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for a set bit in a record lock bitmap. </p>
<p>Returns ULINT_UNDEFINED, if none found. </p><dl class="section return"><dt>Returns</dt><dd>bit index == heap number of the record, or ULINT_UNDEFINED if none found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock with at least one bit set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ef553dad30bea9338835b3762320248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef553dad30bea9338835b3762320248">&#9670;&nbsp;</a></span>lock_rec_find_similar_on_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_find_similar_on_page </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>type_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>found_waiter_before_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks for a suitable type record lock struct by the same trx on the same page. </p>
<p>This can be used to save space when a new record lock should be set on a page: no new struct is needed, if a suitable old is found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">type_mode</td><td>lock type_mode field </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>heap number of the record we plan to use. The lock struct we search for needs to have a bitmap at least as large. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>lock_rec_get_first_on_page() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>transaction </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">found_waiter_before_lock</td><td>true iff there is a waiting lock before the returned lock </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lock or nullptr if there is no lock we could reuse </dd></dl>

</div>
</div>
<a id="a5f9c55d69db3ad92b4af176625eac460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9c55d69db3ad92b4af176625eac460">&#9670;&nbsp;</a></span>lock_rec_free_all_from_discard_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rec_free_all_from_discard_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes record lock objects set on an index page which is discarded. </p>
<p>This function does not move locks, or check for waiting locks, therefore the lock bitmaps must already be reset when this function is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: page to be discarded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c487adb53263bd8c6e2e0c16f1022d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c487adb53263bd8c6e2e0c16f1022d5">&#9670;&nbsp;</a></span>lock_rec_free_all_from_discard_page_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_free_all_from_discard_page_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpage__id__t.html">page_id_t</a>&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>lock_hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes record lock objects set on an index page which is discarded. </p>
<p>This function does not move locks, or check for waiting locks, therefore the lock bitmaps must already be reset when this function is called. </p>

</div>
</div>
<a id="a419d78b85193924e945f2313a60f7ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419d78b85193924e945f2313a60f7ccf">&#9670;&nbsp;</a></span>lock_rec_get_gap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_rec_get_gap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the gap flag of a record lock. </p>
<dl class="section return"><dt>Returns</dt><dd>LOCK_GAP or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a489f292f2abfd59464a820e4ef3efdf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489f292f2abfd59464a820e4ef3efdf6">&#9670;&nbsp;</a></span>lock_rec_get_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structdict__index__t.html">dict_index_t</a>* lock_rec_get_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a record lock, gets the index on which the lock is. </p>
<dl class="section return"><dt>Returns</dt><dd>index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07cae5f235e5f095fb70d92c8d2e0bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07cae5f235e5f095fb70d92c8d2e0bc6">&#9670;&nbsp;</a></span>lock_rec_get_index_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* lock_rec_get_index_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a record lock, gets the name of the index on which the lock is. </p>
<p>The string should not be free()'d or modified. </p><dl class="section return"><dt>Returns</dt><dd>name of the index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedc4fc3dd2500ccd00e4139c4ccba75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc4fc3dd2500ccd00e4139c4ccba75a">&#9670;&nbsp;</a></span>lock_rec_get_insert_intention()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_rec_get_insert_intention </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the waiting insert flag of a record lock. </p>
<dl class="section return"><dt>Returns</dt><dd>LOCK_INSERT_INTENTION or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa95ea09f1777797a5e22cb63720d483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa95ea09f1777797a5e22cb63720d483">&#9670;&nbsp;</a></span>lock_rec_get_page_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpage__id__t.html">page_id_t</a> lock_rec_get_page_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a record lock, gets the tablespace number and page number on which the lock is. </p>
<dl class="section return"><dt>Returns</dt><dd>tablespace number in: lock </dd></dl>

</div>
</div>
<a id="a9398c6b6d42fd740b9fa25ae4be1f660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9398c6b6d42fd740b9fa25ae4be1f660">&#9670;&nbsp;</a></span>lock_rec_get_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_get_prev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>in_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the previous record lock set on a record. </p>
<dl class="section return"><dt>Returns</dt><dd>previous lock on the same record, NULL if none exists </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_lock</td><td>in: record lock </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of the record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ea241051962fafa069de83516f0df01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea241051962fafa069de83516f0df01">&#9670;&nbsp;</a></span>lock_rec_get_rec_not_gap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint lock_rec_get_rec_not_gap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the LOCK_REC_NOT_GAP flag of a record lock. </p>
<dl class="section return"><dt>Returns</dt><dd>LOCK_REC_NOT_GAP or 0 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: record lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe7d42b1e15b49c2d55413e7c8d62107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7d42b1e15b49c2d55413e7c8d62107">&#9670;&nbsp;</a></span>lock_rec_grant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_grant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>in_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Grant lock to waiting requests that no longer conflicts. </p>
<p>The in_lock might be modified before call to this function by clearing some flag (see for example lock_trx_release_read_locks). It also might already be removed from the hash bucket (a.k.a. waiting queue) or still reside in it. However the content of bitmap should not be changed prior to calling this function, as the bitmap will be inspected to see which heap_no at all were blocked by this in_lock, and only locks waiting for those heap_no's will be checked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">in_lock</td><td>record lock object: grant all non-conflicting locks waiting behind this lock object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01ee8ae5537f4080b9f3e7e092e35830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ee8ae5537f4080b9f3e7e092e35830">&#9670;&nbsp;</a></span>lock_rec_grant_by_heap_no()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_grant_by_heap_no </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>in_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Grant a lock to waiting transactions. </p>
<p>This function scans the queue of locks in which in_lock resides (or resided) paying attention only to locks on heap_no-th bit. For each waiting lock which was blocked by in_lock-&gt;trx it checks if it can be granted now. It iterates on waiting locks in order favoring high-priority transactions and then transactions of high trx-&gt;lock.schedule_weight. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_lock</td><td>Lock which was released, or partially released by modifying its type/mode (see lock_trx_release_read_locks) or reseting heap_no-th bit in the bitmap (see lock_rec_release) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>Heap number within the page on which the lock was (or still is) held </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b72e4f9774ec637cf85a44ad8239635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b72e4f9774ec637cf85a44ad8239635">&#9670;&nbsp;</a></span>lock_rec_has_expl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE const <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_has_expl </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>precise_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a transaction has a GRANTED explicit lock on rec stronger or equal to precise_mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">precise_mode</td><td>LOCK_S or LOCK_X possibly ORed to LOCK_GAP or LOCK_REC_NOT_GAP, for a supremum record we regard this always a gap type request </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block containing the record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>heap number of the record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>lock or NULL </dd></dl>

</div>
</div>
<a id="a0eed8028e8450e8856921546fa518253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eed8028e8450e8856921546fa518253">&#9670;&nbsp;</a></span>lock_rec_has_to_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_rec_has_to_wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>lock_is_on_supremum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a lock request for a new lock has to wait for request lock2. </p>
<dl class="section return"><dt>Returns</dt><dd>true if new lock has to wait for lock2 to be removed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: trx of new lock </td></tr>
    <tr><td class="paramname">type_mode</td><td>in: precise mode of the new lock to set: LOCK_S or LOCK_X, possibly ORed to LOCK_GAP or LOCK_REC_NOT_GAP, LOCK_INSERT_INTENTION </td></tr>
    <tr><td class="paramname">lock2</td><td>in: another record lock; NOTE that it is assumed that this has a lock bit set on the same record as in the new lock we are setting </td></tr>
    <tr><td class="paramname">lock_is_on_supremum</td><td>in: true if we are setting the lock on the 'supremum' record of an index page: we know then that the lock request is really for a 'gap' type lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac472658729904fde01384fc8722df156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac472658729904fde01384fc8722df156">&#9670;&nbsp;</a></span>lock_rec_has_to_wait_for_granted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_has_to_wait_for_granted </td>
          <td>(</td>
          <td class="paramtype">const typename Container::value_type &amp;&#160;</td>
          <td class="paramname"><em>wait_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>granted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>new_granted_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a waiting record lock request still has to wait for granted locks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_lock</td><td>Waiting record lock </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">granted</td><td>Granted record locks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_granted_index</td><td>Start of new granted locks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The conflicting lock which is the reason wait_lock has to wait or nullptr if it can be granted now </dd></dl>

</div>
</div>
<a id="ac354a74731c3f15924faea730a70f71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac354a74731c3f15924faea730a70f71a">&#9670;&nbsp;</a></span>lock_rec_has_to_wait_in_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_has_to_wait_in_queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>wait_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>blocking_trx</em> = <code><a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a waiting record lock request still has to wait in a queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_lock</td><td>Waiting record lock </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocking_trx</td><td>If not nullptr, it restricts the search to only the locks held by the blocking_trx, which is useful in case when there might be multiple reasons for waiting in queue, but we need to report the specific one. Useful when reporting a deadlock cycle. (optional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The conflicting lock which is the reason wait_lock has to wait or nullptr if it can be granted now </dd></dl>

</div>
</div>
<a id="ad71a1e16ac85a11e9ac1f3111f707439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad71a1e16ac85a11e9ac1f3111f707439">&#9670;&nbsp;</a></span>lock_rec_inherit_to_gap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_inherit_to_gap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>heir_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heir_heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a record to inherit the locks (except LOCK_INSERT_INTENTION type) of another record as gap type locks, but does not reset the lock bits of the other record. </p>
<p>Also waiting lock requests on rec are inherited as GRANTED gap locks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heir_block</td><td>in: block containing the record which inherits </td></tr>
    <tr><td class="paramname">block</td><td>in: block containing the record from which inherited; does NOT reset the locks on this record </td></tr>
    <tr><td class="paramname">heir_heap_no</td><td>in: heap_no of the inheriting record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap_no of the donating record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb009afd28d954b9ba74693b823b4ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb009afd28d954b9ba74693b823b4ad3">&#9670;&nbsp;</a></span>lock_rec_inherit_to_gap_if_gap_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_inherit_to_gap_if_gap_lock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heir_heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a record to inherit the gap locks (except LOCK_INSERT_INTENTION type) of another record as gap type locks, but does not reset the lock bits of the other record. </p>
<p>Also waiting lock requests are inherited as GRANTED gap locks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block </td></tr>
    <tr><td class="paramname">heir_heap_no</td><td>in: heap_no of record which inherits </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap_no of record from which inherited; does NOT reset the locks on this record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3d6fd7d2966684cc39668db595f5c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d6fd7d2966684cc39668db595f5c3a">&#9670;&nbsp;</a></span>lock_rec_insert_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_rec_insert_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>inherit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if locks of other transactions prevent an immediate insert of a record. </p>
<p>If they do, first tests if the query thread should anyway be suspended for some reason; if not, then puts the transaction and the query thread to the lock wait state and inserts a waiting request for a gap x-lock to the lock queue. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or DB_DEADLOCK </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">rec</td><td>in: record after which to insert </td></tr>
    <tr><td class="paramname">block</td><td>in/out: buffer block of rec </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
    <tr><td class="paramname">inherit</td><td>out: set to true if the new inserted record maybe should inherit LOCK_GAP type locks from the successor record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c3f55305a03daf27987ec050d0610ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3f55305a03daf27987ec050d0610ed">&#9670;&nbsp;</a></span>lock_rec_insert_to_granted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_insert_to_granted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>lock_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRecID.html">RecID</a> &amp;&#160;</td>
          <td class="paramname"><em>rec_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert lock record to the head of the queue where the GRANTED locks reside. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock_hash</td><td>Hash table containing the locks </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>Record lock instance to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec_id</td><td>Record being locked </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ad9479e72fd3c0f3ebef965a098a241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad9479e72fd3c0f3ebef965a098a241">&#9670;&nbsp;</a></span>lock_rec_insert_to_waiting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_insert_to_waiting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>lock_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRecID.html">RecID</a> &amp;&#160;</td>
          <td class="paramname"><em>rec_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert lock record to the tail of the queue where the WAITING locks reside. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock_hash</td><td>Hash table containing the locks </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>Record lock instance to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec_id</td><td>Record being locked </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9f9d4188fafaaf5d9dbdb95d6532e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9f9d4188fafaaf5d9dbdb95d6532e0c">&#9670;&nbsp;</a></span>lock_rec_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_rec_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>impl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a>&#160;</td>
          <td class="paramname"><em>sel_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to lock the specified record in the mode requested. </p>
<p>If not immediately possible, enqueues a waiting lock request. This is a low-level function which does NOT look at implicit locks! Checks lock compatibility within explicit locks. This function sets a normal next-key lock, or in the case of a page supremum record, a gap type lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">impl</td><td>if true, no lock is set if no wait is necessary: we assume that the caller will set an implicit lock </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sel_mode</td><td>select mode: SELECT_ORDINARY, SELECT_SKIP_LOCKED, or SELECT_NO_WAIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>lock mode: LOCK_X or LOCK_S possibly ORed to either LOCK_GAP or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block containing the record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>heap number of record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index of record </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thr</td><td>query thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, DB_LOCK_WAIT, DB_DEADLOCK, DB_SKIP_LOCKED, or DB_LOCK_NOWAIT </dd></dl>

</div>
</div>
<a id="ae9bd08791fbcb3c4372fd1679a9a7003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bd08791fbcb3c4372fd1679a9a7003">&#9670;&nbsp;</a></span>lock_rec_lock_fast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="lock0priv_8h.html#aaa98e1bd917f95280993475788ea6c5b">lock_rec_req_status</a> lock_rec_lock_fast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>impl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a fast routine for locking a record in the most common cases: there are no explicit locks on the page, or there is just one lock, owned by this transaction, and of the right type_mode. </p>
<p>This is a low-level function which does NOT look at implicit locks! Checks lock compatibility within explicit locks. This function sets a normal next-key lock, or in the case of a page supremum record, a gap type lock. </p><dl class="section return"><dt>Returns</dt><dd>whether the locking succeeded LOCK_REC_SUCCESS, LOCK_REC_SUCCESS_CREATED, LOCK_REC_FAIL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">impl</td><td>in: if true, no lock is set if no wait is necessary: we assume that the caller will set an implicit lock </td></tr>
    <tr><td class="paramname">mode</td><td>in: lock mode: LOCK_X or LOCK_S possibly ORed to either LOCK_GAP or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block containing the record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of record </td></tr>
    <tr><td class="paramname">index</td><td>in: index of record </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48374d73d24053ebce5038781703e13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48374d73d24053ebce5038781703e13a">&#9670;&nbsp;</a></span>lock_rec_lock_fold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint lock_rec_lock_fold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the fold value of a lock: used in migrating the hash table. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>record lock object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>folded value </dd></dl>

</div>
</div>
<a id="af45076e7e4e028081383d502247e0953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45076e7e4e028081383d502247e0953">&#9670;&nbsp;</a></span>lock_rec_lock_slow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_rec_lock_slow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>impl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a>&#160;</td>
          <td class="paramname"><em>sel_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is the general, and slower, routine for locking a record. </p>
<p>This is a low-level function which does NOT look at implicit locks! Checks lock compatibility within explicit locks. This function sets a normal next-key lock, or in the case of a page supremum record, a gap type lock. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">impl</td><td>if true, no lock is set if no wait is necessary: we assume that the caller will set an implicit lock </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sel_mode</td><td>select mode: SELECT_ORDINARY, SELECT_SKIP_LOCKED, or SELECT_NO_WAIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>lock mode: LOCK_X or LOCK_S possibly ORed to either LOCK_GAP or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block containing the record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>heap number of record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index of record </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thr</td><td>query thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, DB_LOCK_WAIT, DB_DEADLOCK, DB_SKIP_LOCKED, or DB_LOCK_NOWAIT </dd></dl>

</div>
</div>
<a id="ac36451e4190af50f249bd167316ed50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36451e4190af50f249bd167316ed50d">&#9670;&nbsp;</a></span>lock_rec_move()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_rec_move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>donator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>receiver_heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>donator_heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the locks of a record to another record and resets the lock bits of the donating record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">receiver</td><td>in: buffer block containing the receiving record </td></tr>
    <tr><td class="paramname">donator</td><td>in: buffer block containing the donating record </td></tr>
    <tr><td class="paramname">receiver_heap_no</td><td>in: heap_no of the record which gets the locks; there must be no lock requests on it! </td></tr>
    <tr><td class="paramname">donator_heap_no</td><td>in: heap_no of the record which gives the locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ce283c05fa456105b955a306434a6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce283c05fa456105b955a306434a6af">&#9670;&nbsp;</a></span>lock_rec_move_granted_to_front()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_move_granted_to_front </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRecID.html">RecID</a> &amp;&#160;</td>
          <td class="paramname"><em>rec_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves a granted lock to the front of the queue for a given record by removing it adding it to the front. </p>
<p>As a single lock can correspond to multiple rows (and thus: queues) this function moves it to the front of whole bucket. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>a granted lock to be moved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec_id</td><td>record id which specifies particular queue and bucket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6cabdc623d14c7e334fefb0771123f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cabdc623d14c7e334fefb0771123f02">&#9670;&nbsp;</a></span>lock_rec_move_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_move_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>lock_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>donator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>receiver_heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>donator_heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the locks of a record to another record and resets the lock bits of the donating record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_hash</td><td>in: hash table to use </td></tr>
    <tr><td class="paramname">receiver</td><td>in: buffer block containing the receiving record </td></tr>
    <tr><td class="paramname">donator</td><td>in: buffer block containing the donating record </td></tr>
    <tr><td class="paramname">receiver_heap_no</td><td>in: heap_no of the record which gets the locks; there must be no lock requests on it! </td></tr>
    <tr><td class="paramname">donator_heap_no</td><td>in: heap_no of the record which gives the locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a753371bcba42ef61e86fd97596bcf8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753371bcba42ef61e86fd97596bcf8d7">&#9670;&nbsp;</a></span>lock_rec_other_has_conflicting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_other_has_conflicting </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if some other transaction has a conflicting explicit lock request in the queue, so that we have to wait. </p>
<dl class="section return"><dt>Returns</dt><dd>lock or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>in: LOCK_S or LOCK_X, possibly ORed to LOCK_GAP or LOC_REC_NOT_GAP, LOCK_INSERT_INTENTION </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block containing the record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of the record </td></tr>
    <tr><td class="paramname">trx</td><td>in: our transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76ffee781817efb3882d42cfc9f0014a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ffee781817efb3882d42cfc9f0014a">&#9670;&nbsp;</a></span>lock_rec_other_has_expl_req()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structlock__t.html">lock_t</a>* lock_rec_other_has_expl_req </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if some other transaction has a lock request in the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>lock or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>in: LOCK_S or LOCK_X </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block containing the record </td></tr>
    <tr><td class="paramname">wait</td><td>in: whether also waiting locks are taken into account </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of the record </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction, or NULL if requests by all transactions are taken into account </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e4a26d2631c27149ddf0ee924420083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4a26d2631c27149ddf0ee924420083">&#9670;&nbsp;</a></span>lock_rec_other_trx_holds_expl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_rec_other_trx_holds_expl </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>precise_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if some transaction, other than given trx_id, has an explicit lock on the given rec, in the given precise_mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">precise_mode</td><td>LOCK_S or LOCK_X possibly ORed to LOCK_GAP or LOCK_REC_NOT_GAP. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>the trx holding implicit lock on rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>user record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block containing the record </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true iff there's a transaction, whose id is not equal to trx_id, that has an explicit lock on the given rec, in the given precise_mode. </dd></dl>

</div>
</div>
<a id="a84aa5902c8064caabb3ba36dd65c7903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84aa5902c8064caabb3ba36dd65c7903">&#9670;&nbsp;</a></span>lock_rec_print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints info of a record lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
    <tr><td class="paramname">lock</td><td>in: record type lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0ed500b53a738294018138bbebc18d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0ed500b53a738294018138bbebc18d5">&#9670;&nbsp;</a></span>lock_rec_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Grant a lock to waiting transactions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>Lock that was unlocked </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>Heap no within the page for the lock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5a13c16488466902242a906b82422a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a13c16488466902242a906b82422a7">&#9670;&nbsp;</a></span>lock_rec_reset_and_inherit_gap_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rec_reset_and_inherit_gap_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>heir_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heir_heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the original locks on heir and replaces them with gap type locks inherited from rec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heir_block</td><td>Block containing the record which inherits </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Block containing the record from which inherited; does not reset the locks on this record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heir_heap_no</td><td>Heap_no of the inheriting record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>Heap_no of the donating record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a39c043b7a0da7ad896f9c8b1784d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a39c043b7a0da7ad896f9c8b1784d19">&#9670;&nbsp;</a></span>lock_rec_reset_and_release_wait()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_reset_and_release_wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the lock bits for a single record. </p>
<p>Releases transactions waiting for lock requests here. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing the record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c38c5e5e038b3ff28600a1e1f81718f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c38c5e5e038b3ff28600a1e1f81718f">&#9670;&nbsp;</a></span>lock_rec_reset_and_release_wait_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_rec_reset_and_release_wait_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhash__table__t.html">hash_table_t</a> *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets the lock bits for a single record. </p>
<p>Releases transactions waiting for lock requests here. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>in: hash table </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block containing the record </td></tr>
    <tr><td class="paramname">heap_no</td><td>in: heap number of record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1ddd74f278136a863417a7fcafecceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ddd74f278136a863417a7fcafecceb">&#9670;&nbsp;</a></span>lock_rec_reset_nth_bit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> lock_rec_reset_nth_bit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the nth bit of a record lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>record lock </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of the bit that will be reset </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>previous value of the bit </dd></dl>

</div>
</div>
<a id="ae70020e803cb615546ffde6384bb8505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70020e803cb615546ffde6384bb8505">&#9670;&nbsp;</a></span>lock_rec_restore_from_page_infimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rec_restore_from_page_infimum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>donator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restores the state of explicit lock requests on a single record, where the state was stored on the infimum of the page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Buffer block containing rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>Record whose lock state is restored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">donator</td><td>Page (rec is not necessarily on this page) whose infimum stored the lock state; lock bits are reset on the infimum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63e2620fd1f715019989f11107c2de47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e2620fd1f715019989f11107c2de47">&#9670;&nbsp;</a></span>lock_rec_store_on_page_infimum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rec_store_on_page_infimum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores on the page infimum record the explicit locks of another record. </p>
<p>This function is used to store the lock state of a record when it is updated and the size of the record changes in the update. The record is moved in such an update, perhaps to another page. The infimum record acts as a dummy carrier record, taking care of lock releases while the actual record is being moved. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record whose lock state is stored on the infimum record of the same page; lock bits are reset on the record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc396ea6e4e953a9400b711b2d57230f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc396ea6e4e953a9400b711b2d57230f">&#9670;&nbsp;</a></span>lock_rec_trx_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rec_trx_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset the nth bit of a record lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>record lock </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>index of the bit that will be reset </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>whether the lock is in wait mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a385872f00cebe85ef57ac1ee1d1a9ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385872f00cebe85ef57ac1ee1d1a9ec5">&#9670;&nbsp;</a></span>lock_rec_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rec_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>lock_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a granted record lock of a transaction from the queue and grants locks to other transactions waiting in the queue if they now are entitled to a lock. </p>
<p>This function is meant to be used only by row_unlock_for_mysql, and it assumes that the lock we are looking for has LOCK_REC_NOT_GAP flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction that has set a record lock </td></tr>
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record </td></tr>
    <tr><td class="paramname">lock_mode</td><td>in: LOCK_S or LOCK_X </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acaaf94eb0978b4f4623a40bd8a2a376d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaaf94eb0978b4f4623a40bd8a2a376d">&#9670;&nbsp;</a></span>lock_rec_validate_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_rec_validate_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates the record lock queues on a page. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add8eda56dfbfc87c40fc55a96c779b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8eda56dfbfc87c40fc55a96c779b32">&#9670;&nbsp;</a></span>lock_release()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases transaction locks, and releases possible other transactions waiting because of these locks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trx</td><td>transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92a50f54e8700cb44a27c398426a6308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a50f54e8700cb44a27c398426a6308">&#9670;&nbsp;</a></span>lock_release_autoinc_last_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_release_autoinc_last_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release the last lock from the transaction's autoinc locks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>trx which vector of AUTOINC locks to modify </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0586798d137559b27f00d9212a565ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0586798d137559b27f00d9212a565ed7">&#9670;&nbsp;</a></span>lock_release_autoinc_locks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_release_autoinc_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release all the transaction's autoinc locks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63dd528e3d441f569e6d841e63515163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63dd528e3d441f569e6d841e63515163">&#9670;&nbsp;</a></span>lock_release_gap_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_release_gap_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlock the GAP Lock part of a Next Key Lock and grant it to waiters (if any) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lock</td><td>lock object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af277e85e3615915a087ab2ad35ff58c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af277e85e3615915a087ab2ad35ff58c9">&#9670;&nbsp;</a></span>lock_release_read_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_release_read_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>only_gap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to release a lock during PREPARE. </p>
<p>The lock is only released if rules permit it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>the lock that we consider releasing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">only_gap</td><td>true if we don't want to release records, just the gaps between them </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ef596f4d04a32dc7eeea3e7a8481341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ef596f4d04a32dc7eeea3e7a8481341">&#9670;&nbsp;</a></span>lock_remove_all_on_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_remove_all_on_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>remove_also_table_sx_locks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes locks on a table to be dropped. </p>
<p>If remove_also_table_sx_locks is true then table-level S and X locks are also removed in addition to other table-level and record-level locks. No lock, that is going to be removed, is allowed to be a wait lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table to be dropped or discarded </td></tr>
    <tr><td class="paramname">remove_also_table_sx_locks</td><td>in: also removes table S and X locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c114fec902791921c84d744e35e6f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c114fec902791921c84d744e35e6f20">&#9670;&nbsp;</a></span>lock_remove_all_on_table_for_trx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_remove_all_on_table_for_trx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>remove_also_table_sx_locks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes locks of a transaction on a table to be dropped. </p>
<p>If remove_also_table_sx_locks is true then table-level S and X locks are also removed in addition to other table-level and record-level locks. No lock that is going to be removed is allowed to be a wait lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table to be dropped </td></tr>
    <tr><td class="paramname">trx</td><td>in: a transaction </td></tr>
    <tr><td class="paramname">remove_also_table_sx_locks</td><td>in: also removes table S and X locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0441a5473b53bfbed8aeec335812c381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0441a5473b53bfbed8aeec335812c381">&#9670;&nbsp;</a></span>lock_remove_recovered_trx_record_locks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint lock_remove_recovered_trx_record_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove any explicit record locks held by recovering transactions on the table. </p>
<dl class="section return"><dt>Returns</dt><dd>number of recovered transactions examined </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: check if there are any locks held on records in this table or on the table itself </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac881161276c0dfc1994b2af6d22f3ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac881161276c0dfc1994b2af6d22f3ea5">&#9670;&nbsp;</a></span>lock_report_trx_id_insanity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_report_trx_id_insanity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>trx_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="trx0types_8h.html#a91afca43a639c098efe14a9069a1d4ec">trx_id_t</a>&#160;</td>
          <td class="paramname"><em>max_trx_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports that a transaction id is insensible, i.e., in the future. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx_id</td><td>Trx id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>User record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>Rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">max_trx_id</td><td>Trx_sys_get_max_trx_id() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cec2831a61b0f4e9e4d54647fcd66e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cec2831a61b0f4e9e4d54647fcd66e9">&#9670;&nbsp;</a></span>lock_reuse_for_next_key_lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_reuse_for_next_key_lock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>held_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper function for lock_rec_lock_slow(), which grants a Next Key Lock (either LOCK_X or LOCK_S as specified by <code>mode</code>) on &lt;<code>block</code>,<code>heap_no</code>&gt; in the <code>index</code> to the <code>trx</code>, assuming that it already has a granted <code>held_lock</code>, which is at least as strong as mode|LOCK_REC_NOT_GAP. </p>
<p>It does so by either reusing the lock if it already covers the gap, or by ensuring a separate GAP Lock, which in combination with Record Lock satisfies the request. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">held_lock</td><td>a lock granted to <code>trx</code> which is at least as strong as mode|LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>requested lock mode: LOCK_X or LOCK_S </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block containing the record to be locked </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>heap number of the record to be locked </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index of record to be locked </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>the transaction requesting the Next Key Lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47fefbca8fe9d4d308d925eff524b4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fefbca8fe9d4d308d925eff524b4f8">&#9670;&nbsp;</a></span>lock_rtr_move_rec_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_rtr_move_rec_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="gis0type_8h.html#a2d71af64b5717827d5581da7a7b4a180">rtr_rec_move_t</a> *&#160;</td>
          <td class="paramname"><em>rec_move</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>num_move</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves the explicit locks on user records to another page if a record list start is moved to another page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_block</td><td>Index page to move to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Index page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec_move</td><td>Recording records moved </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_move</td><td>Num of rec to move </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53a7181a1b37cd5b082c7b41f816e7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a7181a1b37cd5b082c7b41f816e7be">&#9670;&nbsp;</a></span>lock_sec_rec_cons_read_sees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_sec_rec_cons_read_sees </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classReadView.html">ReadView</a> *&#160;</td>
          <td class="paramname"><em>view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that a non-clustered index record is seen in a consistent read. </p>
<p>NOTE that a non-clustered index page contains so little information on its modifications that also in the case false, the present version of rec may be the right, but we must check this from the clustered index record.</p>
<dl class="section return"><dt>Returns</dt><dd>true if certainly sees, or false if an earlier version of the clustered index record might be needed </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: user record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramname">index</td><td>in: index </td></tr>
    <tr><td class="paramname">view</td><td>in: consistent read view </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae00980a4b5a19525a76a41633a5acfb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00980a4b5a19525a76a41633a5acfb2">&#9670;&nbsp;</a></span>lock_sec_rec_modify_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_sec_rec_modify_check_and_lock </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if locks of other transactions prevent an immediate modify (delete mark or delete unmark) of a secondary index record. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or DB_DEADLOCK </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">block</td><td>in/out: buffer block of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: record which should be modified; NOTE: as this is a secondary index, we always have to modify the clustered index record first: see the comment below </td></tr>
    <tr><td class="paramname">index</td><td>in: secondary index </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread (can be NULL if BTR_NO_LOCKING_FLAG) </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad964d7dd2bf2a24e44069405e7ef1011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad964d7dd2bf2a24e44069405e7ef1011">&#9670;&nbsp;</a></span>lock_sec_rec_read_check_and_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_sec_rec_read_check_and_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="lock0lock_8h.html#adfd720ce09a7e9babfd890d6a3c3d0a3">lock_duration_t</a>&#160;</td>
          <td class="paramname"><em>duration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a>&#160;</td>
          <td class="paramname"><em>sel_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>gap_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like lock_clust_rec_read_check_and_lock(), but reads a secondary index record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">duration</td><td>If equal to AT_LEAST_STATEMENT, then makes sure that the lock will be kept around and inherited for at least the duration of current statement. If equal to REGULAR the life-cycle of the lock will depend on isolation level rules. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block of rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>user record or page supremum record which should be read or passed over by a read cursor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>secondary index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sel_mode</td><td>select mode: SELECT_ORDINARY, SELECT_SKIP_LOKCED, or SELECT_NO_WAIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>mode of the lock which the read cursor should set on records: LOCK_S or LOCK_X; the latter is possible in SELECT FOR UPDATE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gap_mode</td><td>LOCK_ORDINARY, LOCK_GAP, or LOCK_REC_NOT_GAP </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thr</td><td>query thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, DB_LOCK_WAIT, DB_DEADLOCK, DB_SKIP_LOCKED, or DB_LOCK_NOWAIT </dd></dl>

</div>
</div>
<a id="ad51fc9d5d1a77f69b4fb7a4cbdbfa036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51fc9d5d1a77f69b4fb7a4cbdbfa036">&#9670;&nbsp;</a></span>lock_sec_rec_some_has_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structtrx__t.html">trx_t</a>* lock_sec_rec_some_has_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if some transaction has an implicit x-lock on a record in a secondary index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>user record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>secondary index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>rec_get_offsets(rec, index) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transaction id of the transaction which has the x-lock, or 0; NOTE that this function can return false positives but never false negatives. The caller must confirm all positive results by checking if the trx is still active. </dd></dl>

</div>
</div>
<a id="ae0110e6281abe4ae1837ce04ff99279a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0110e6281abe4ae1837ce04ff99279a">&#9670;&nbsp;</a></span>lock_set_lock_and_trx_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_set_lock_and_trx_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the wait flag of a lock and the back pointer in trx to lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock</td><td>The lock on which a transaction is waiting </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0ba28814c32fc40e4c71c8a32f6fdba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ba28814c32fc40e4c71c8a32f6fdba">&#9670;&nbsp;</a></span>lock_set_timeout_event()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_set_timeout_event </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the lock system timeout event. </p>

</div>
</div>
<a id="a127c8053fd0338b4d796d0c0de0272dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127c8053fd0338b4d796d0c0de0272dd">&#9670;&nbsp;</a></span>lock_sys_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_sys_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes the lock system at database shutdown. </p>

</div>
</div>
<a id="a6b61b8949e0116857ff488de16509d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b61b8949e0116857ff488de16509d4d">&#9670;&nbsp;</a></span>lock_sys_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_sys_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the lock system at database start. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_cells</td><td>in: number of slots in lock hash table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6032b9d467a2fa36b3a6b1532df30a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6032b9d467a2fa36b3a6b1532df30a33">&#9670;&nbsp;</a></span>lock_sys_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_sys_resize </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_cells</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize the lock hash tables. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_cells</td><td>number of slots in lock hash table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1a3a3e111f874ce25075882ef35dfd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a3a3e111f874ce25075882ef35dfd9">&#9670;&nbsp;</a></span>lock_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_table </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the specified database table in the mode given. </p>
<p>If the lock cannot be granted immediately, the query thread is put to wait. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_LOCK_WAIT, or DB_DEADLOCK </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>in: if BTR_NO_LOCKING_FLAG bit is set, does nothing </td></tr>
    <tr><td class="paramname">table</td><td>in/out: database table in dictionary cache </td></tr>
    <tr><td class="paramname">mode</td><td>in: lock mode </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a184b272b7c4a2c9e49e7e973fbb2d4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a184b272b7c4a2c9e49e7e973fbb2d4ed">&#9670;&nbsp;</a></span>lock_table_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="structlock__t.html">lock_t</a>* lock_table_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table lock object and adds it as the last in the lock queue of the table. </p>
<p>Does NOT check for deadlocks or lock compatibility. </p><dl class="section return"><dt>Returns</dt><dd>own: new lock object </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in/out: database table in dictionary cache </td></tr>
    <tr><td class="paramname">type_mode</td><td>in: lock mode possibly ORed with LOCK_WAIT </td></tr>
    <tr><td class="paramname">trx</td><td>in: trx </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa10e4db7d11e1b4a0a5d3afd17467334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10e4db7d11e1b4a0a5d3afd17467334">&#9670;&nbsp;</a></span>lock_table_dequeue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_table_dequeue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>in_lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a table lock request, waiting or granted, from the queue and grants locks to other transactions in the queue, if they now are entitled to a lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_lock</td><td>in/out: table lock object; transactions waiting behind will get their lock requests granted, if they are now qualified to it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadc404f482d9124b4450bc71d73e69c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc404f482d9124b4450bc71d73e69c6">&#9670;&nbsp;</a></span>lock_table_enqueue_waiting()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_table_enqueue_waiting </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueues a waiting request for a table lock which cannot be granted immediately. </p>
<p>Checks for deadlocks. </p><dl class="section return"><dt>Returns</dt><dd>DB_LOCK_WAIT or DB_DEADLOCK </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>in: lock mode this transaction is requesting </td></tr>
    <tr><td class="paramname">table</td><td>in/out: table </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94f8b30188b58505e53584a7c428a95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f8b30188b58505e53584a7c428a95d">&#9670;&nbsp;</a></span>lock_table_for_trx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_table_for_trx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a lock on a table based on the given mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table to lock </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trx</td><td>transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>LOCK_X or LOCK_S </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error code or DB_SUCCESS. </dd></dl>

</div>
</div>
<a id="a7271bf61ea0010a2552e9343dad624c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7271bf61ea0010a2552e9343dad624c3">&#9670;&nbsp;</a></span>lock_table_has_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_table_has_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there are any locks (table or rec) against table. </p>
<p>Returned value might be obsolete. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>the table </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there were any locks held on records in this table or on the table itself at some point in time during the call </dd></dl>
<p>The n_rec_locks field might be modified by operation on any page shard, so we need to latch everything. Note, that the results of this function will be obsolete, as soon as we release the latch. It is called in contexts where we believe that the number of locks should either be zero or decreasing. For such scenario of usage, we might perhaps read the n_rec_locks without latch and restrict latch just to a table shard. But that would complicate the debug version of the code for no significant gain as this is not a hot path. </p>

</div>
</div>
<a id="a00d214bf5c5587f08c7f0a24134ff138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d214bf5c5587f08c7f0a24134ff138">&#9670;&nbsp;</a></span>lock_table_has_to_wait_in_queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structlock__t.html">lock_t</a>* lock_table_has_to_wait_in_queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>wait_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>blocking_trx</em> = <code><a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a waiting table lock request still has to wait in a queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_lock</td><td>Waiting table lock </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocking_trx</td><td>If not nullptr, it restricts the search to only the locks held by the blocking_trx, which is useful in case when there might be multiple reasons for waiting in queue, but we need to report the specific one. Useful when reporting a deadlock cycle. (optional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The conflicting lock which is the reason wait_lock has to wait or nullptr if it can be granted now </dd></dl>

</div>
</div>
<a id="a8b1d4aaa7d211a0b5fa98edcf3b7c09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1d4aaa7d211a0b5fa98edcf3b7c09b">&#9670;&nbsp;</a></span>lock_table_ix_resurrect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_table_ix_resurrect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a table IX lock object for a resurrected transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">table</td><td>Table </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trx</td><td>Transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8df4975363491df12966baa045ea3546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df4975363491df12966baa045ea3546">&#9670;&nbsp;</a></span>lock_table_lock_list_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_table_lock_list_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dict0mem_8h.html#a47e92c93f6a5c35342487951b263812d">table_lock_list_t</a> *&#160;</td>
          <td class="paramname"><em>lock_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the table lock list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">lock_list</td><td>List to initialise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca1fa8e49263ea226696d339f29a685f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca1fa8e49263ea226696d339f29a685f">&#9670;&nbsp;</a></span>lock_table_locks_lookup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structlock__t.html">lock_t</a>* lock_table_locks_lookup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const trx_ut_list_t *&#160;</td>
          <td class="paramname"><em>trx_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do an exhaustive check for any locks (table or rec) against the table. </p>
<dl class="section return"><dt>Returns</dt><dd>lock if found </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: check if there are any locks held on records in this table or on the table itself </td></tr>
    <tr><td class="paramname">trx_list</td><td>in: trx list to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebd493385965cf18a23b428ffca184ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd493385965cf18a23b428ffca184ca">&#9670;&nbsp;</a></span>lock_table_other_has_incompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE const <a class="el" href="structlock__t.html">lock_t</a>* lock_table_other_has_incompatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>wait</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#acff05fa7dd69832a04f93b92db1e0013">lock_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if other transactions have an incompatible mode lock request in the lock queue. </p>
<dl class="section return"><dt>Returns</dt><dd>lock or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction, or NULL if all transactions should be included </td></tr>
    <tr><td class="paramname">wait</td><td>in: LOCK_WAIT if also waiting locks are taken into account, or 0 if not </td></tr>
    <tr><td class="paramname">table</td><td>in: table </td></tr>
    <tr><td class="paramname">mode</td><td>in: lock mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae88eb4bd1862004641853bdac32e3da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae88eb4bd1862004641853bdac32e3da">&#9670;&nbsp;</a></span>lock_table_pop_autoinc_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_table_pop_autoinc_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops autoinc lock requests from the transaction's autoinc_locks. </p>
<p>We handle the case where there are gaps in the array and they need to be popped off the stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction that owns the AUTOINC locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3916adee88293aa3f29a6e3994248d93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3916adee88293aa3f29a6e3994248d93">&#9670;&nbsp;</a></span>lock_table_print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_table_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints info of a table lock. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
    <tr><td class="paramname">lock</td><td>in: table type lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad446d238fbe34e26616c0bec50c1cb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad446d238fbe34e26616c0bec50c1cb7d">&#9670;&nbsp;</a></span>lock_table_queue_validate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_table_queue_validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates the lock queue on a table. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a678cd8514367bc1b2b43d3df58ce5325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678cd8514367bc1b2b43d3df58ce5325">&#9670;&nbsp;</a></span>lock_table_remove_autoinc_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_table_remove_autoinc_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes an autoinc lock request from the transaction's autoinc_locks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in: table lock </td></tr>
    <tr><td class="paramname">trx</td><td>in/out: transaction that owns the lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab3ef5a97ef26d0edfffcca4f4d413ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3ef5a97ef26d0edfffcca4f4d413ed">&#9670;&nbsp;</a></span>lock_table_remove_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void lock_table_remove_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a table lock request from the queue and the trx list of locks; this is a low-level function which does NOT check if waiting requests can now be granted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>in/out: table lock </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd23066177e056191e90bae4f14215e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd23066177e056191e90bae4f14215e0">&#9670;&nbsp;</a></span>lock_trx_alloc_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_trx_alloc_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocate cached locks for the transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>allocate cached record locks for this transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeefbced8febccb3e8ab67e20ee33b0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeefbced8febccb3e8ab67e20ee33b0b4">&#9670;&nbsp;</a></span>lock_trx_handle_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> lock_trx_handle_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether the transaction has already been rolled back because it was selected as a deadlock victim, or if it has to wait then cancel the wait lock. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_DEADLOCK, DB_LOCK_WAIT or DB_SUCCESS </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: trx lock state </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99887080ffdb266d6f94b5938ab423d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99887080ffdb266d6f94b5938ab423d2">&#9670;&nbsp;</a></span>lock_trx_has_rec_x_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_trx_has_rec_x_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heap_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the transaction holds an exclusive lock on a record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread of the transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">table</td><td>table to check </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block of the record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap_no</td><td>record heap number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the locks are held </dd></dl>

</div>
</div>
<a id="aed9583aff22e270def04a7697faaa1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9583aff22e270def04a7697faaa1e9">&#9670;&nbsp;</a></span>lock_trx_holds_autoinc_locks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_trx_holds_autoinc_locks </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a transaction holds any autoinc locks. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the transaction holds any AUTOINC locks. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82f5f27eeb669c559bcf49469cbe3d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f5f27eeb669c559bcf49469cbe3d16">&#9670;&nbsp;</a></span>lock_trx_lock_list_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_trx_lock_list_init </td>
          <td>(</td>
          <td class="paramtype">trx_lock_list_t *&#160;</td>
          <td class="paramname"><em>lock_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the trx lock list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock_list</td><td>List to initialise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af61a28220b173b01cf7ca52d7e056ec4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61a28220b173b01cf7ca52d7e056ec4">&#9670;&nbsp;</a></span>lock_trx_print_locks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_trx_print_locks </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrxLockIterator.html">TrxLockIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>load_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Prints info of locks for a transaction. </p>
<dl class="section return"><dt>Returns</dt><dd>true if all printed, false if latches were released. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in/out: File to write </td></tr>
    <tr><td class="paramname">trx</td><td>in: current transaction </td></tr>
    <tr><td class="paramname">iter</td><td>in: transaction lock iterator </td></tr>
    <tr><td class="paramname">load_block</td><td>in: if true then read block from disk </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4b2ef62b3cd2784b7d3d3c442d9a320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b2ef62b3cd2784b7d3d3c442d9a320">&#9670;&nbsp;</a></span>lock_trx_print_wait_and_mvcc_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_trx_print_wait_and_mvcc_state </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints transaction lock wait and MVCC state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">file</td><td>file where to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fbb256f6d14ba050d686b9ba1d007b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbb256f6d14ba050d686b9ba1d007b0">&#9670;&nbsp;</a></span>lock_trx_release_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_trx_release_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases a transaction's locks, and releases possible other transactions waiting because of these locks. </p>
<p>Change the state of the transaction to TRX_STATE_COMMITTED_IN_MEMORY. </p>
<p>Doing an implicit to explicit conversion should not be expensive. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a837664214700c0a21ff9c6ab1085fa76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837664214700c0a21ff9c6ab1085fa76">&#9670;&nbsp;</a></span>lock_trx_release_read_locks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_trx_release_read_locks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>only_gap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Release read locks of a transaction. </p>
<p>It is called during XA prepare to release locks early. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trx</td><td>transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">only_gap</td><td>release only GAP locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8adabe4366256b19cd9b6dd50e530d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adabe4366256b19cd9b6dd50e530d6b">&#9670;&nbsp;</a></span>lock_trx_release_read_locks_in_x_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_trx_release_read_locks_in_x_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>only_gap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release read locks of a transacion latching the whole lock-sys in exclusive mode, which is a bit too expensive to do by default. </p>
<p>It is called during XA prepare to release locks early. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trx</td><td>transaction </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">only_gap</td><td>release only GAP locks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaad933826c1fceedca17c0491ff82e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad933826c1fceedca17c0491ff82e24">&#9670;&nbsp;</a></span>lock_trx_table_locks_find()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_trx_table_locks_find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>find_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the lock exists in the trx_t::trx_lock_t::table_locks vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>the trx to validate </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">find_lock</td><td>lock to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if found </dd></dl>

</div>
</div>
<a id="a7abfdceec128a59cd3c1ad2569bb3eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abfdceec128a59cd3c1ad2569bb3eaf">&#9670;&nbsp;</a></span>lock_trx_table_locks_remove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_trx_table_locks_remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>lock_to_remove</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes lock_to_remove from lock_to_remove-&gt;trx-&gt;lock.table_locks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lock_to_remove</td><td>lock to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5af6183a5555e7a95a366be8aaa7f280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af6183a5555e7a95a366be8aaa7f280">&#9670;&nbsp;</a></span>lock_unlock_table_autoinc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_unlock_table_autoinc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks AUTO_INC type locks that were possibly reserved by a trx. </p>
<p>This function should be called at the the end of an SQL statement, by the connection thread that owns the transaction (trx-&gt;mysql_thd). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in/out: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72d530560f93577d1c8b2865251a3a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d530560f93577d1c8b2865251a3a47">&#9670;&nbsp;</a></span>lock_update_copy_and_discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_copy_and_discard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>new_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when a page is copied to another and the original page is removed from the chain of leaf pages, except if page is the root! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_block</td><td>Index page to which copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Index page; not the root! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2d9fef0df1b551f23c7da52fd68accd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d9fef0df1b551f23c7da52fd68accd">&#9670;&nbsp;</a></span>lock_update_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when a record is removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Buffer block containing rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>The record to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11c59f431194af5e5f6a6842bfe50344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c59f431194af5e5f6a6842bfe50344">&#9670;&nbsp;</a></span>lock_update_discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_discard </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>heir_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>heir_heap_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when a page is discarded. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">heir_block</td><td>Index page which will inherit the locks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heir_heap_no</td><td>Heap_no of the record which will inherit the locks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Index page which will be discarded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3de1c790f6a289f4b803acab127b3755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de1c790f6a289f4b803acab127b3755">&#9670;&nbsp;</a></span>lock_update_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when a new user record is inserted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: buffer block containing rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: the inserted record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa151b0e44c3fd7542ef9441ac2125988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa151b0e44c3fd7542ef9441ac2125988">&#9670;&nbsp;</a></span>lock_update_merge_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_merge_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>orig_pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when a page is merged to the left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">left_block</td><td>Left page to which merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orig_pred</td><td>Original predecessor of supremum on the left page before merge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">right_block</td><td>Merged index page which will be discarded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98d987baa574ae26300c02c38d3297aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d987baa574ae26300c02c38d3297aa">&#9670;&nbsp;</a></span>lock_update_merge_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_merge_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>orig_succ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when a page is merged to the right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">right_block</td><td>Right page to which merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">orig_succ</td><td>Original successor of infimum on the right page before merge </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left_block</td><td>Merged index page which will be discarded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa60bc5af0ffa9cbef92444c2f36cbca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60bc5af0ffa9cbef92444c2f36cbca0">&#9670;&nbsp;</a></span>lock_update_root_raise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_root_raise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when the root page is copied to another in btr_root_raise_and_insert. </p>
<p>Note that we leave lock structs on the root page, even though they do not make sense on other than leaf pages: the reason is that in a pessimistic update the infimum record of the root page will act as a dummy carrier of the locks of the record to be updated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: index page to which copied </td></tr>
    <tr><td class="paramname">root</td><td>in: root page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c056f069cb338691dafe4665b8a4435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c056f069cb338691dafe4665b8a4435">&#9670;&nbsp;</a></span>lock_update_split_left()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_split_left </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when a page is split to the left. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">right_block</td><td>Right page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left_block</td><td>Left page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9af01b85f0aa5d1e2d0e026044673110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af01b85f0aa5d1e2d0e026044673110">&#9670;&nbsp;</a></span>lock_update_split_right()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lock_update_split_right </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>right_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>left_block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the lock table when a page is split to the right. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">right_block</td><td>Right page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">left_block</td><td>Left page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfcc1f9fe684413ac1f7a92879666500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcc1f9fe684413ac1f7a92879666500">&#9670;&nbsp;</a></span>lock_update_wait_for_edge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void lock_update_wait_for_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>waiting_lock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structlock__t.html">lock_t</a> *&#160;</td>
          <td class="paramname"><em>blocking_lock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a waiting_lock, and blocking_lock which is the reason it has to wait, makes sure that the (only) edge in the wait-for graph outgoing from the waiting_lock-&gt;trx points to blocking_lock-&gt;trx. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">waiting_lock</td><td>A lock waiting in queue, blocked by blocking_lock </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocking_lock</td><td>A lock which is a reason the waiting_lock has to wait </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4aba7196cfa609a25581a9c37537b697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aba7196cfa609a25581a9c37537b697">&#9670;&nbsp;</a></span>lock_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_validate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the lock system. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>

</div>
</div>
<a id="a56cdc6c7c0c17d28163ffaa415e177ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cdc6c7c0c17d28163ffaa415e177ad">&#9670;&nbsp;</a></span>lock_validate_table_locks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_validate_table_locks </td>
          <td>(</td>
          <td class="paramtype">const trx_ut_list_t *&#160;</td>
          <td class="paramname"><em>trx_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates the table locks. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx_list</td><td>in: trx list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a81d550ee42c724c84fb023128ce80147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d550ee42c724c84fb023128ce80147">&#9670;&nbsp;</a></span>innobase_deadlock_detect</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> innobase_deadlock_detect = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82f9f4beca353dd655536095ea4d2ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f9f4beca353dd655536095ea4d2ad7">&#9670;&nbsp;</a></span>lock_cached_lock_mode_names</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>, const char *&gt; lock_cached_lock_mode_names</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used by lock_get_mode_str to cache results. </p>
<p>Strings pointed by these pointers might be in use by performance schema and thus can not be freed until the very end. Protected by exclusive global lock_sys latch. </p>

</div>
</div>
<a id="af0872da603ecd1de7f39c8beaa8b71e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0872da603ecd1de7f39c8beaa8b71e1">&#9670;&nbsp;</a></span>lock_constant_names</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>, const char *&gt; lock_constant_names</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">    {<a class="code" href="lock0lock_8h.html#a8631af3f85d4c19484f6de819b2b2a37">LOCK_GAP</a>, <span class="stringliteral">&quot;GAP&quot;</span>},</div><div class="line">    {<a class="code" href="lock0lock_8h.html#a5ec9b0cce21ee17de083d3bb96b1bec6">LOCK_REC_NOT_GAP</a>, <span class="stringliteral">&quot;REC_NOT_GAP&quot;</span>},</div><div class="line">    {<a class="code" href="lock0lock_8h.html#a7a448126f7465de2aa940d1751dd8b7e">LOCK_INSERT_INTENTION</a>, <span class="stringliteral">&quot;INSERT_INTENTION&quot;</span>},</div><div class="line">    {<a class="code" href="lock0lock_8h.html#a7e59e399364d823b33bc010e93e9c278">LOCK_PREDICATE</a>, <span class="stringliteral">&quot;PREDICATE&quot;</span>},</div><div class="line">    {<a class="code" href="lock0lock_8h.html#a7fe3f32b4e6bb44b08818eea5638e94b">LOCK_PRDT_PAGE</a>, <span class="stringliteral">&quot;PRDT_PAGE&quot;</span>},</div><div class="line">}</div><div class="ttc" id="lock0lock_8h_html_a7fe3f32b4e6bb44b08818eea5638e94b"><div class="ttname"><a href="lock0lock_8h.html#a7fe3f32b4e6bb44b08818eea5638e94b">LOCK_PRDT_PAGE</a></div><div class="ttdeci">#define LOCK_PRDT_PAGE</div><div class="ttdoc">Page lock. </div><div class="ttdef"><b>Definition:</b> lock0lock.h:946</div></div>
<div class="ttc" id="lock0lock_8h_html_a8631af3f85d4c19484f6de819b2b2a37"><div class="ttname"><a href="lock0lock_8h.html#a8631af3f85d4c19484f6de819b2b2a37">LOCK_GAP</a></div><div class="ttdeci">#define LOCK_GAP</div><div class="ttdoc">when this bit is set, it means that the \ lock holds only on the gap before the record; \ for instanc...</div><div class="ttdef"><b>Definition:</b> lock0lock.h:899</div></div>
<div class="ttc" id="lock0lock_8h_html_a5ec9b0cce21ee17de083d3bb96b1bec6"><div class="ttname"><a href="lock0lock_8h.html#a5ec9b0cce21ee17de083d3bb96b1bec6">LOCK_REC_NOT_GAP</a></div><div class="ttdeci">#define LOCK_REC_NOT_GAP</div><div class="ttdoc">this bit means that the lock is only on \ the index record and does NOT block inserts \ to the gap be...</div><div class="ttdef"><b>Definition:</b> lock0lock.h:913</div></div>
<div class="ttc" id="lock0lock_8h_html_a7a448126f7465de2aa940d1751dd8b7e"><div class="ttname"><a href="lock0lock_8h.html#a7a448126f7465de2aa940d1751dd8b7e">LOCK_INSERT_INTENTION</a></div><div class="ttdeci">#define LOCK_INSERT_INTENTION</div><div class="ttdoc">this bit is set when we place a waiting \ gap type record lock request in order to let \ an insert of...</div><div class="ttdef"><b>Definition:</b> lock0lock.h:929</div></div>
<div class="ttc" id="lock0lock_8h_html_a7e59e399364d823b33bc010e93e9c278"><div class="ttname"><a href="lock0lock_8h.html#a7e59e399364d823b33bc010e93e9c278">LOCK_PREDICATE</a></div><div class="ttdeci">#define LOCK_PREDICATE</div><div class="ttdoc">Predicate lock. </div><div class="ttdef"><b>Definition:</b> lock0lock.h:945</div></div>
</div><!-- fragment -->
<p>Used by lock_get_mode_str to build a lock mode description. </p>

</div>
</div>
<a id="a5127cf175e520ae462dd6282c06ab3dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5127cf175e520ae462dd6282c06ab3dd">&#9670;&nbsp;</a></span>lock_deadlock_found</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> lock_deadlock_found = <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We store info on the latest deadlock error to this buffer. </p>
<p>InnoDB Monitor will then fetch it and print </p>

</div>
</div>
<a id="ab58b635675c25066d014d44908f3a487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58b635675c25066d014d44908f3a487">&#9670;&nbsp;</a></span>lock_latest_err_file</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FILE* lock_latest_err_file</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Only created if !srv_read_only_mode. </p>
<p>I/O operations on this file require exclusive lock_sys latch </p>

</div>
</div>
<a id="ac5399aad1a992cb27e897fc806570ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5399aad1a992cb27e897fc806570ba0">&#9670;&nbsp;</a></span>lock_sys</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlock__sys__t.html">lock_sys_t</a>* lock_sys = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The lock system. </p>

</div>
</div>
<a id="a810550c97af735417d7903a97f95631d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810550c97af735417d7903a97f95631d">&#9670;&nbsp;</a></span>REC_LOCK_CACHE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ulint REC_LOCK_CACHE = 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of cached record locks. </p>

</div>
</div>
<a id="ae93dc6084a46cc48951a63a6f9371e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae93dc6084a46cc48951a63a6f9371e91">&#9670;&nbsp;</a></span>REC_LOCK_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ulint REC_LOCK_SIZE = sizeof(ib_lock_t) + 256</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum record lock size in bytes. </p>

</div>
</div>
<a id="a5c0acd94573600dde7c95c7f385edd12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c0acd94573600dde7c95c7f385edd12">&#9670;&nbsp;</a></span>TABLE_LOCK_CACHE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ulint TABLE_LOCK_CACHE = 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total number of cached table locks. </p>

</div>
</div>
<a id="a59eb2cc0c5b0180e9dcedfb8507bf3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59eb2cc0c5b0180e9dcedfb8507bf3c7">&#9670;&nbsp;</a></span>TABLE_LOCK_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ulint TABLE_LOCK_SIZE = sizeof(ib_lock_t)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size in bytes, of the table lock instance. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_a92a0f1911438c718531eeaff646b0b5.html">lock</a></li><li class="navelem"><a class="el" href="lock0lock_8cc.html">lock0lock.cc</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
