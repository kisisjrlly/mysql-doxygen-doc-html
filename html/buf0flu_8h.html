<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/include/buf0flu.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('buf0flu_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">buf0flu.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The database buffer pool flush algorithm.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="buf0types_8h_source.html">buf0types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0log_8h_source.html">log0log.h</a>&quot;</code><br />
<code>#include &quot;univ.i&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0byte_8h_source.html">ut0byte.h</a>&quot;</code><br />
<code>#include &quot;buf0flu.ic&quot;</code><br />
</div>
<p><a href="buf0flu_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlushObserver.html">FlushObserver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We use FlushObserver to track flushing of non-redo logged pages in bulk create index(BtrBulk.cc).Since we disable redo logging during a index build, we need to make sure that all dirty pages modifed by the index build are flushed to disk before any redo logged operations go to the index.  <a href="classFlushObserver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afc32a17f0dc7a9895adec53754ae98cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#afc32a17f0dc7a9895adec53754ae98cd">buf_flush_page_cleaner_is_active</a> ()</td></tr>
<tr class="memdesc:afc32a17f0dc7a9895adec53754ae98cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the page_cleaner is in active state.  <a href="#afc32a17f0dc7a9895adec53754ae98cd">More...</a><br /></td></tr>
<tr class="separator:afc32a17f0dc7a9895adec53754ae98cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ecfb0cf0b18959486e8f155f60fcaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a73ecfb0cf0b18959486e8f155f60fcaf">buf_flush_remove</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a73ecfb0cf0b18959486e8f155f60fcaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a block from the flush list of modified blocks.  <a href="#a73ecfb0cf0b18959486e8f155f60fcaf">More...</a><br /></td></tr>
<tr class="separator:a73ecfb0cf0b18959486e8f155f60fcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3be9763cec3cba165c7b9f4897ac382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#ab3be9763cec3cba165c7b9f4897ac382">buf_flush_relocate_on_flush_list</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="classbuf__page__t.html">buf_page_t</a> *dpage)</td></tr>
<tr class="memdesc:ab3be9763cec3cba165c7b9f4897ac382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Relocates a buffer control block on the flush_list.  <a href="#ab3be9763cec3cba165c7b9f4897ac382">More...</a><br /></td></tr>
<tr class="separator:ab3be9763cec3cba165c7b9f4897ac382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e3dd9b538ed985dbb702a4963374a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a40e3dd9b538ed985dbb702a4963374a9">buf_flush_write_complete</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:a40e3dd9b538ed985dbb702a4963374a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the flush system data structures when a write is completed.  <a href="#a40e3dd9b538ed985dbb702a4963374a9">More...</a><br /></td></tr>
<tr class="separator:a40e3dd9b538ed985dbb702a4963374a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe33c34fe5f19231976b9b60753f3599"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#afe33c34fe5f19231976b9b60753f3599">page_is_uncompressed_type</a> (const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>)</td></tr>
<tr class="memdesc:afe33c34fe5f19231976b9b60753f3599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if page type is uncompressed.  <a href="#afe33c34fe5f19231976b9b60753f3599">More...</a><br /></td></tr>
<tr class="separator:afe33c34fe5f19231976b9b60753f3599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0d8b9bbb44ab1ea73374bfba8d6417"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#afb0d8b9bbb44ab1ea73374bfba8d6417">buf_flush_init_for_writing</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, void *page_zip_, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> newest_lsn, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> skip_checksum, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> skip_lsn_check)</td></tr>
<tr class="memdesc:afb0d8b9bbb44ab1ea73374bfba8d6417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a page for writing to the tablespace.  <a href="#afb0d8b9bbb44ab1ea73374bfba8d6417">More...</a><br /></td></tr>
<tr class="separator:afb0d8b9bbb44ab1ea73374bfba8d6417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82378da645bc734469c6c11e24a15399"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a82378da645bc734469c6c11e24a15399">buf_flush_page_try</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:a82378da645bc734469c6c11e24a15399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a flushable page asynchronously from the buffer pool to a file.  <a href="#a82378da645bc734469c6c11e24a15399">More...</a><br /></td></tr>
<tr class="separator:a82378da645bc734469c6c11e24a15399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42235e1e34a9f14524c48935848d2686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a42235e1e34a9f14524c48935848d2686">buf_flush_do_batch</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> type, ulint min_n, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> lsn_limit, ulint *n_processed)</td></tr>
<tr class="memdesc:a42235e1e34a9f14524c48935848d2686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do flushing batch of a given type.  <a href="#a42235e1e34a9f14524c48935848d2686">More...</a><br /></td></tr>
<tr class="separator:a42235e1e34a9f14524c48935848d2686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528025409ff3ed8503e172b8ae62a6be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a528025409ff3ed8503e172b8ae62a6be">buf_flush_lists</a> (ulint min_n, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> lsn_limit, ulint *n_processed)</td></tr>
<tr class="memdesc:a528025409ff3ed8503e172b8ae62a6be"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility flushes dirty blocks from the end of the flush list of all buffer pool instances.  <a href="#a528025409ff3ed8503e172b8ae62a6be">More...</a><br /></td></tr>
<tr class="separator:a528025409ff3ed8503e172b8ae62a6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43a7147265a4e12b3bb5b6cea221caf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a43a7147265a4e12b3bb5b6cea221caf4">buf_flush_single_page_from_LRU</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a43a7147265a4e12b3bb5b6cea221caf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function picks up a single page from the tail of the LRU list, flushes it (if it is dirty), removes it from page_hash and LRU list and puts it on the free list.  <a href="#a43a7147265a4e12b3bb5b6cea221caf4">More...</a><br /></td></tr>
<tr class="separator:a43a7147265a4e12b3bb5b6cea221caf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b6769e4f299f9c14aa375bb9eab878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a25b6769e4f299f9c14aa375bb9eab878">buf_flush_wait_batch_end</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> <a class="el" href="group__MYSYS.html#gaff94a40cf049a7ffa8c8fdc46b757085">flush_type</a>)</td></tr>
<tr class="memdesc:a25b6769e4f299f9c14aa375bb9eab878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until a flush batch of the given type ends.  <a href="#a25b6769e4f299f9c14aa375bb9eab878">More...</a><br /></td></tr>
<tr class="separator:a25b6769e4f299f9c14aa375bb9eab878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43effc2f445e05e01e858611e1b3a473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a43effc2f445e05e01e858611e1b3a473">buf_flush_wait_batch_end_wait_only</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> type)</td></tr>
<tr class="memdesc:a43effc2f445e05e01e858611e1b3a473"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until a flush batch of the given type ends.  <a href="#a43effc2f445e05e01e858611e1b3a473">More...</a><br /></td></tr>
<tr class="separator:a43effc2f445e05e01e858611e1b3a473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421b3f1cf5a30db8cb88ae04f868fb6f"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a421b3f1cf5a30db8cb88ae04f868fb6f">buf_flush_note_modification</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> start_lsn, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> end_lsn, <a class="el" href="classFlushObserver.html">FlushObserver</a> *observer)</td></tr>
<tr class="memdesc:a421b3f1cf5a30db8cb88ae04f868fb6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should be called at a mini-transaction commit, if a page was modified in it.  <a href="#a421b3f1cf5a30db8cb88ae04f868fb6f">More...</a><br /></td></tr>
<tr class="separator:a421b3f1cf5a30db8cb88ae04f868fb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a109aff89cdb96f674786a8b913be0043"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a109aff89cdb96f674786a8b913be0043">buf_flush_recv_note_modification</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> start_lsn, <a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> end_lsn)</td></tr>
<tr class="memdesc:a109aff89cdb96f674786a8b913be0043"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function should be called when recovery has modified a buffer page.  <a href="#a109aff89cdb96f674786a8b913be0043">More...</a><br /></td></tr>
<tr class="separator:a109aff89cdb96f674786a8b913be0043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab62dc5b248898f799ccc3efdfa91a1a5"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#ab62dc5b248898f799ccc3efdfa91a1a5">buf_flush_ready_for_replace</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage)</td></tr>
<tr class="memdesc:ab62dc5b248898f799ccc3efdfa91a1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if the file page block is immediately suitable for replacement, i.e., the transition FILE_PAGE =&gt; NOT_USED allowed.  <a href="#ab62dc5b248898f799ccc3efdfa91a1a5">More...</a><br /></td></tr>
<tr class="separator:ab62dc5b248898f799ccc3efdfa91a1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2cb1355911c2d1581560fc3ea299f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a6a2cb1355911c2d1581560fc3ea299f5">buf_flush_page_cleaner_disabled_debug_update</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="structSYS__VAR.html">SYS_VAR</a> *var, void *var_ptr, const void *save)</td></tr>
<tr class="memdesc:a6a2cb1355911c2d1581560fc3ea299f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables page cleaner threads (coordinator and workers).  <a href="#a6a2cb1355911c2d1581560fc3ea299f5">More...</a><br /></td></tr>
<tr class="separator:a6a2cb1355911c2d1581560fc3ea299f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ffa9bb53ae04af71f6b0831832e7a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a53ffa9bb53ae04af71f6b0831832e7a8">buf_flush_page_cleaner_init</a> (size_t n_page_cleaners)</td></tr>
<tr class="memdesc:a53ffa9bb53ae04af71f6b0831832e7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize page_cleaner.  <a href="#a53ffa9bb53ae04af71f6b0831832e7a8">More...</a><br /></td></tr>
<tr class="separator:a53ffa9bb53ae04af71f6b0831832e7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9009b835c5483b778102082175f1a95c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a9009b835c5483b778102082175f1a95c">buf_flush_wait_LRU_batch_end</a> ()</td></tr>
<tr class="memdesc:a9009b835c5483b778102082175f1a95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for any possible LRU flushes that are in progress to end.  <a href="#a9009b835c5483b778102082175f1a95c">More...</a><br /></td></tr>
<tr class="separator:a9009b835c5483b778102082175f1a95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49be0031c6d9844ec4fa2bfe8bb97861"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a49be0031c6d9844ec4fa2bfe8bb97861">buf_flush_validate</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool)</td></tr>
<tr class="memdesc:a49be0031c6d9844ec4fa2bfe8bb97861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates the flush list.  <a href="#a49be0031c6d9844ec4fa2bfe8bb97861">More...</a><br /></td></tr>
<tr class="separator:a49be0031c6d9844ec4fa2bfe8bb97861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fee1529fdf99802a4d838f15e2e00f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a4fee1529fdf99802a4d838f15e2e00f4">buf_flush_init_flush_rbt</a> (void)</td></tr>
<tr class="memdesc:a4fee1529fdf99802a4d838f15e2e00f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the red-black tree to speed up insertions into the flush_list during recovery process.  <a href="#a4fee1529fdf99802a4d838f15e2e00f4">More...</a><br /></td></tr>
<tr class="separator:a4fee1529fdf99802a4d838f15e2e00f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7e668a2ff50fe0e70ec6514061315a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a9f7e668a2ff50fe0e70ec6514061315a">buf_flush_free_flush_rbt</a> (void)</td></tr>
<tr class="memdesc:a9f7e668a2ff50fe0e70ec6514061315a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees up the red-black tree.  <a href="#a9f7e668a2ff50fe0e70ec6514061315a">More...</a><br /></td></tr>
<tr class="separator:a9f7e668a2ff50fe0e70ec6514061315a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4f35ed7b257e277bb3c8bdba954bcc"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#aaa4f35ed7b257e277bb3c8bdba954bcc">buf_flush_page</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> <a class="el" href="group__MYSYS.html#gaff94a40cf049a7ffa8c8fdc46b757085">flush_type</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sync)</td></tr>
<tr class="memdesc:aaa4f35ed7b257e277bb3c8bdba954bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a flushable page asynchronously from the buffer pool to a file.  <a href="#aaa4f35ed7b257e277bb3c8bdba954bcc">More...</a><br /></td></tr>
<tr class="separator:aaa4f35ed7b257e277bb3c8bdba954bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecec14617af55f34859e552f9df967d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#aecec14617af55f34859e552f9df967d9">buf_flush_ready_for_flush</a> (<a class="el" href="classbuf__page__t.html">buf_page_t</a> *bpage, <a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a> <a class="el" href="group__MYSYS.html#gaff94a40cf049a7ffa8c8fdc46b757085">flush_type</a>)</td></tr>
<tr class="memdesc:aecec14617af55f34859e552f9df967d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the block is modified and ready for flushing.  <a href="#aecec14617af55f34859e552f9df967d9">More...</a><br /></td></tr>
<tr class="separator:aecec14617af55f34859e552f9df967d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d1cae1738f050554b98aa0eede40fe"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#ab8d1cae1738f050554b98aa0eede40fe">buf_pool_get_dirty_pages_count</a> (<a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *buf_pool, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> <a class="el" href="xcom__base_8cc.html#a7307f729d2752bdbe1d32d9fda65f30a">id</a>, <a class="el" href="classFlushObserver.html">FlushObserver</a> *observer)</td></tr>
<tr class="memdesc:ab8d1cae1738f050554b98aa0eede40fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if there are any dirty pages that belong to a space id in the flush list in a particular buffer pool.  <a href="#ab8d1cae1738f050554b98aa0eede40fe">More...</a><br /></td></tr>
<tr class="separator:ab8d1cae1738f050554b98aa0eede40fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b8fee83b5a7a0569c8e0e9eb6d596b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#ae1b8fee83b5a7a0569c8e0e9eb6d596b">buf_flush_sync_all_buf_pools</a> (void)</td></tr>
<tr class="memdesc:ae1b8fee83b5a7a0569c8e0e9eb6d596b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronously flush dirty blocks from the end of the flush list of all buffer pool instances.  <a href="#ae1b8fee83b5a7a0569c8e0e9eb6d596b">More...</a><br /></td></tr>
<tr class="separator:ae1b8fee83b5a7a0569c8e0e9eb6d596b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d0b53149ea04d5d4afb4150a6e8f7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#ae5d0b53149ea04d5d4afb4150a6e8f7f">buf_flush_request_force</a> (<a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a> lsn_limit)</td></tr>
<tr class="memdesc:ae5d0b53149ea04d5d4afb4150a6e8f7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request IO burst and wake page_cleaner up.  <a href="#ae5d0b53149ea04d5d4afb4150a6e8f7f">More...</a><br /></td></tr>
<tr class="separator:ae5d0b53149ea04d5d4afb4150a6e8f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0553b7e69d539966d0ff4096b2bf4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a6b0553b7e69d539966d0ff4096b2bf4c">reset_buf_flush_sync_lsn</a> ()</td></tr>
<tr class="memdesc:a6b0553b7e69d539966d0ff4096b2bf4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset sync LSN if beyond current log sys LSN.  <a href="#a6b0553b7e69d539966d0ff4096b2bf4c">More...</a><br /></td></tr>
<tr class="separator:a6b0553b7e69d539966d0ff4096b2bf4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2fb0fb1a47fd6f6aedcf7bc054c4add"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#ad2fb0fb1a47fd6f6aedcf7bc054c4add">buf_are_flush_lists_empty_validate</a> ()</td></tr>
<tr class="memdesc:ad2fb0fb1a47fd6f6aedcf7bc054c4add"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all flush lists are empty.  <a href="#ad2fb0fb1a47fd6f6aedcf7bc054c4add">More...</a><br /></td></tr>
<tr class="separator:ad2fb0fb1a47fd6f6aedcf7bc054c4add"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ade5ded563e72647ca835048b2f4f0c5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#ade5ded563e72647ca835048b2f4f0c5b">innodb_page_cleaner_disabled_debug</a></td></tr>
<tr class="memdesc:ade5ded563e72647ca835048b2f4f0c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value of MySQL global variable used to disable page cleaner.  <a href="#ade5ded563e72647ca835048b2f4f0c5b">More...</a><br /></td></tr>
<tr class="separator:ade5ded563e72647ca835048b2f4f0c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89813a5f0a56b1a2baf315553652fa42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a89813a5f0a56b1a2baf315553652fa42">buf_flush_event</a></td></tr>
<tr class="memdesc:a89813a5f0a56b1a2baf315553652fa42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event to synchronise with the flushing.  <a href="#a89813a5f0a56b1a2baf315553652fa42">More...</a><br /></td></tr>
<tr class="separator:a89813a5f0a56b1a2baf315553652fa42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0f75b6932976e19431ee9f5f550faf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="buf0flu_8h.html#a7e0f75b6932976e19431ee9f5f550faf">buf_flush_tick_event</a></td></tr>
<tr class="memdesc:a7e0f75b6932976e19431ee9f5f550faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event to wait for one flushing step.  <a href="#a7e0f75b6932976e19431ee9f5f550faf">More...</a><br /></td></tr>
<tr class="separator:a7e0f75b6932976e19431ee9f5f550faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The database buffer pool flush algorithm. </p>
<p>Created 11/5/1995 Heikki Tuuri </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ad2fb0fb1a47fd6f6aedcf7bc054c4add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2fb0fb1a47fd6f6aedcf7bc054c4add">&#9670;&nbsp;</a></span>buf_are_flush_lists_empty_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_are_flush_lists_empty_validate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if all flush lists are empty. </p>
<p>It is supposed to be used in single thread, during startup or shutdown. Hence it does not acquire lock and it is caller's responsibility to guarantee that flush lists are not changed in background. </p><dl class="section return"><dt>Returns</dt><dd>true if all flush lists were empty. </dd></dl>

</div>
</div>
<a id="a42235e1e34a9f14524c48935848d2686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42235e1e34a9f14524c48935848d2686">&#9670;&nbsp;</a></span>buf_flush_do_batch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_do_batch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>min_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>lsn_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_processed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do flushing batch of a given type. </p>
<p>NOTE: The calling thread is not allowed to own any latches on pages! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>flush type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">min_n</td><td>wished minimum mumber of blocks flushed (it is not guaranteed that the actual number is that big, though) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lsn_limit</td><td>in the case BUF_FLUSH_LIST all blocks whose oldest_modification is smaller than this should be flushed (if their number does not exceed min_n), otherwise ignored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n_processed</td><td>the number of pages which were processed is passed back to caller. Ignored if NULL </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if a batch was queued successfully. </td></tr>
    <tr><td class="paramname">false</td><td>if another batch of same type was already running. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f7e668a2ff50fe0e70ec6514061315a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7e668a2ff50fe0e70ec6514061315a">&#9670;&nbsp;</a></span>buf_flush_free_flush_rbt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_free_flush_rbt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees up the red-black tree. </p>

</div>
</div>
<a id="a4fee1529fdf99802a4d838f15e2e00f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fee1529fdf99802a4d838f15e2e00f4">&#9670;&nbsp;</a></span>buf_flush_init_flush_rbt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_init_flush_rbt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the red-black tree to speed up insertions into the flush_list during recovery process. </p>
<p>Should be called at the start of recovery process before any page has been read/written. </p>

</div>
</div>
<a id="afb0d8b9bbb44ab1ea73374bfba8d6417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0d8b9bbb44ab1ea73374bfba8d6417">&#9670;&nbsp;</a></span>buf_flush_init_for_writing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_init_for_writing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>page_zip_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>newest_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>skip_checksum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>skip_lsn_check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a page for writing to the tablespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>buffer block; NULL if bypassing the buffer pool </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">page</td><td>page frame </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">page_zip_</td><td>compressed page, or NULL if uncompressed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newest_lsn</td><td>newest modification LSN to the page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skip_checksum</td><td>whether to disable the page checksum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">skip_lsn_check</td><td>true to skip check for LSN (in DEBUG) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a528025409ff3ed8503e172b8ae62a6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a528025409ff3ed8503e172b8ae62a6be">&#9670;&nbsp;</a></span>buf_flush_lists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_lists </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>min_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>lsn_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_processed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This utility flushes dirty blocks from the end of the flush list of all buffer pool instances. </p>
<p>NOTE: The calling thread is not allowed to own any latches on pages! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">min_n</td><td>wished minimum mumber of blocks flushed (it is not guaranteed that the actual number is that big, though) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lsn_limit</td><td>in the case BUF_FLUSH_LIST all blocks whose oldest_modification is smaller than this should be flushed (if their number does not exceed min_n), otherwise ignored </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n_processed</td><td>the number of pages which were processed is passed back to caller. Ignored if NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a batch was queued successfully for each buffer pool instance. false if another batch of same type was already running in at least one of the buffer pool instance </dd></dl>

</div>
</div>
<a id="a421b3f1cf5a30db8cb88ae04f868fb6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a421b3f1cf5a30db8cb88ae04f868fb6f">&#9670;&nbsp;</a></span>buf_flush_note_modification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_flush_note_modification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>start_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>end_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFlushObserver.html">FlushObserver</a> *&#160;</td>
          <td class="paramname"><em>observer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function should be called at a mini-transaction commit, if a page was modified in it. </p>
<p>Puts the block to the list of modified blocks, if it not already in it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>block which is modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_lsn</td><td>start lsn of the first mtr in a set of mtr's </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_lsn</td><td>end lsn of the last mtr in the set of mtr's </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">observer</td><td>flush observer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa4f35ed7b257e277bb3c8bdba954bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4f35ed7b257e277bb3c8bdba954bcc">&#9670;&nbsp;</a></span>buf_flush_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_flush_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a flushable page asynchronously from the buffer pool to a file. </p>
<p>NOTE: 1. in simulated aio we must call os_aio_simulated_wake_handler_threads after we have posted a batch of writes! 2. buf_page_get_mutex(bpage) must be held upon entering this function. The LRU list mutex must be held if flush_type == BUF_FLUSH_SINGLE_PAGE. Both mutexes will be released by this function if it returns true. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>buffer control block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush_type</td><td>type of flush </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>true if sync IO request </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if page was flushed </dd></dl>

</div>
</div>
<a id="a6a2cb1355911c2d1581560fc3ea299f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2cb1355911c2d1581560fc3ea299f5">&#9670;&nbsp;</a></span>buf_flush_page_cleaner_disabled_debug_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_page_cleaner_disabled_debug_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structSYS__VAR.html">SYS_VAR</a> *&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>var_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>save</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables page cleaner threads (coordinator and workers). </p>
<p>It's used by: SET GLOBAL innodb_page_cleaner_disabled_debug = 1 (0). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thd</td><td>thread handle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">var</td><td>pointer to system variable </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">var_ptr</td><td>where the formal string goes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">save</td><td>immediate result from check function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53ffa9bb53ae04af71f6b0831832e7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ffa9bb53ae04af71f6b0831832e7a8">&#9670;&nbsp;</a></span>buf_flush_page_cleaner_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_page_cleaner_init </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_page_cleaners</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize page_cleaner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_page_cleaners</td><td>Number of page cleaner threads to create </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc32a17f0dc7a9895adec53754ae98cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc32a17f0dc7a9895adec53754ae98cd">&#9670;&nbsp;</a></span>buf_flush_page_cleaner_is_active()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_page_cleaner_is_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the page_cleaner is in active state. </p>
<p>Checks if the page_cleaner is in active state. </p>

</div>
</div>
<a id="a82378da645bc734469c6c11e24a15399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82378da645bc734469c6c11e24a15399">&#9670;&nbsp;</a></span>buf_flush_page_try()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_page_try </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a flushable page asynchronously from the buffer pool to a file. </p>
<p>NOTE: block and LRU list mutexes must be held upon entering this function, and they will be released by this function after flushing. This is loosely based on buf_flush_batch() and buf_flush_page(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>buffer control block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the page was flushed and the mutex released </dd></dl>

</div>
</div>
<a id="aecec14617af55f34859e552f9df967d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecec14617af55f34859e552f9df967d9">&#9670;&nbsp;</a></span>buf_flush_ready_for_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_ready_for_flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the block is modified and ready for flushing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>buffer control block, must be buf_page_in_file() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush_type</td><td>type of flush </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if can flush immediately </dd></dl>

</div>
</div>
<a id="ab62dc5b248898f799ccc3efdfa91a1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab62dc5b248898f799ccc3efdfa91a1a5">&#9670;&nbsp;</a></span>buf_flush_ready_for_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool buf_flush_ready_for_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns TRUE if the file page block is immediately suitable for replacement, i.e., the transition FILE_PAGE =&gt; NOT_USED allowed. </p>
<p>The caller must hold the LRU list and block mutexes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>buffer control block, must be buf_page_in_file() and in the LRU list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if can replace immediately </dd></dl>

</div>
</div>
<a id="a109aff89cdb96f674786a8b913be0043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a109aff89cdb96f674786a8b913be0043">&#9670;&nbsp;</a></span>buf_flush_recv_note_modification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void buf_flush_recv_note_modification </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>start_lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>end_lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function should be called when recovery has modified a buffer page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>block which is modified </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">start_lsn</td><td>start lsn of the first mtr in a set of mtr's </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_lsn</td><td>end lsn of the last mtr in the set of mtr's </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3be9763cec3cba165c7b9f4897ac382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3be9763cec3cba165c7b9f4897ac382">&#9670;&nbsp;</a></span>buf_flush_relocate_on_flush_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_relocate_on_flush_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>dpage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Relocates a buffer control block on the flush_list. </p>
<p>Note that it is assumed that the contents of bpage has already been copied to dpage. in/out: destination block</p>
<p>Note that it is assumed that the contents of bpage have already been copied to dpage. IMPORTANT: When this function is called bpage and dpage are not exact copies of each other. For example, they both will have different "::state". Also the "::list" pointers in dpage may be stale. We need to use the current list node (bpage) to do the list manipulation because the list pointers could have changed between the time that we copied the contents of bpage to the dpage and the flush list manipulation below. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bpage</td><td>in/out: control block being moved </td></tr>
    <tr><td class="paramname">dpage</td><td>in/out: destination block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73ecfb0cf0b18959486e8f155f60fcaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ecfb0cf0b18959486e8f155f60fcaf">&#9670;&nbsp;</a></span>buf_flush_remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a block from the flush list of modified blocks. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>pointer to the block in question </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5d0b53149ea04d5d4afb4150a6e8f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d0b53149ea04d5d4afb4150a6e8f7f">&#9670;&nbsp;</a></span>buf_flush_request_force()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_request_force </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="log0types_8h.html#aa7401e3081ffb8ee7e8fb182647f475c">lsn_t</a>&#160;</td>
          <td class="paramname"><em>lsn_limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request IO burst and wake page_cleaner up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lsn_limit</td><td>upper limit of LSN to be flushed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if we requested higher lsn than ever requested so far </dd></dl>

</div>
</div>
<a id="a43a7147265a4e12b3bb5b6cea221caf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43a7147265a4e12b3bb5b6cea221caf4">&#9670;&nbsp;</a></span>buf_flush_single_page_from_LRU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_single_page_from_LRU </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function picks up a single page from the tail of the LRU list, flushes it (if it is dirty), removes it from page_hash and LRU list and puts it on the free list. </p>
<p>It is called from user threads when they are unable to find a replaceable page at the tail of the LRU list i.e.: when the background LRU flushing in the page_cleaner thread is not fast enough to keep pace with the workload. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success. </dd></dl>

</div>
</div>
<a id="ae1b8fee83b5a7a0569c8e0e9eb6d596b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b8fee83b5a7a0569c8e0e9eb6d596b">&#9670;&nbsp;</a></span>buf_flush_sync_all_buf_pools()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_sync_all_buf_pools </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronously flush dirty blocks from the end of the flush list of all buffer pool instances. </p>
<p>NOTE: The calling thread is not allowed to own any latches on pages! </p>

</div>
</div>
<a id="a49be0031c6d9844ec4fa2bfe8bb97861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49be0031c6d9844ec4fa2bfe8bb97861">&#9670;&nbsp;</a></span>buf_flush_validate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> buf_flush_validate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validates the flush list. </p>
<dl class="section return"><dt>Returns</dt><dd>true if ok </dd></dl>

</div>
</div>
<a id="a25b6769e4f299f9c14aa375bb9eab878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b6769e4f299f9c14aa375bb9eab878">&#9670;&nbsp;</a></span>buf_flush_wait_batch_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_wait_batch_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>flush_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until a flush batch of the given type ends. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>Buffer pool instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flush_type</td><td>Flush type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43effc2f445e05e01e858611e1b3a473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43effc2f445e05e01e858611e1b3a473">&#9670;&nbsp;</a></span>buf_flush_wait_batch_end_wait_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_wait_batch_end_wait_only </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="buf0types_8h.html#a7b34944f1921a4bf7c1a28abfb86d73c">buf_flush_t</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until a flush batch of the given type ends. </p>
<p>This is called by a thread that only wants to wait for a flush to end but doesn't do any flushing itself. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_pool</td><td>buffer pool instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>BUF_FLUSH_LRU or BUF_FLUSH_LIST </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9009b835c5483b778102082175f1a95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9009b835c5483b778102082175f1a95c">&#9670;&nbsp;</a></span>buf_flush_wait_LRU_batch_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_wait_LRU_batch_end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for any possible LRU flushes that are in progress to end. </p>

</div>
</div>
<a id="a40e3dd9b538ed985dbb702a4963374a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40e3dd9b538ed985dbb702a4963374a9">&#9670;&nbsp;</a></span>buf_flush_write_complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void buf_flush_write_complete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbuf__page__t.html">buf_page_t</a> *&#160;</td>
          <td class="paramname"><em>bpage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the flush system data structures when a write is completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bpage</td><td>pointer to the block in question </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8d1cae1738f050554b98aa0eede40fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d1cae1738f050554b98aa0eede40fe">&#9670;&nbsp;</a></span>buf_pool_get_dirty_pages_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint buf_pool_get_dirty_pages_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__pool__t.html">buf_pool_t</a> *&#160;</td>
          <td class="paramname"><em>buf_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFlushObserver.html">FlushObserver</a> *&#160;</td>
          <td class="paramname"><em>observer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if there are any dirty pages that belong to a space id in the flush list in a particular buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>number of dirty pages present in a single buffer pool in: flush observer to check</dd>
<dd>
number of dirty pages present in a single buffer pool </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf_pool</td><td>in: buffer pool </td></tr>
    <tr><td class="paramname">id</td><td>in: space id to check </td></tr>
    <tr><td class="paramname">observer</td><td>in: flush observer to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe33c34fe5f19231976b9b60753f3599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe33c34fe5f19231976b9b60753f3599">&#9670;&nbsp;</a></span>page_is_uncompressed_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> page_is_uncompressed_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if page type is uncompressed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page</td><td>page frame </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if uncompressed page type. </dd></dl>

</div>
</div>
<a id="a6b0553b7e69d539966d0ff4096b2bf4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0553b7e69d539966d0ff4096b2bf4c">&#9670;&nbsp;</a></span>reset_buf_flush_sync_lsn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reset_buf_flush_sync_lsn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset sync LSN if beyond current log sys LSN. </p>
<p>Currently used when redo logging is disabled. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a89813a5f0a56b1a2baf315553652fa42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89813a5f0a56b1a2baf315553652fa42">&#9670;&nbsp;</a></span>buf_flush_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> buf_flush_event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event to synchronise with the flushing. </p>

</div>
</div>
<a id="a7e0f75b6932976e19431ee9f5f550faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0f75b6932976e19431ee9f5f550faf">&#9670;&nbsp;</a></span>buf_flush_tick_event</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> buf_flush_tick_event</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event to wait for one flushing step. </p>

</div>
</div>
<a id="ade5ded563e72647ca835048b2f4f0c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5ded563e72647ca835048b2f4f0c5b">&#9670;&nbsp;</a></span>innodb_page_cleaner_disabled_debug</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> innodb_page_cleaner_disabled_debug</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value of MySQL global variable used to disable page cleaner. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_9b7ed1f29269ffabdc4c5f5522a0db25.html">include</a></li><li class="navelem"><a class="el" href="buf0flu_8h.html">buf0flu.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
