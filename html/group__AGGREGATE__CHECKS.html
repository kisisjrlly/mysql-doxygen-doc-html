<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Aggregate checks of ONLY_FULL_GROUP_BY</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__AGGREGATE__CHECKS.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Aggregate checks of ONLY_FULL_GROUP_BY</div>  </div>
</div><!--header-->
<div class="contents">

<p>Checks for some semantic constraints on queries using GROUP BY, or aggregate functions, or DISTINCT (ONLY_FULL_GROUP_BY).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmem__root__deque.html">mem_root_deque&lt; Element_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A (partial) implementation of std::deque allocating its blocks on a MEM_ROOT.  <a href="classmem__root__deque.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDistinct__check.html">Distinct_check</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for queries which have DISTINCT.  <a href="classDistinct__check.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGroup__check.html">Group_check</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks for queries which have GROUP BY or aggregate functions.  <a href="classGroup__check.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga83e75b415b78e10ade375ad320ea446c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga83e75b415b78e10ade375ad320ea446c">Distinct_check::check_query</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga83e75b415b78e10ade375ad320ea446c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rejects the query if it has a combination of DISTINCT and ORDER BY which could lead to randomly ordered results.  <a href="#ga83e75b415b78e10ade375ad320ea446c">More...</a><br /></td></tr>
<tr class="separator:ga83e75b415b78e10ade375ad320ea446c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85f98a122e6f9accf528534acb5db686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga85f98a122e6f9accf528534acb5db686">Group_check::check_query</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga85f98a122e6f9accf528534acb5db686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rejects the query if it does aggregation or grouping, and expressions in its SELECT list, ORDER BY clause, HAVING condition, or window functions may vary inside a group (are not "group-invariant").  <a href="#ga85f98a122e6f9accf528534acb5db686">More...</a><br /></td></tr>
<tr class="separator:ga85f98a122e6f9accf528534acb5db686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d9d680fb5c912394aa10ffdb4b28e2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga8d9d680fb5c912394aa10ffdb4b28e2b">Group_check::check_expression</a> (<a class="el" href="classTHD.html">THD</a> *thd, <a class="el" href="classItem.html">Item</a> *expr, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> in_select_list)</td></tr>
<tr class="memdesc:ga8d9d680fb5c912394aa10ffdb4b28e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validates one expression (this forms one step of check_query()).  <a href="#ga8d9d680fb5c912394aa10ffdb4b28e2b">More...</a><br /></td></tr>
<tr class="separator:ga8d9d680fb5c912394aa10ffdb4b28e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga710fce06294788d8e9185095b2e9485f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga710fce06294788d8e9185095b2e9485f">Group_check::is_fd_on_source</a> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="memdesc:ga710fce06294788d8e9185095b2e9485f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells if 'item' is functionally dependent ("FD") on source columns.  <a href="#ga710fce06294788d8e9185095b2e9485f">More...</a><br /></td></tr>
<tr class="separator:ga710fce06294788d8e9185095b2e9485f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07fce05353d6cd618ac382a6372da174"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga07fce05353d6cd618ac382a6372da174">Group_check::add_to_fd</a> (<a class="el" href="classItem.html">Item</a> *item, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> <a class="el" href="classGroup__check.html#a8dea46f7e265b509fe5f52e1592ba700">local_column</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> add_to_mat_table=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>)</td></tr>
<tr class="separator:ga07fce05353d6cd618ac382a6372da174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ae18ec75ebbaa4268a231f4fec7017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#gae3ae18ec75ebbaa4268a231f4fec7017">Group_check::find_group_in_fd</a> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="memdesc:gae3ae18ec75ebbaa4268a231f4fec7017"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function must be called every time we discover an item which is FD on source columns, or add a bit to whole_tables_fd; it maintains group_in_fd.  <a href="#gae3ae18ec75ebbaa4268a231f4fec7017">More...</a><br /></td></tr>
<tr class="separator:gae3ae18ec75ebbaa4268a231f4fec7017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35a0eceb6320238044b128e1fcd6f481"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga35a0eceb6320238044b128e1fcd6f481">Group_check::select_expression</a> (<a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> idx)</td></tr>
<tr class="separator:ga35a0eceb6320238044b128e1fcd6f481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7af970a2defc3ba21ad2682b608c7046"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga7af970a2defc3ba21ad2682b608c7046">Group_check::add_to_source_of_mat_table</a> (<a class="el" href="classItem__field.html">Item_field</a> *item_field, <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *tl)</td></tr>
<tr class="memdesc:ga7af970a2defc3ba21ad2682b608c7046"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we just added a column of a materialized table to 'fd', we record this fact in a new Group_check (mat_gc) for the query expression underlying that table.  <a href="#ga7af970a2defc3ba21ad2682b608c7046">More...</a><br /></td></tr>
<tr class="separator:ga7af970a2defc3ba21ad2682b608c7046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4106041d478efe724a53b239ba3b693"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#gaa4106041d478efe724a53b239ba3b693">Group_check::is_in_fd</a> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="memdesc:gaa4106041d478efe724a53b239ba3b693"><td class="mdescLeft">&#160;</td><td class="mdescRight">is_in_fd() is low-level compared to is_fd_on_source().  <a href="#gaa4106041d478efe724a53b239ba3b693">More...</a><br /></td></tr>
<tr class="separator:gaa4106041d478efe724a53b239ba3b693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb78998a8a3e195bc60c2c80f589343d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#gacb78998a8a3e195bc60c2c80f589343d">Group_check::is_in_fd_of_underlying</a> (<a class="el" href="classItem__ident.html">Item_ident</a> *item)</td></tr>
<tr class="memdesc:gacb78998a8a3e195bc60c2c80f589343d"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if we can derive a FD from a column which has an underlying expression.  <a href="#gacb78998a8a3e195bc60c2c80f589343d">More...</a><br /></td></tr>
<tr class="separator:gacb78998a8a3e195bc60c2c80f589343d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8104cfa83d31426803965c2dd9abe4aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classItem.html">Item</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga8104cfa83d31426803965c2dd9abe4aa">Group_check::get_fd_equal</a> (<a class="el" href="classItem.html">Item</a> *item)</td></tr>
<tr class="separator:ga8104cfa83d31426803965c2dd9abe4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1372eef975d492070ea5e7df1a06259"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#gad1372eef975d492070ea5e7df1a06259">Group_check::analyze_conjunct</a> (<a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classItem.html">Item</a> *conjunct, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> weak_tables, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> weak_side_upwards)</td></tr>
<tr class="memdesc:gad1372eef975d492070ea5e7df1a06259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for equality-based functional dependences in an AND-ed part of a condition (a conjunct).  <a href="#gad1372eef975d492070ea5e7df1a06259">More...</a><br /></td></tr>
<tr class="separator:gad1372eef975d492070ea5e7df1a06259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47e06193dc3d4e1018031e9e82c83470"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga47e06193dc3d4e1018031e9e82c83470">Group_check::analyze_scalar_eq</a> (<a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="classItem.html">Item</a> *left_item, <a class="el" href="classItem.html">Item</a> *right_item, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> weak_tables, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> weak_side_upwards)</td></tr>
<tr class="memdesc:ga47e06193dc3d4e1018031e9e82c83470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function.  <a href="#ga47e06193dc3d4e1018031e9e82c83470">More...</a><br /></td></tr>
<tr class="separator:ga47e06193dc3d4e1018031e9e82c83470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bf8ae0675a0199b27aabeb1a09f182a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga3bf8ae0675a0199b27aabeb1a09f182a">Group_check::find_fd_in_cond</a> (<a class="el" href="classItem.html">Item</a> *cond, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> weak_tables, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> weak_side_upwards)</td></tr>
<tr class="memdesc:ga3bf8ae0675a0199b27aabeb1a09f182a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for equality-based functional dependencies in a condition.  <a href="#ga3bf8ae0675a0199b27aabeb1a09f182a">More...</a><br /></td></tr>
<tr class="separator:ga3bf8ae0675a0199b27aabeb1a09f182a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99c585cb512d0af4bd097f352de8c350"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga99c585cb512d0af4bd097f352de8c350">Group_check::find_fd_in_joined_table</a> (<a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *join_list)</td></tr>
<tr class="memdesc:ga99c585cb512d0af4bd097f352de8c350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for equality-based functional dependencies in the condition of a join nest, and recursively in all contained join nests.  <a href="#ga99c585cb512d0af4bd097f352de8c350">More...</a><br /></td></tr>
<tr class="separator:ga99c585cb512d0af4bd097f352de8c350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97e11f17193e6ad1adff12b0ff2c3af6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga97e11f17193e6ad1adff12b0ff2c3af6">Group_check::to_opt_trace</a> (<a class="el" href="classTHD.html">THD</a> *thd)</td></tr>
<tr class="memdesc:ga97e11f17193e6ad1adff12b0ff2c3af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes "check information" to the optimizer trace.  <a href="#ga97e11f17193e6ad1adff12b0ff2c3af6">More...</a><br /></td></tr>
<tr class="separator:ga97e11f17193e6ad1adff12b0ff2c3af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a926fd146d27f4b8d06de95a2e0c742"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga5a926fd146d27f4b8d06de95a2e0c742">Group_check::to_opt_trace2</a> (<a class="el" href="classOpt__trace__context.html">Opt_trace_context</a> *ctx, <a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> *parent)</td></tr>
<tr class="memdesc:ga5a926fd146d27f4b8d06de95a2e0c742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function for to_opt_trace(), as we need recursion in children Group_checks.  <a href="#ga5a926fd146d27f4b8d06de95a2e0c742">More...</a><br /></td></tr>
<tr class="separator:ga5a926fd146d27f4b8d06de95a2e0c742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d9e51c550e4d81b6c100633b37cc3f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga2d9e51c550e4d81b6c100633b37cc3f3">Group_check::do_ident_check</a> (<a class="el" href="classItem__ident.html">Item_ident</a> *i, <a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a> tm, enum <a class="el" href="classGroup__check.html#a56c8b8e7fa8710acec07b40674555063">enum_ident_check</a> type)</td></tr>
<tr class="memdesc:ga2d9e51c550e4d81b6c100633b37cc3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does one low-level check on one Item_ident.  <a href="#ga2d9e51c550e4d81b6c100633b37cc3f3">More...</a><br /></td></tr>
<tr class="separator:ga2d9e51c550e4d81b6c100633b37cc3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga760e082ce4eff6cdf0a68f345ae6fbc2"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="sql__const_8h.html#ab2df5e15d7fb7ccd43e6af9527cb81cf">enum_walk</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__AGGREGATE__CHECKS.html#ga760e082ce4eff6cdf0a68f345ae6fbc2">walk_options</a></td></tr>
<tr class="memdesc:ga760e082ce4eff6cdf0a68f345ae6fbc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">We need to search for items inside subqueries, in case subqueries contain outer references to tables of a query block having DISTINCT or GROUP BY.  <a href="#ga760e082ce4eff6cdf0a68f345ae6fbc2">More...</a><br /></td></tr>
<tr class="separator:ga760e082ce4eff6cdf0a68f345ae6fbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Checks for some semantic constraints on queries using GROUP BY, or aggregate functions, or DISTINCT (ONLY_FULL_GROUP_BY). </p>
<p>We call "aggregation" the operation of taking a group of rows and replacing it with a single row. There are three types of aggregation: DISTINCT, implicit grouping, explicit grouping.</p>
<p>This text describes MySQL's checks (why certain queries are rejected) and the rationale behind them.</p>
<p>References:</p><ul>
<li>WL#2489 "better only_full_group_by".</li>
<li>if you have access to the SQL standard, we recommend the following parts of "SQL2011 Foundation": query expression Syntax rule 28; column reference Syntax rule 7 and Conformance rule 2; 4.19 functional dependencies.</li>
</ul>
<h1><a class="anchor" id="DISTINCT"></a>
DISTINCT</h1>
<p>DISTINCT: all identical rows in the result of SELECT are "aggregated" to one single row - duplicates are eliminated. If the result of the SELECT without DISTINCT is </p><pre class="fragment">1 2
3 4
1 2
</pre><p> then the result with DISTINCT is </p><pre class="fragment">1 2
3 4
</pre><p> Here is a problematic query. Assume we have a table T which contains three columns C1,C2,C3 and has the following rows: </p><pre class="fragment">C1 C2 C3
1  2  A
3  4  B
1  2  C
</pre><p> and we do "SELECT DISTINCT C1, C2 FROM T ORDER BY C3". Because we want the result to be ordered, we have to first eliminate duplicates then order the result. When we eliminate duplicates, should we keep the first or the third row? This arbitrary choice will influence the retained value of C3, which will influence ordering. In the end, we have arbitrary ordering, which is problematic. To prevent this, if, in a query block 'sl', an ORDER BY expression is not the same expression as one in the SELECT list of 'sl' and contains a column which:</p><ul>
<li>is of a table whose qualifying query block is 'sl'</li>
<li>and is not in the SELECT list of 'sl'</li>
</ul>
<p>then 'sl' should not have DISTINCT. This rule makes the query above invalid. Class Check_distinct implements this rule.</p>
<p>Class Check_distinct implements a second rule, specific of set functions in ORDER BY (a non-standard feature). Consider these queries labelled (1), (2), (3), with DISTINCT and a set function in ORDER BY: </p><pre class="fragment">SELECT DISTINCT MIN(C2) FROM T GROUP BY C1 ORDER BY MIN(C3);
SELECT DISTINCT MIN(C2) FROM T GROUP BY C1 ORDER BY MIN(C2);
SELECT DISTINCT C1, MIN(C2) FROM T GROUP BY C1 ORDER BY MIN(C3);
</pre><p> (1) is a random-order query, (2) and (3) are not. MySQL has traditionally been permissive, we want to allow (2) and (3).</p>
<p>So the second rule is that Check_distinct rejects a query if it has DISTINCT and a set function in ORDER BY which is not the same expression as one in the SELECT list. This rejects (1) and allows (2). It would reject (3); luckily, before Check_distinct checks, DISTINCT is removed (it is redundant with GROUP BY) and thus the query is not processed by Check_distinct; the second rule is thus by-passed and (3) is correctly accepted.</p>
<p>The implementation of Check_distinct works like this: if the query has DISTINCT, examine each element of the ORDER BY list: if the element is not the same expression as one in the SELECT list, then examine parts of the element (using Item::walk()), to spot offending set functions or columns.</p>
<h1><a class="anchor" id="IMPLICIT_GROUPING"></a>
Implicit grouping</h1>
<p>A query with set functions without GROUP BY can be seen as having GROUP BY() i.e. the set of grouping expressions is empty, all rows are part of a single group and are replaced with a single row. So it is just a sub-case of the next section.</p>
<h1><a class="anchor" id="EXPLICIT_GROUPING"></a>
Explicit grouping (GROUP BY)</h1>
<p>MySQL is more permissive than the standard, it allows to group by any expression; it does not require that every element of the GROUP BY clause should be a column of one table of the FROM clause.</p>
<p>Here is a problematic query, using a table T with columns C1, C2, C3: </p><pre class="fragment">C1 C2 C3
1  2  A
3  4  B
1  2  C

SELECT C1, C3 FROM T GROUP BY C1;
</pre><p> we first form groups, in each group the value of C1 must be the same for all rows. Consider the group made of the first and third row. We have to produce one row out of it, and this row must have a value for C3 because C3 is in the SELECT list. Among those two rows, which value of C3 should we choose? This is arbitrary, and will give a random result.</p>
<p>To prevent this, in a query with GROUP BY or aggregates (known as "a grouped
query"), any column referenced by an expression in the SELECT list or HAVING condition and belonging to one table of the FROM clause, should be one of the group columns (enforced by only_full_group_by in MySQL 5.6 and older) or, if functional dependencies are supported (as in MySQL 5.7), should be functionally dependent on the group columns. In the table T above, C3 is obviously not functionally dependent on {C1,C2}: the values of C1 and C2 for a row do not uniquely determine the value of C3. In other words, if two rows have the same value in C1 and the same value in C2 they do not necessarily have the same value in C3. So this rule correctly rejects the query above.</p>
<p>Note that NULL is treated as one value: two NULLs are considered equal.</p>
<p>In WL#2489, we have implemented the optional standard feature T301 "functional dependencies" almost entirely.</p>
<p>Here are the functional dependencies which we recognize.</p>
<h2><a class="anchor" id="KEYFD"></a>
Key-based, in a base table</h2>
<p>A key in this text is a unique constraint made of only non-NULLable columns. For example, a primary key. Considering a base table T, if two rows have the same values of all columns of a key of T they are actually one single row, so: { all columns of key} -&gt; { T.* } (notation: what is on the right of the arrow is functionally dependent on what is on the left).</p>
<h2><a class="anchor" id="GCOLFD"></a>
Generated-column-based, in a base table</h2>
<p>Considering a base table T, a generated column is functionally dependent on the set of columns it references (the so-called parametric columns). Note that the SQL standard doesn't allow a parametric column to be a generated column, but MySQL does.</p>
<h2><a class="anchor" id="INNEREQ"></a>
Equality-based, in the result of an inner join</h2>
<p>Considering two tables T1 and T2, a condition C, and the result R of an inner join T1 JOIN T2 ON C. Note that T1/T2 are not necessarily base tables. For example, they can also be views, or derived tables, or the results of some joins; in the rest of text, we use the vague term "table" for those various objects.</p>
<p>Note that C may only refer to columns of T1 or T2 (outer references are forbidden by MySQL in join conditions).</p>
<p>Assuming that C is a conjunction (i.e. is made of one or more conditions, "conjuncts", chained together with AND):</p><ul>
<li>If one conjunct is of the form T1.A=constant, then {} -&gt; {A} holds in R (the value of A is "the constant" in all rows of R).</li>
<li>If one conjunct is of the form T1.A=T2.B, then {T1.A} -&gt; {T2.B} (and vice versa) holds in R (the value of T2.B is that of T1.A in all rows of R).</li>
</ul>
<h2><a class="anchor" id="OUTEREQ"></a>
Equality-based, in the result of an outer join</h2>
<p>Considering the result R of TS LEFT JOIN TW ON C. Assuming that C is a conjunction. TS is said to be the strong table, TW is said to be the weak table (the one which might be NULL-complemented in the result of this join). To make this really clear, note that, if we have "t1 left join (t2 left join t3 on C) on D":</p><ul>
<li>in the t2-t3 join, t2 is strong and t3 is weak.</li>
<li>in the t1-(t2-t3) join, t1 is strong, t2 is weak, t3 is weak.</li>
</ul>
<p>If C is deterministic and one conjunct is of the form TW.A=constant or TW.A=TS.B, then DJS -&gt; {TW.A} holds in R, where DJS is the set of all columns of TS referenced by C. Proof: consider in R two rows r1 and r2 which have the same values of DJS columns. Consider r1. There are two possibilities when r1 was built from a row of TS:</p><ul>
<li>no row in TW matched the row of TS (for no row of TW has C been true): so, r1 is NULL-complemented for the columns of TW. Given that r2 has the same values of DJS columns as r1, and given that C is deterministic, it is sure that no row in TW matched when r2 was built. So r2 is also NULL-complemented for the columns of TW. So r1 and r2 have the same value of TW.A (NULL).</li>
<li>At least one row in TW matched: so, r1 contains real values from TW (not NULL-complemented), matching C, and thus TW.A in r1 is equal to the constant or to TS.B. Following the same reasoning as above, it is sure that it is also the case for r2.</li>
<li>In conclusion, we can see that r1 and r2 always have the same value of TW.A.</li>
</ul>
<p>If one conjunct is of the form TW.A=TW.B then {TW.A} -&gt; {TW.B} holds in R Proof: consider r1 and r2 two rows in R having the same value of TW.A. Two cases are possible:</p><ul>
<li>this value is NULL. Then both rows are NULL-complemented (if not, the value of TW.A in TW would be NULL, which cannot match in an equality, so C is not true, which is absurd). Thus, in r1 and r2 TW.B is NULL.</li>
<li>This value is not NULL. Then both rows are not NULL-complemented, C matched for both, so TW.B in r1/r2 is equal to TW.A in r1/r2.</li>
<li>In conclusion, r1 and r2 have the same value of TW.B.</li>
</ul>
<p>If any conjunct references column T1.A and is not true if T1.A is NULL (e.g. conjunct is T1.A &gt; 3), and T1 is part of TW, we can replace T1 with (SELECT * FROM T1 WHERE T1.A IS NOT NULL) AS T1. We do not do such query rewriting, but a consequence is that we can and do treat T1.A as "known not nullable in T1". Proof: if we do this replacement, it means we remove from T1 some rows where T1.A is NULL. For the sake of the proof, let's broaden this to "we remove from
and/or add to T1 rows where T1.A is NULL". By this operation,</p><ul>
<li>the result of T2 JOIN T1 ON C is affected in the same manner (i.e. it's like if we remove from and/or add rows to the join's result, rows where T1.A is NULL).</li>
<li>the same is true for the result of T1 LEFT JOIN T2 ON C,</li>
<li>regarding the result of T2 LEFT JOIN T1 ON C, consider a row r2 from T2:<ul>
<li>if r2 had a match with a row of T1 where T1.A is not NULL, this match is preserved after replacement of T1</li>
<li>due to removed rows, matches with rows of T1 where T1.A is NULL may be lost, and so NULL-complemented rows may appear</li>
<li>due to added rows, matches with rows of T1 where T1.A is NULL may appear</li>
<li>so in the result of the left join, it's like if we remove from and/or add rows which all have T1.A is NULL. So, the net effect in all situations, on the join nest simply containing T1, is that "we remove from and/or add to the nest's result rows where T1.A is
NULL". By induction we can go up the nest tree, for every nest it's like if we remove from and/or add to the join nest's result rows where T1.A is NULL. Going up, finally we come to the nest TS LEFT JOIN TW ON C where our NULL-rejecting conjunct is. If T1 belonged to TS, we could not say anything. But we have assumed T1 belongs to TW: then the C condition eliminates added rows, and would have eliminated removed rows anyway. Thus the result of TS LEFT JOIN TW ON C is unchanged by our operation on T1. We can thus safely treat T1.A as not nullable <em>in_T1</em>. Thus, if T1.A is part of a unique constraint, we may treat this constraint as a primary key of T1 (<dl class="section see"><dt>See also</dt><dd>WHEREEQ for an example).</dd></dl>
</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="WHEREEQ"></a>
Equality-based, in the result of a WHERE clause</h2>
<p>Same rule as the result of an inner join. Additionally, the rule is extended to T1.A=outer_reference, because an outer reference is a constant during one execution of this query.</p>
<p>Moreoever, if any conjunct references column T1.A and is not true if T1.A is NULL (e.g. conjunct is T1.A &gt; 3), we can treat T1.A as not nullable in T1. Proof: same as in previous section OUTEREQ. We can then derive FD information from a unique index on a nullable column; consider: create table t1(a int null, b int null, unique(a)); While select a,b from t1 group by a; is invalid (because two null values of 'a' go in same group), select a,b from t1 where 'a' is not null group by a; is valid: 'a' can be treated as non-nullable in t1, so the unique index is like "unique not null", so 'a' determines 'b'.</p>
<p>Below we examine how functional dependencies in a table propagate to its containing join nest.</p>
<h2><a class="anchor" id="PROPAGOUTER"></a>
Considering the result R of TS LEFT JOIN TW ON C.</h2>
<p>All functional dependencies in TS are also functional dependencies in R. Proof: trivial. The same is not necessarily true for TW. Let's define a "NULL-friendly functional dependency" (NFFD) as a functional dependency between two sets A and B, which has two properties:</p><ul>
<li>A is not empty</li>
<li>if, in a row, all values of A are NULL, then all values of B are NULL.</li>
</ul>
<p>All NFFDs in TW are also NFFDs in R. Proof: consider an NFFD A -&gt; B in TW, and r1 and r2 two rows in R having the same values of A columns. Two cases are possible:</p><ul>
<li>In r1 and r2, at least one value of A is not NULL. Then r1 is not NULL-complemented. Its values for A and B come from TW. By application of the functional dependency in TW, because values in A are equal in TW, values in B are equal in TW and thus in r1/r2.</li>
<li>In r1 and r2, all values of A are NULL. Two cases are possible: i) r1 is not NULL-complemented. Its values for A and B come from TW. In the row of TW values of A are all NULL. Because the functional dependency in NULL-friendly, all values of B are NULL in the row of TW and thus in r1. ii) r1 is NULL-complemented. Then all values of B in r1 are NULL. iii) In conclusion, all values of B in r1 are NULL. The same reasoning applies to r2. So, values of B are identical (NULL) in r1 and r2.</li>
<li>In conclusion, values of B are identical in r1/r2, we have proved that this is a functional dependency in R, and a NULL-friendly one.</li>
</ul>
<p>The concept of an NFFD is Guilhem's invention. It was felt it was necessary, to have easy propagation of FDs from TW to R. It was preferred to the alternative, simpler rule which says that a functional dependency A-&gt; B in TW is also a functional dependency in R if A contains a non-nullable column. There are two points to note:</p><ul>
<li>the functional dependency of the simpler rule is an NFFD, so our rule is not more restrictive than the simpler one</li>
<li>this simpler rule prevents free propagation of functional dependencies through join nests, which complicates implementation and leads to rejecting queries which could be accepted. An example follows: <pre class="fragment">SELECT T3.A
FROM T1 LEFT JOIN (T2 LEFT JOIN T3 ON  TRUE) ON  TRUE
GROUP BY T3.PK;
</pre> This is what the simpler rule says for this query: In T3, T3.PK-&gt;T3.A holds. Let R1 be the result of "(T2 LEFT JOIN T3 ON TRUE)", in R1 T3.PK-&gt;T3.A holds, by application of: there is a functional dependency in the weak side T3, and T3.PK is not nullable in T3. Let R2 be the result of "T1 LEFT JOIN (T2 LEFT JOIN T3 ON TRUE) ON TRUE", in R2 T3.PK-&gt;T3.A doesn't hold anymore, because: it's a dependency in the weak side (weak side is R1 here), and T3.PK is nullable <em>when seen as a column of R1</em> (in R1 T3.PK can be NULL, if the row of T3 is actually a NULL-complemented one).</li>
</ul>
<h2><a class="anchor" id="PROPAGINNER"></a>
Considering the result R of T1 JOIN T2 ON C.</h2>
<p>All [NULL-friendly] functional dependencies in T1 are also [NULL-friendly] functional dependencies in R. the same is true for T2. Proof: trivial.</p>
<h2><a class="anchor" id="PROPAGSUMMARY"></a>
Summary rules for propagating FDs</h2>
<p>All NULL-friendly functional dependencies propagate freely through join nests all the way up to the result of the WHERE clause. The same is true for ordinary functional dependencies except if there are weak tables along the propagation path between the table where the dependency holds and the result of the WHERE clause; in other words, except if the table where the dependency holds belongs to some embedding join nest which is on the weak side of an outer join.</p>
<h2><a class="anchor" id="NFFDS"></a>
Which functional dependencies are NULL-friendly</h2>
<p>A key-based functional dependency A -&gt; B in the base table is NULL-friendly, because, by definition, there can never be a NULL value in any column of A.</p>
<p>A functional dependency A -&gt; B in a base table, between parametric columns A and a generated column B, is not NULL-friendly; for more details, see <a class="el" href="group__AGGREGATE__CHECKS.html#FDVIEW">Functional dependencies in a view or a derived table</a> .</p>
<p>A functional dependency A-&gt;B in the result of T1 JOIN T2 ON C, if based on equality of two columns, is NULL-friendly. Indeed, A is not empty and if there was some NULL in A, it would not match the equality in C and thus it would not exist in the result, absurd. If the equality is rather column=constant, A is empty, the dependency is not NULL-friendly. However, in our implementation, function <code>simplify_joins()</code> moves inner-join conditions to the embedding outer-join nest's join condition, or to the WHERE clause. Because our analysis of functional dependencies happens after simplify_joins(), when we analyze T1 JOIN T2 it is guaranteed to have no condition, and this paragraph is irrelevant.</p>
<p>A functional dependency in the result of TS LEFT JOIN TW ON C, if based on equality of two columns, is NULL-friendly. Proof: let's consider, in turn, the two types of equality-based functional dependencies which exist in this result R. Let r1 be a row of R.</p><ul>
<li>If C is deterministic and one conjunct is of the form TW.A=constant or TW.A=TS.B, then DJS -&gt; {TW.A} holds in R, where DJS is the set of all columns of TS referenced by C. For NULL-friendliness, we need DJS to not be empty. Thus, we exclude the form TW.A=constant and consider only TW.A=TS.B. We suppose that in r1 DJS contains all NULLs. Conjunct is TW.A=TS.B then this equality is not true, so r1 is NULL-complemented: TW.A is NULL in r1.</li>
<li>If one conjunct is of the form TW.A=TW.B then {TW.A} -&gt; {TW.B} holds in R. If in r1 TW.A is NULL, again the equality in C is not true, and TW.B is NULL in R1.</li>
<li>In conclusion, this is NULL-friendly.</li>
</ul>
<p>A functional dependency in the result of a WHERE clause, if based on equality of two columns, is NULL-friendly. If based on T1.A=constant, it is not, as it has an empty set of source columns.</p>
<p>Summary: all functional dependencies which we have seen so far are NULL-friendly, except those inferred from TW.A=constant in an outer join condition or in a WHERE clause, and those about generated columns.</p>
<p>Thus, in the query with T1-T2-T3 previously seen, T3.PK-&gt;T3.A is NULL-friendly and propagates, query is accepted.</p>
<p>In our implementation, we take special care of TW.A=constant in an outer join condition: we infer a functional dependency DJS-&gt;TW.A from such equality only if one of these requirements are met:</p><ul>
<li>the join nest "TS LEFT JOIN TW ON TW.A=constant [AND...]" is not on the weak side of any embedding join nest - in that case, propagation will not meet any weak tables so we do not need the dependency to be NULL-friendly, it will propagate anyway.</li>
<li>DJS contains at least one column from a strong-side table which, if NULL, makes the join condition not evaluate to TRUE - in that case, DJS-&gt;TW.A is NULL-friendly.</li>
</ul>
<p>Either of these two conditions is satisfied in most practical cases. For example, it's very common to have an equality between a strong-side column and a weak-side column as a conjunct in the outer join condition (like, "ON
strong.pk = weak.foreign_key AND ..." or "ON strong.foreign_key = weak.pk AND
..."); this satisfies the second condition. It's also common to have outer joins only left-deep ("SELECT ... T1 LEFT JOIN T2 ON ... LEFT JOIN T3 ON ..." is left-deep); this satisfies the first condition. Note that the dependency found from TW.A=TS.B in an outer join condition always satisfies the second condition.</p>
<p>T1.A=constant in a WHERE clause is exterior to any join nest so does not need to propagate, so does not need to be NULL-friendly.</p>
<h2><a class="anchor" id="FDVIEW"></a>
Functional dependencies in a view or a derived table</h2>
<p>In the rest of this text, we will use the term "view" for "view or derived
table". A view can be merged or materialized, in MySQL. Consider a view V defined by a query expression. If the query expression contains UNION or ROLLUP (which is theoretically based on UNION) there are no functional dependencies in this view. So let's assume that the query expression is a query specification (let's note it VS): </p><pre class="fragment">CREATE VIEW V AS SELECT [DISTINCT] VE1 AS C1, VE2 AS C2, ... FROM ... WHERE ...
[GROUP BY ...] [HAVING ...] [ORDER BY ...]
</pre><p>If {VE1, VE2, VE3} are columns of tables of the FROM clause, and {VE1, VE2} -&gt; {VE3} has been deduced from rules in the previous sections [and is NULL-friendly], then {C1, C2} -&gt; { C3 } holds in the view [and is NULL-friendly].</p>
<p>If {VE1, VE2} are columns of tables of the FROM clause, and VE3 is a deterministic expression depending only on VE1 and VE2, then {C1, C2} -&gt; { C3 } in the view. It is not always NULL-friendly, for example: VE3 could be COALESCE(VE1,VE2,3): if VE1 (C1) and VE2 (C2) are NULL, VE3 (C3) is 3: not NULL. Another example: VE3 could be a literal; {}-&gt;{C3}, the left set is empty. The same examples apply to a generated column in a base table - it is like a merged view's expression. For example, in a base table T which has a generated column C3 AS COALESCE(C1,C2,3): {C1, C2} -&gt; { C3 } holds in T but is not NULL-friendly.</p>
<p>If VS is a grouped query (which, in MySQL, implies that the view is materialized), then in the result of the grouping there is a functional dependency from the set of all group expressions to the set of all selected expressions (otherwise, this query expression would not have passed its own only_full_group_by validation - in the implementation we validate each query expression separately). Thus, if all group expressions of VS are in the select list of VS, for example they are VE1 and VE2, then {C1, C2} -&gt; {V.*}. It is not NULL-friendly, for example: VE3 is COUNT(1): if the result of the WHERE clause contains a row with group expressions VE1 and VE2 equal to NULL, VE3 is not NULL.</p>
<p>It's possible to infer functional dependencies from equality conditions in HAVING, but we have not implemented it yet.</p>
<p>Because some functional dependencies above are not NULL-friendly, they exist in the view, but may not freely propagate in the result of join nests containing the view. This includes examples just given in paragraphs above, and the case of T1.A=constant in the WHERE clause of VS.</p>
<p>Thus, when we know of a functional dependency A -&gt; B in the query expression of a view, we deduce from it a functional dependency in the view only if:</p><ul>
<li>this view is not on the weak side of any embedding join nest (so NULL-friendliness is not required for propagation).</li>
<li>or A contains at least one non-nullable expression, which makes A -&gt; B NULL-friendly.</li>
</ul>
<p>The above is fine for materialized views. For merged views, we cannot study the query expression of the view, it has been merged (and scattered), so we use a different rule:</p><ul>
<li>a merged view is similar to a join nest inserted in the parent query, so for dependencies based on keys or join conditions, we simply follow propagation rules of the non-view sections.</li>
<li>For expression-based dependencies (VE3 depends on VE1 and VE2, VE3 belonging to the view SELECT list), which may not be NULL-friendly, we require<ul>
<li>the same non-weak-side criterion as above</li>
<li>or that the left set of the dependency be non-empty and that if VE1 and VE2 are NULL then VE3 must be NULL, which makes the dependency NULL-friendly.</li>
</ul>
</li>
<li>The same solution is used for generated columns in a base table.</li>
</ul>
<h1><a class="anchor" id="USED_TABLES"></a>
Implementation note: used_tables_for_level() vs</h1>
<p>used_tables()</p>
<ul>
<li>When we are looking for items to validate, we must enter scalar/row subqueries; if we find an item of our SELECT_LEX inside such subquery, for example an Item_field with depended_from equal to our SELECT_LEX, we must use used_tables_for_level(). Example: when validating t1.a in select (select t1.a from t1 as t2 limit 1) from t1 group by t1.pk; we need t1.a's map in the grouped query; used_tables() would return OUTER_REF_TABLE_BIT.</li>
<li>When we are searching for FDs in PKs, or join conditions, or the GROUP BY clause, we do not enter scalar/row subqueries, so we use used_tables(). Example: select ... from t1 where t1.a=(subq) from t1 group by ... the subq is not used to discover FDs in the grouped query. Or: select (select t2.a from t1 as t2 where t2.a=t1.a group by t2.b) from t1 when validating the subq, t1.a is an outer reference, kind of a constant, so tells us that t2.a is FD on {} ; using used_tables_for_level() on t1.a would be nonsense - we are validating the subquery. </li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga07fce05353d6cd618ac382a6372da174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07fce05353d6cd618ac382a6372da174">&#9670;&nbsp;</a></span>add_to_fd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Group_check::add_to_fd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>local_column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>add_to_mat_table</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7af970a2defc3ba21ad2682b608c7046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7af970a2defc3ba21ad2682b608c7046">&#9670;&nbsp;</a></span>add_to_source_of_mat_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Group_check::add_to_source_of_mat_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__field.html">Item_field</a> *&#160;</td>
          <td class="paramname"><em>item_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&#160;</td>
          <td class="paramname"><em>tl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we just added a column of a materialized table to 'fd', we record this fact in a new Group_check (mat_gc) for the query expression underlying that table. </p>
<p>This can later help us derive new functional dependencies in our Group_check. For example: select d.a, d.b from (select t.a*2 as a, t.a as b from t) group by d.b; When we add d.b to 'fd', in this function we create mat_gc, see that d.b is built from a column of t (t.b), we can say that "t.b is determined", so we add t.b to mat_gc.fd. Later, when we wonder if d.a is functionally dependent on d.b, we process d.a in is_in_fd_of_underlying(): we analyze 2*t.a in the context of mat_gc: 2*t.a is FD on t.a, we conclude that d.a is indeed FD on d.b.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item_field</td><td>column of 'tl', just added to 'fd' </td></tr>
    <tr><td class="paramname">tl</td><td>mat table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1372eef975d492070ea5e7df1a06259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1372eef975d492070ea5e7df1a06259">&#9670;&nbsp;</a></span>analyze_conjunct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Group_check::analyze_conjunct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>conjunct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>weak_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>weak_side_upwards</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for equality-based functional dependences in an AND-ed part of a condition (a conjunct). </p>
<p>Search for columns which are known-not-nullable due to the conjunct.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>complete condition </td></tr>
    <tr><td class="paramname">conjunct</td><td>one AND-ed part of 'cond' </td></tr>
    <tr><td class="paramname">weak_tables</td><td>If condition is WHERE, it's 0. Otherwise it is the map of weak tables in the join nest which owns the condition. </td></tr>
    <tr><td class="paramname">weak_side_upwards</td><td>If condition is WHERE it's false. Otherwise it is true if the join nest owning this condition is embedded in the weak side of some parent outer join (no matter how far up the parent is). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga47e06193dc3d4e1018031e9e82c83470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47e06193dc3d4e1018031e9e82c83470">&#9670;&nbsp;</a></span>analyze_scalar_eq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Group_check::analyze_scalar_eq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>left_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>right_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>weak_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>weak_side_upwards</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function. </p>
<dl class="section see"><dt>See also</dt><dd>analyze_conjunct(). </dd></dl>

</div>
</div>
<a id="ga8d9d680fb5c912394aa10ffdb4b28e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d9d680fb5c912394aa10ffdb4b28e2b">&#9670;&nbsp;</a></span>check_expression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Group_check::check_expression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>in_select_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Validates one expression (this forms one step of check_query()). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>current thread </td></tr>
    <tr><td class="paramname">expr</td><td>expression </td></tr>
    <tr><td class="paramname">in_select_list</td><td>whether this expression is coming from the SELECT list. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga83e75b415b78e10ade375ad320ea446c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83e75b415b78e10ade375ad320ea446c">&#9670;&nbsp;</a></span>check_query() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Distinct_check::check_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rejects the query if it has a combination of DISTINCT and ORDER BY which could lead to randomly ordered results. </p>
<p>More precisely: if, in a query block 'sl', an ORDER BY expression</p><ul>
<li>is not the same expression as one in the SELECT list of 'sl' (1)</li>
<li>and contains a column which: &ndash; is of a table whose qualifying query block is 'sl' (2) &ndash; and is not in the SELECT list of 'sl' (3) then 'sl' should not have DISTINCT.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>true if rejected (my_error() is called) </dd></dl>

</div>
</div>
<a id="ga85f98a122e6f9accf528534acb5db686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga85f98a122e6f9accf528534acb5db686">&#9670;&nbsp;</a></span>check_query() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Group_check::check_query </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rejects the query if it does aggregation or grouping, and expressions in its SELECT list, ORDER BY clause, HAVING condition, or window functions may vary inside a group (are not "group-invariant"). </p>

</div>
</div>
<a id="ga2d9e51c550e4d81b6c100633b37cc3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d9e51c550e4d81b6c100633b37cc3f3">&#9670;&nbsp;</a></span>do_ident_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Group_check::do_ident_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__ident.html">Item_ident</a> *&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>tm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="classGroup__check.html#a56c8b8e7fa8710acec07b40674555063">enum_ident_check</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does one low-level check on one Item_ident. </p>
<p>Called by Item_ident walk processors. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>item to check </td></tr>
    <tr><td class="paramname">tm</td><td>map of strong tables, if type==CHECK_STRONG_SIDE_COLUMN </td></tr>
    <tr><td class="paramname">type</td><td>check to do:<ul>
<li>CHECK_GROUP for Item_ident::aggregate_check_group()</li>
<li>CHECK_STRONG_SIDE_COLUMN for Item_ident::is_strong_side_column_not_in_fd()</li>
<li>CHECK_COLUMN for Item_ident::is_column_not_in_fd() </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if success </dd></dl>

</div>
</div>
<a id="ga3bf8ae0675a0199b27aabeb1a09f182a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bf8ae0675a0199b27aabeb1a09f182a">&#9670;&nbsp;</a></span>find_fd_in_cond()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Group_check::find_fd_in_cond </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__table__map_8h.html#a82b78abeba8cfb8e3df3e082f42b6cff">table_map</a>&#160;</td>
          <td class="paramname"><em>weak_tables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>weak_side_upwards</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for equality-based functional dependencies in a condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cond</td><td>condition: a WHERE condition or JOIN condition. </td></tr>
    <tr><td class="paramname">weak_tables</td><td>If condition is WHERE, it's 0. Otherwise it is the map of weak tables in the join nest which owns the condition. </td></tr>
    <tr><td class="paramname">weak_side_upwards</td><td>If condition is WHERE it's false. Otherwise it is true if the join nest owning this condition is embedded in the right side of some parent left join. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga99c585cb512d0af4bd097f352de8c350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99c585cb512d0af4bd097f352de8c350">&#9670;&nbsp;</a></span>find_fd_in_joined_table()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Group_check::find_fd_in_joined_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmem__root__deque.html">mem_root_deque</a>&lt; <a class="el" href="structTABLE__LIST.html">TABLE_LIST</a> *&gt; *&#160;</td>
          <td class="paramname"><em>join_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches for equality-based functional dependencies in the condition of a join nest, and recursively in all contained join nests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">join_list</td><td>members of the join nest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae3ae18ec75ebbaa4268a231f4fec7017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae3ae18ec75ebbaa4268a231f4fec7017">&#9670;&nbsp;</a></span>find_group_in_fd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Group_check::find_group_in_fd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function must be called every time we discover an item which is FD on source columns, or add a bit to whole_tables_fd; it maintains group_in_fd. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>item which is FD; if NULL, means that we instead added a bit to whole_tables_fd. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8104cfa83d31426803965c2dd9abe4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8104cfa83d31426803965c2dd9abe4aa">&#9670;&nbsp;</a></span>get_fd_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a> * Group_check::get_fd_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an element of 'fd' array equal to 'item', or nullptr if not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Item to search for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga710fce06294788d8e9185095b2e9485f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga710fce06294788d8e9185095b2e9485f">&#9670;&nbsp;</a></span>is_fd_on_source()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Group_check::is_fd_on_source </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tells if 'item' is functionally dependent ("FD") on source columns. </p>
<p>Source columns are:</p><ul>
<li>if !is_child(), the GROUP BY columns</li>
<li>if is_child(), columns of the result of the query expression under 'table' which are themselves part of 'fd' of the parent Group_check.</li>
</ul>
<p>We recognize most FDs imposed by SQL2011 (optional feature T301)</p>
<p>We build sets, named En, by induction. A "column" is defined as base table / view / derived table's column.</p>
<p>E1 = {source columns} (=group columns, if this is a master Group_check; empty set otherwise).</p>
<p>En is a set of columns of the result of the WHERE clause of 'select' which are functionally dependent on E1. If is_child(), En columns might rather be of the result of the GROUP BY clause (if there is one), but that's an unimportant detail, ignored further down.</p>
<p>Given En, build En+1:</p><ul>
<li>let En+1= En</li>
<li>for each {pk/unique index of some table T} found in En, add T.* to En+1 (actually, we rather add T's map bit to the table_map whole_tables_fd).</li>
</ul>
<p>Then build En+2, by adding y, for each x=y in AND parts of WHERE/ON where x is in En+1 or is constant, and y is a column not in En+1.</p>
<p>When we meet columns of views or derived tables, we additionally search for FDs in their query expression, which can then give FDs in our query. If En+2==En, this is the end of the induction. Otherwise we loop.</p>
<p>As we build En, we check if 'item' is in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Item to consider; either a column local to 'select', or a set function whose aggregation query is 'select'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if 'item' is functionally dependent on source columns. </dd></dl>

</div>
</div>
<a id="gaa4106041d478efe724a53b239ba3b693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4106041d478efe724a53b239ba3b693">&#9670;&nbsp;</a></span>is_in_fd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Group_check::is_in_fd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>is_in_fd() is low-level compared to is_fd_on_source(). </p>
<p>The former only searches through built FD information; the latter builds this information and calls the former to search in it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>Item to consider; either a column local to 'select', or a set function whose aggregation query is 'select'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the expression is FD on the source. </dd></dl>

</div>
</div>
<a id="gacb78998a8a3e195bc60c2c80f589343d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb78998a8a3e195bc60c2c80f589343d">&#9670;&nbsp;</a></span>is_in_fd_of_underlying()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Group_check::is_in_fd_of_underlying </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem__ident.html">Item_ident</a> *&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See if we can derive a FD from a column which has an underlying expression. </p>
<p>For a generated column, see if we can derive a FD from its expression. For a column of a view or derived table, see if we can derive a FD from the underlying query block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>column </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this column is FD on source </dd></dl>

</div>
</div>
<a id="ga35a0eceb6320238044b128e1fcd6f481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35a0eceb6320238044b128e1fcd6f481">&#9670;&nbsp;</a></span>select_expression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classItem.html">Item</a> * Group_check::select_expression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the idx-th expression in the SELECT list of our query block. </dd></dl>

</div>
</div>
<a id="ga97e11f17193e6ad1adff12b0ff2c3af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97e11f17193e6ad1adff12b0ff2c3af6">&#9670;&nbsp;</a></span>to_opt_trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Group_check::to_opt_trace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes "check information" to the optimizer trace. </p>

</div>
</div>
<a id="ga5a926fd146d27f4b8d06de95a2e0c742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a926fd146d27f4b8d06de95a2e0c742">&#9670;&nbsp;</a></span>to_opt_trace2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Group_check::to_opt_trace2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpt__trace__context.html">Opt_trace_context</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpt__trace__object.html">Opt_trace_object</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function for to_opt_trace(), as we need recursion in children Group_checks. </p>
<p>to_opt_trace() only writes a one-time header. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga760e082ce4eff6cdf0a68f345ae6fbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga760e082ce4eff6cdf0a68f345ae6fbc2">&#9670;&nbsp;</a></span>walk_options</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="sql__const_8h.html#ab2df5e15d7fb7ccd43e6af9527cb81cf">enum_walk</a> walk_options</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="sql__const_8h.html#ab2df5e15d7fb7ccd43e6af9527cb81cfab6abb1328d16cf42b80d04a09a026775">enum_walk::SUBQUERY_PREFIX</a> | <a class="code" href="sql__const_8h.html#ab2df5e15d7fb7ccd43e6af9527cb81cfa6d3030ce53debb6bf57af40bd5428db0">enum_walk::POSTFIX</a></div><div class="ttc" id="sql__const_8h_html_ab2df5e15d7fb7ccd43e6af9527cb81cfa6d3030ce53debb6bf57af40bd5428db0"><div class="ttname"><a href="sql__const_8h.html#ab2df5e15d7fb7ccd43e6af9527cb81cfa6d3030ce53debb6bf57af40bd5428db0">enum_walk::POSTFIX</a></div></div>
<div class="ttc" id="sql__const_8h_html_ab2df5e15d7fb7ccd43e6af9527cb81cfab6abb1328d16cf42b80d04a09a026775"><div class="ttname"><a href="sql__const_8h.html#ab2df5e15d7fb7ccd43e6af9527cb81cfab6abb1328d16cf42b80d04a09a026775">enum_walk::SUBQUERY_PREFIX</a></div></div>
</div><!-- fragment -->
<p>We need to search for items inside subqueries, in case subqueries contain outer references to tables of a query block having DISTINCT or GROUP BY. </p>
<p>We also need to sometimes skip parts of item trees, so the walk processor must be called prefix (to enable skipping) and postfix (to disable skipping). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
