<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Format of redo log</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('PAGE_INNODB_REDO_LOG_FORMAT.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Format of redo log </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sect_redo_log_format_overview"></a>
Overview</h1>
<p>Redo log contains multiple log files, each has the same format. Consecutive files have data for consecutive ranges of lsn values. When a file ends at <em>end_lsn</em>, the next log file begins at the <em>end_lsn</em>. There is a fixed number of log files, they are re-used in circular manner. That is, for the last log file, the first log file is a successor.</p>
<dl class="section note"><dt>Note</dt><dd>A single big file would remain fully cached for some of file systems, even if only a small fragment of the file is being modified. Hence multiple log files are used to make evictions always possible. Keep in mind though that log files are used in circular manner (lsn modulo size of log files, when size is calculated except the log file headers).</dd></dl>
<p>The default log file names are: <em>ib_logfile0</em>, <em>ib_logfile1</em>, ... The maximum allowed number of log files is 100. The special file name <em>ib_logfile101</em> is used when new log files are created and it is used instead of <em>ib_logfile0</em> until all the files are ready. Afterwards the <em>ib_logfile101</em> is atomically renamed to <em>ib_logfile0</em> and files are considered successfully created then.</p>
<h1><a class="anchor" id="sect_redo_log_format_file"></a>
Log file format</h1>
<h2><a class="anchor" id="subsect_redo_log_format_header"></a>
Header of log file</h2>
<p>Log file starts with a header of <em>LOG_FILE_HDR_SIZE</em> bytes. It contains:</p>
<ul>
<li>Initial block of <em>OS_FILE_LOG_BLOCK_SIZE</em> (512) bytes, which has:<ul>
<li><p class="startli">Binding of an offset within the file to the lsn value.</p>
<p class="startli">This binding allows to map any lsn value which is represented within the file to corresponding lsn value.</p>
</li>
</ul>
</li>
<li>Format of redo log - remains the same as before the patch.</li>
<li>Checksum of the block.</li>
<li><p class="startli">Two checkpoint blocks - <em>LOG_CHECKPOINT_1</em> and <em>LOG_CHECKPOINT_2</em>.</p>
<p class="startli">Each checkpoint block contains <em>OS_FILE_LOG_BLOCK_SIZE</em> bytes:</p><ul>
<li><p class="startli"><em>checkpoint_lsn</em> - lsn to start recovery at.</p>
<dl class="section note"><dt>Note</dt><dd>In earlier versions than 8.0, checkpoint_lsn pointed directly to the beginning of the first log record group, which should be recovered (but still the related page could have been flushed). However since 8.0 this value might point to some byte inside a log record. In such case, recovery is supposed to skip the group of log records which contains the checkpoint lsn (and start at the beginning of the next). We cannot easily determine beginning of the next group. There are two cases:<ul>
<li>block with <em>checkpoint_lsn</em> has no beginning of group at all (first_rec_group = 0) - then we search forward for the first block that has non-zero first_rec_group and there we have the next group's start,</li>
<li>block with <em>checkpoint_lsn</em> has one or more groups of records starting inside the block - then we start parsing at the first group that starts in the block and keep parsing consecutive groups until we passed checkpoint_lsn; we don't apply these groups of records (we must not because of fil renames); after we passed checkpoint_lsn, the next group that starts is the one we were looking for to start recovery at; it is possible that the next group begins in the next block (if there was no more groups starting after checkpoint_lsn within the block)</li>
</ul>
</dd></dl>
</li>
<li><em>checkpoint_no</em> - checkpoint number - when checkpoint is being written, a next checkpoint number is assigned.</li>
<li><p class="startli"><em>log.buf_size</em> - size of the log buffer when the checkpoint write was started.</p>
<p class="startli">It remains a mystery, why do we need that. It's neither used by the recovery, nor required for MEB. Some rumours say that maybe it could be useful for auto-config external tools to detect what configuration of MySQL should be used.</p>
<dl class="section note"><dt>Note</dt><dd>Note that size of the log buffer could be decreased in runtime, after writing the checkpoint (which was not the case, when this field was being introduced).</dd></dl>
<p>There are two checkpoint headers, because they are updated alternately. In case of crash in the middle of any such update, the alternate header would remain valid (so it's the same reason for which double write buffer is used for pages).</p>
</li>
</ul>
<dl class="section remark"><dt>Remarks</dt><dd>Each log file has its own header. However checkpoints are read only from the first log file (<em>ib_logfile0</em>) during recovery.</dd></dl>
</li>
</ul>
<h2><a class="anchor" id="subsect_redo_log_format_blocks"></a>
Log blocks</h2>
<p>After the header, there are consecutive log blocks. Each log block has the same format and consists of <em>OS_FILE_LOG_BLOCK_SIZE</em> bytes (512). These bytes are enumerated by lsn values.</p>
<dl class="section note"><dt>Note</dt><dd>Bytes used by <a class="el" href="PAGE_INNODB_REDO_LOG_FORMAT.html#subsect_redo_log_format_header">headers of log files</a> are NOT included in lsn sequence.</dd></dl>
<p>Each log block contains:</p><ul>
<li>header - <em>LOG_BLOCK_HDR_SIZE</em> bytes (12):<ul>
<li><p class="startli"><a class="anchor" id="a_redo_log_block_hdr_no"></a>hdr_no</p>
<p class="startli">This is a block number. Consecutive blocks have consecutive numbers. Hence this is basically lsn divided by <em>OS_FILE_LOG_BLOCK_SIZE</em>. However it is also wrapped at 1G (due to limited size of the field). It should be possible to wrap it at 2G (only the single flush bit is reserved as the highest bit) but for historical reasons it is 1G.</p>
</li>
<li><p class="startli"><a class="anchor" id="a_redo_log_block_flush_bit"></a>flush_bit</p>
<p class="startli">This is a single bit stored as the highest bit of hdr_no. The bit is skipped when calculating block number.</p>
<p class="startli">It is set for the first block of multiple blocks written in a single call to fil_io().</p>
<p class="startli">It was supposed to help to filter out writes which were not atomic. When the flush bit is read from disk, it means that up to this lsn, all previous log records have been fully written from the log buffer to OS buffers. That's because previous calls to fil_io() had to be finished, before a fil_io() call for current block was started.</p>
<p class="startli">The wrong assumption was that we can trust those log records then. Note, we have no guarantee that order of writes is preserved by disk controller. That's why only after fsync() call is finished, one could be sure, that data is fully written (up to the write_lsn at which fsync() was started).</p>
<p class="startli">During recovery, when the flush bit is encountered, *contiguous_lsn is updated, but then the updated lsn seems unused...</p>
<p class="startli">It seems that there is no real benefit from the flush bit at all, and even in 5.7 it was completely ignored during the recovery.</p>
</li>
<li><p class="startli"><a class="anchor" id="a_redo_log_block_data_len"></a>data_len</p>
<p class="startli">Number of bytes within the log block. Possible values:</p><ul>
<li><em>0</em> - this is an empty block (end the recovery).</li>
<li><em>OS_FILE_LOG_BLOCK_SIZE</em> - this is a full block.</li>
<li><p class="startli">value within [<em>LOG_BLOCK_HDR_SIZE</em>, <em>OS_FILE_LOG_BLOCK_SIZE</em> - <em>LOG_BLOCK_TRL_SIZE</em>), which means that this is the last block and it is an incomplete block.</p>
<p class="startli">This could be then considered an offset, which points to the end of the data within the block. This value includes <em>LOG_BLOCK_HDR_SIZE</em> bytes of the header.</p>
</li>
</ul>
</li>
<li><p class="startli"><a class="anchor" id="a_redo_log_block_first_rec_group"></a>first_rec_group</p>
<p class="startli">Offset within the log block to the beginning of the first group of log records that starts within the block or 0 if none starts. This offset includes <em>LOG_BLOCK_HDR_SIZE</em> bytes of the header.</p>
</li>
<li><p class="startli"><a class="anchor" id="a_redo_log_block_checkpoint_no"></a>checkpoint_no</p>
<p class="startli">Checkpoint number of a next checkpoint write. Set by the log writer thread just before a write starts for the block.</p>
<p class="startli">It could be used during recovery to detect that we have read old block of redo log (tail) because of the wrapped log files.</p>
</li>
</ul>
</li>
<li><p class="startli">data part - bytes up to <a class="el" href="PAGE_INNODB_REDO_LOG_FORMAT.html#a_redo_log_block_data_len">data_len</a> byte.</p>
<p class="startli">Actual data bytes are followed by <em>0x00</em> if the block is incomplete.</p>
<dl class="section note"><dt>Note</dt><dd>Bytes within this fragment of the block, are enumerated by <em>sn</em> sequence (whereas bytes of header and trailer are NOT). This is the only difference between <em>sn</em> and <em>lsn</em> sequences (<em>lsn</em> enumerates also bytes of header and trailer).</dd></dl>
</li>
<li>trailer - <em>LOG_BLOCK_TRL_SIZE</em> bytes (4):<ul>
<li><p class="startli">checksum</p>
<p class="startli">Algorithm used for the checksum depends on the configuration. Note that there is a potential problem if a crash happened just after switching to "checksums enabled". During recovery some log blocks would have checksum = LOG_NO_CHECKSUM_MAGIC and some would have a valid checksum. Then recovery with enabled checksums would point problems for the blocks without valid checksum. User would have to disable checksums for the recovery then.</p>
</li>
</ul>
</li>
</ul>
<dl class="section remark"><dt>Remarks</dt><dd>All fields except <a class="el" href="PAGE_INNODB_REDO_LOG_FORMAT.html#a_redo_log_block_first_rec_group">first_rec_group</a> are updated by the <a class="el" href="PAGE_INNODB_REDO_LOG_THREADS.html#sect_redo_log_writer">log writer thread</a> just before writing the block. </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="PAGE_STORAGE.html">Data Storage</a></li><li class="navelem"><a class="el" href="PAGE_INNODB_REDO_LOG.html">Innodb redo log</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
