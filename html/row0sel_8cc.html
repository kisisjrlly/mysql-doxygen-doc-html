<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/row/row0sel.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('row0sel_8cc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">row0sel.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Select.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="row0sel_8h_source.html">row0sel.h</a>&quot;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0cur_8h_source.html">btr0cur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0sea_8h_source.html">btr0sea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0lru_8h_source.html">buf0lru.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0boot_8h_source.html">dict0boot.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0dd_8h_source.html">dict0dd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0dict_8h_source.html">dict0dict.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="eval0eval_8h_source.html">eval0eval.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="gis0rtree_8h_source.html">gis0rtree.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ha__innodb_8h_source.html">ha_innodb.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ha__prototypes_8h_source.html">ha_prototypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sql_2handler_8h_source.html">handler.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lob0lob_8h_source.html">lob0lob.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lob0undo_8h_source.html">lob0undo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mach0data_8h_source.html">mach0data.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pars0pars_8h_source.html">pars0pars.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pars0sym_8h_source.html">pars0sym.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="que0que_8h_source.html">que0que.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="read0read_8h_source.html">read0read.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="record__buffer_8h_source.html">record_buffer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0cmp_8h_source.html">rem0cmp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0mysql_8h_source.html">row0mysql.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0row_8h_source.html">row0row.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0upd_8h_source.html">row0upd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0vers_8h_source.html">row0vers.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0mon_8h_source.html">srv0mon.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0trx_8h_source.html">trx0trx.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0undo_8h_source.html">trx0undo.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ut0new_8h_source.html">ut0new.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__dbug_8h_source.html">my_dbug.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRow__sel__get__clust__rec__for__mysql.html">Row_sel_get_clust_rec_for_mysql</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to cache clust_rec and old_ver.  <a href="classRow__sel__get__clust__rec__for__mysql.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrow__to__range__relation__t.html">row_to_range_relation_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The return type of row_compare_row_to_range() which summarizes information about the relation between the row being processed, and the range of the scan.  <a href="structrow__to__range__relation__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a01430b79ede5d4cf453f45462592cf76"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a01430b79ede5d4cf453f45462592cf76">SEL_MAX_N_PREFETCH</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:a01430b79ede5d4cf453f45462592cf76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of rows to prefetch; MySQL interface has another parameter.  <a href="#a01430b79ede5d4cf453f45462592cf76">More...</a><br /></td></tr>
<tr class="separator:a01430b79ede5d4cf453f45462592cf76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5204c5b2e2b11a0521a67a7e4a1a98"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a1a5204c5b2e2b11a0521a67a7e4a1a98">SEL_PREFETCH_LIMIT</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a1a5204c5b2e2b11a0521a67a7e4a1a98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows fetched, after which to start prefetching; MySQL interface has another parameter.  <a href="#a1a5204c5b2e2b11a0521a67a7e4a1a98">More...</a><br /></td></tr>
<tr class="separator:a1a5204c5b2e2b11a0521a67a7e4a1a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a403b172b5e16197799778348b38c1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a50a403b172b5e16197799778348b38c1">SEL_COST_LIMIT</a>&#160;&#160;&#160;100</td></tr>
<tr class="memdesc:a50a403b172b5e16197799778348b38c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">When a select has accessed about this many pages, it returns control back to que_run_threads: this is to allow canceling runaway queries.  <a href="#a50a403b172b5e16197799778348b38c1">More...</a><br /></td></tr>
<tr class="separator:a50a403b172b5e16197799778348b38c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7e9f6d33cc34931bf6eb6e41439b00"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a0c7e9f6d33cc34931bf6eb6e41439b00">SEL_FOUND</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a0c7e9f6d33cc34931bf6eb6e41439b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags for search shortcut.  <a href="#a0c7e9f6d33cc34931bf6eb6e41439b00">More...</a><br /></td></tr>
<tr class="separator:a0c7e9f6d33cc34931bf6eb6e41439b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238b6d3e5d1266f5ba148ad5d0b3cefe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a238b6d3e5d1266f5ba148ad5d0b3cefe">SEL_EXHAUSTED</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a238b6d3e5d1266f5ba148ad5d0b3cefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557e37795152ecf2d7c00774107a8c11"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a557e37795152ecf2d7c00774107a8c11">SEL_RETRY</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a557e37795152ecf2d7c00774107a8c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ef793c9a6004778655aa2f478679ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a15ef793c9a6004778655aa2f478679ca">row_sel_field_store_in_mysql_format</a>(dest,  templ,  idx,  field,  src,  len,  <a class="el" href="ctype_8cc.html#abe7970caf4b4a5acc5ddc69da9a6ddb1">sec</a>)</td></tr>
<tr class="memdesc:a15ef793c9a6004778655aa2f478679ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a non-SQL-NULL field from Innobase format to MySQL format.  <a href="#a15ef793c9a6004778655aa2f478679ca">More...</a><br /></td></tr>
<tr class="separator:a15ef793c9a6004778655aa2f478679ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ebbcfe3c889aaa52b04f820667b7ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a57ebbcfe3c889aaa52b04f820667b7ef">row_sel_store_mysql_field</a>(m,  <a class="el" href="ctype-mb_8cc.html#a6bc6b007533335efe02bafff799ec64c">p</a>,  <a class="el" href="pfs__example__plugin__employee_8cc.html#ab3f8ffa864d702be7152eed806293ad9">r</a>,  ri,  pi,  o,  f,  t,  s,  l,  bh)&#160;&#160;&#160;<a class="el" href="row0sel_8cc.html#afd58fcedab737ea4a2fc128cad8f8708">row_sel_store_mysql_field_func</a>(m, <a class="el" href="ctype-mb_8cc.html#a6bc6b007533335efe02bafff799ec64c">p</a>, <a class="el" href="pfs__example__plugin__employee_8cc.html#ab3f8ffa864d702be7152eed806293ad9">r</a>, ri, pi, o, f, t, s, l, bh)</td></tr>
<tr class="memdesc:a57ebbcfe3c889aaa52b04f820667b7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a field from Innobase format to MySQL format.  <a href="#a57ebbcfe3c889aaa52b04f820667b7ef">More...</a><br /></td></tr>
<tr class="separator:a57ebbcfe3c889aaa52b04f820667b7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1e085f0f39f707f45fbbbbb2c238d676"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a1e085f0f39f707f45fbbbbb2c238d676">row_sel_sec_rec_is_for_blob</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, ulint mtype, ulint prtype, ulint mbminmaxlen, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *clust_field, ulint clust_len, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *sec_field, ulint sec_len, ulint prefix_len, <a class="el" href="structdict__table__t.html">dict_table_t</a> *table)</td></tr>
<tr class="memdesc:a1e085f0f39f707f45fbbbbb2c238d676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if the user-defined column in a secondary index record is alphabetically the same as the corresponding BLOB column in the clustered index record.  <a href="#a1e085f0f39f707f45fbbbbb2c238d676">More...</a><br /></td></tr>
<tr class="separator:a1e085f0f39f707f45fbbbbb2c238d676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a071a68fc165d2730ca75030fbd2c1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#aa2a071a68fc165d2730ca75030fbd2c1">row_sel_sec_rec_is_for_clust_rec</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *sec_rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *sec_index, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *clust_rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *clust_index, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> &amp;is_equal)</td></tr>
<tr class="memdesc:aa2a071a68fc165d2730ca75030fbd2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if the user-defined column values in a secondary index record are alphabetically the same as the corresponding columns in the clustered index record.  <a href="#aa2a071a68fc165d2730ca75030fbd2c1">More...</a><br /></td></tr>
<tr class="separator:aa2a071a68fc165d2730ca75030fbd2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07758ef3ddfed71103ca09905852fa53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a07758ef3ddfed71103ca09905852fa53">sel_node_create</a> (<a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a07758ef3ddfed71103ca09905852fa53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a select node struct.  <a href="#a07758ef3ddfed71103ca09905852fa53">More...</a><br /></td></tr>
<tr class="separator:a07758ef3ddfed71103ca09905852fa53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01de404cd77d6c2b9ccc3b2cd0c8199e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a01de404cd77d6c2b9ccc3b2cd0c8199e">sel_node_free_private</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *node)</td></tr>
<tr class="memdesc:a01de404cd77d6c2b9ccc3b2cd0c8199e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory private to a select node when a query graph is freed, does not free the heap where the node was originally created.  <a href="#a01de404cd77d6c2b9ccc3b2cd0c8199e">More...</a><br /></td></tr>
<tr class="separator:a01de404cd77d6c2b9ccc3b2cd0c8199e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbac18f23c6c2777e4348deb8a43b653"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#abbac18f23c6c2777e4348deb8a43b653">sel_eval_select_list</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *node)</td></tr>
<tr class="memdesc:abbac18f23c6c2777e4348deb8a43b653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the values in a select list.  <a href="#abbac18f23c6c2777e4348deb8a43b653">More...</a><br /></td></tr>
<tr class="separator:abbac18f23c6c2777e4348deb8a43b653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e906a9b7458e18363283b109ba79865"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a6e906a9b7458e18363283b109ba79865">sel_assign_into_var_values</a> (<a class="el" href="structsym__node__t.html">sym_node_t</a> *var, <a class="el" href="structsel__node__t.html">sel_node_t</a> *node)</td></tr>
<tr class="memdesc:a6e906a9b7458e18363283b109ba79865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the values in the select list to the possible into-variables in SELECT ...  <a href="#a6e906a9b7458e18363283b109ba79865">More...</a><br /></td></tr>
<tr class="separator:a6e906a9b7458e18363283b109ba79865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d82f18cec6edca4d4a146ee825420d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#ae0d82f18cec6edca4d4a146ee825420d">sel_reset_aggregate_vals</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *node)</td></tr>
<tr class="memdesc:ae0d82f18cec6edca4d4a146ee825420d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the aggregate value totals in the select list of an aggregate type query.  <a href="#ae0d82f18cec6edca4d4a146ee825420d">More...</a><br /></td></tr>
<tr class="separator:ae0d82f18cec6edca4d4a146ee825420d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aaf62195104ca1c15083caf9a77f767"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a3aaf62195104ca1c15083caf9a77f767">row_sel_copy_input_variable_vals</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *node)</td></tr>
<tr class="memdesc:a3aaf62195104ca1c15083caf9a77f767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the input variable values when an explicit cursor is opened.  <a href="#a3aaf62195104ca1c15083caf9a77f767">More...</a><br /></td></tr>
<tr class="separator:a3aaf62195104ca1c15083caf9a77f767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab977dadcd29cdaa12354bf464b231ca8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#ab977dadcd29cdaa12354bf464b231ca8">row_sel_fetch_columns</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const ulint *offsets, <a class="el" href="structsym__node__t.html">sym_node_t</a> *column, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> allow_null_lob=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:ab977dadcd29cdaa12354bf464b231ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetches the column values from a record.  <a href="#ab977dadcd29cdaa12354bf464b231ca8">More...</a><br /></td></tr>
<tr class="separator:ab977dadcd29cdaa12354bf464b231ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd568c4b26f7b2aff1eb304c2733a6f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a0cd568c4b26f7b2aff1eb304c2733a6f">sel_col_prefetch_buf_alloc</a> (<a class="el" href="structsym__node__t.html">sym_node_t</a> *column)</td></tr>
<tr class="memdesc:a0cd568c4b26f7b2aff1eb304c2733a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a prefetch buffer for a column when prefetch is first time done.  <a href="#a0cd568c4b26f7b2aff1eb304c2733a6f">More...</a><br /></td></tr>
<tr class="separator:a0cd568c4b26f7b2aff1eb304c2733a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315cd18c35a39e3ab7e0b4137330062e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a315cd18c35a39e3ab7e0b4137330062e">sel_col_prefetch_buf_free</a> (<a class="el" href="structsel__buf__t.html">sel_buf_t</a> *prefetch_buf)</td></tr>
<tr class="memdesc:a315cd18c35a39e3ab7e0b4137330062e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a prefetch buffer for a column, including the dynamically allocated memory for data stored there.  <a href="#a315cd18c35a39e3ab7e0b4137330062e">More...</a><br /></td></tr>
<tr class="separator:a315cd18c35a39e3ab7e0b4137330062e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d31f6c8c4befd6f11ff69380831784"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a68d31f6c8c4befd6f11ff69380831784">sel_dequeue_prefetched_row</a> (<a class="el" href="structplan__t.html">plan_t</a> *plan)</td></tr>
<tr class="memdesc:a68d31f6c8c4befd6f11ff69380831784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops the column values for a prefetched, cached row from the column prefetch buffers and places them to the val fields in the column nodes.  <a href="#a68d31f6c8c4befd6f11ff69380831784">More...</a><br /></td></tr>
<tr class="separator:a68d31f6c8c4befd6f11ff69380831784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14a1423e8ffac387af7cd2ec31f1870"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#ad14a1423e8ffac387af7cd2ec31f1870">sel_enqueue_prefetched_row</a> (<a class="el" href="structplan__t.html">plan_t</a> *plan)</td></tr>
<tr class="memdesc:ad14a1423e8ffac387af7cd2ec31f1870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes the column values for a prefetched, cached row to the column prefetch buffers from the val fields in the column nodes.  <a href="#ad14a1423e8ffac387af7cd2ec31f1870">More...</a><br /></td></tr>
<tr class="separator:ad14a1423e8ffac387af7cd2ec31f1870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423d72b48db4c76ce21ba31541ac1a7f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a423d72b48db4c76ce21ba31541ac1a7f">row_sel_build_prev_vers</a> (<a class="el" href="classReadView.html">ReadView</a> *read_view, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **offset_heap, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **old_vers_heap, <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **old_vers, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a423d72b48db4c76ce21ba31541ac1a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a previous version of a clustered index record for a consistent read.  <a href="#a423d72b48db4c76ce21ba31541ac1a7f">More...</a><br /></td></tr>
<tr class="separator:a423d72b48db4c76ce21ba31541ac1a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a13e4944614123cae0d09aa0475c2ad"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a7a13e4944614123cae0d09aa0475c2ad">row_sel_build_committed_vers_for_mysql</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *clust_index, <a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **offset_heap, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **old_vers, const <a class="el" href="structdtuple__t.html">dtuple_t</a> **vrow, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a7a13e4944614123cae0d09aa0475c2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the last committed version of a clustered index record for a semi-consistent read.  <a href="#a7a13e4944614123cae0d09aa0475c2ad">More...</a><br /></td></tr>
<tr class="separator:a7a13e4944614123cae0d09aa0475c2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5ec5c1cf72b61ecffc6a10077b9e0c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a0e5ec5c1cf72b61ecffc6a10077b9e0c">row_sel_test_end_conds</a> (<a class="el" href="structplan__t.html">plan_t</a> *plan)</td></tr>
<tr class="memdesc:a0e5ec5c1cf72b61ecffc6a10077b9e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests the conditions which determine when the index segment we are searching through has been exhausted.  <a href="#a0e5ec5c1cf72b61ecffc6a10077b9e0c">More...</a><br /></td></tr>
<tr class="separator:a0e5ec5c1cf72b61ecffc6a10077b9e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45d63f8767a1d238d6a83ba20030d9d"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#ab45d63f8767a1d238d6a83ba20030d9d">row_sel_test_other_conds</a> (<a class="el" href="structplan__t.html">plan_t</a> *plan)</td></tr>
<tr class="memdesc:ab45d63f8767a1d238d6a83ba20030d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests the other conditions.  <a href="#ab45d63f8767a1d238d6a83ba20030d9d">More...</a><br /></td></tr>
<tr class="separator:ab45d63f8767a1d238d6a83ba20030d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eaa11e526b865674e274ef489013844"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a7eaa11e526b865674e274ef489013844">row_sel_get_clust_rec</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *node, <a class="el" href="structplan__t.html">plan_t</a> *plan, <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **out_rec, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a7eaa11e526b865674e274ef489013844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the clustered index record corresponding to a record in a non-clustered index.  <a href="#a7eaa11e526b865674e274ef489013844">More...</a><br /></td></tr>
<tr class="separator:a7eaa11e526b865674e274ef489013844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba38dae60f42534bf8cd11fa1905a2e"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a6ba38dae60f42534bf8cd11fa1905a2e">sel_set_rtr_rec_lock</a> (<a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *first_rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, <a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a> sel_mode, ulint mode, ulint type, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a6ba38dae60f42534bf8cd11fa1905a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a lock on a page of R-Tree record.  <a href="#a6ba38dae60f42534bf8cd11fa1905a2e">More...</a><br /></td></tr>
<tr class="separator:a6ba38dae60f42534bf8cd11fa1905a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8583919bdcf40c9686e654ce8f6dace"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#ac8583919bdcf40c9686e654ce8f6dace">sel_set_rec_lock</a> (<a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets, <a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a> sel_mode, ulint mode, ulint type, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ac8583919bdcf40c9686e654ce8f6dace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a lock on a record.  <a href="#ac8583919bdcf40c9686e654ce8f6dace">More...</a><br /></td></tr>
<tr class="separator:ac8583919bdcf40c9686e654ce8f6dace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be48be22748ddb6cf3a043b1d89a068"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a8be48be22748ddb6cf3a043b1d89a068">row_sel_open_pcur</a> (<a class="el" href="structplan__t.html">plan_t</a> *plan, ibool search_latch_locked, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a8be48be22748ddb6cf3a043b1d89a068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a pcur to a table index.  <a href="#a8be48be22748ddb6cf3a043b1d89a068">More...</a><br /></td></tr>
<tr class="separator:a8be48be22748ddb6cf3a043b1d89a068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7369f9771a6c0036ada6c4f37e849eb"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#ac7369f9771a6c0036ada6c4f37e849eb">row_sel_restore_pcur_pos</a> (<a class="el" href="structplan__t.html">plan_t</a> *plan, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ac7369f9771a6c0036ada6c4f37e849eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores a stored pcur position to a table index.  <a href="#ac7369f9771a6c0036ada6c4f37e849eb">More...</a><br /></td></tr>
<tr class="separator:ac7369f9771a6c0036ada6c4f37e849eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02b3d214e35ad30142146f32c6fbaa0"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#ad02b3d214e35ad30142146f32c6fbaa0">plan_reset_cursor</a> (<a class="el" href="structplan__t.html">plan_t</a> *plan)</td></tr>
<tr class="memdesc:ad02b3d214e35ad30142146f32c6fbaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a plan cursor to a closed state.  <a href="#ad02b3d214e35ad30142146f32c6fbaa0">More...</a><br /></td></tr>
<tr class="separator:ad02b3d214e35ad30142146f32c6fbaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca6a6d16666e6aa78564b2e3c041c90"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#afca6a6d16666e6aa78564b2e3c041c90">row_sel_try_search_shortcut</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="structsel__node__t.html">sel_node_t</a> *node, <a class="el" href="structplan__t.html">plan_t</a> *plan, ibool search_latch_locked, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:afca6a6d16666e6aa78564b2e3c041c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to do a shortcut to fetch a clustered index record with a unique key, using the hash index if possible (not always).  <a href="#afca6a6d16666e6aa78564b2e3c041c90">More...</a><br /></td></tr>
<tr class="separator:afca6a6d16666e6aa78564b2e3c041c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15177c7361d85ffc92c8cf1f9be45ab"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#ab15177c7361d85ffc92c8cf1f9be45ab">row_sel</a> (<a class="el" href="structsel__node__t.html">sel_node_t</a> *node, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:ab15177c7361d85ffc92c8cf1f9be45ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a select step.  <a href="#ab15177c7361d85ffc92c8cf1f9be45ab">More...</a><br /></td></tr>
<tr class="separator:ab15177c7361d85ffc92c8cf1f9be45ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495b63075e783048fed8d49aae97e826"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a495b63075e783048fed8d49aae97e826">row_sel_step</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a495b63075e783048fed8d49aae97e826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a select step.  <a href="#a495b63075e783048fed8d49aae97e826">More...</a><br /></td></tr>
<tr class="separator:a495b63075e783048fed8d49aae97e826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad103921b4ed077de358b93f5f6e31a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#aad103921b4ed077de358b93f5f6e31a0">fetch_step</a> (<a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:aad103921b4ed077de358b93f5f6e31a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a fetch for a cursor.  <a href="#aad103921b4ed077de358b93f5f6e31a0">More...</a><br /></td></tr>
<tr class="separator:aad103921b4ed077de358b93f5f6e31a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf589959a6267769bebaf443f31eb6ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#abf589959a6267769bebaf443f31eb6ce">row_sel_convert_mysql_key_to_innobase</a> (<a class="el" href="structdtuple__t.html">dtuple_t</a> *tuple, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *buf, ulint buf_len, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *key_ptr, ulint key_len, <a class="el" href="structtrx__t.html">trx_t</a> *trx)</td></tr>
<tr class="memdesc:abf589959a6267769bebaf443f31eb6ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a key value stored in MySQL format to an Innobase dtuple.  <a href="#abf589959a6267769bebaf443f31eb6ce">More...</a><br /></td></tr>
<tr class="separator:abf589959a6267769bebaf443f31eb6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa73d727df43d710b029a0932d3edda"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#aaaa73d727df43d710b029a0932d3edda">row_sel_store_row_id_to_prebuilt</a> (<a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *index_rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const ulint *offsets)</td></tr>
<tr class="memdesc:aaaa73d727df43d710b029a0932d3edda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the row id to the prebuilt struct.  <a href="#aaaa73d727df43d710b029a0932d3edda">More...</a><br /></td></tr>
<tr class="separator:aaaa73d727df43d710b029a0932d3edda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60149fe3105375396f31f8357d3d5b32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a60149fe3105375396f31f8357d3d5b32">row_sel_field_store_in_mysql_format_func</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *dest, const <a class="el" href="structmysql__row__templ__t.html">mysql_row_templ_t</a> *templ, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint field_no, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *data, ulint len, ulint sec_field)</td></tr>
<tr class="memdesc:a60149fe3105375396f31f8357d3d5b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a non-SQL-NULL field in the MySQL format.  <a href="#a60149fe3105375396f31f8357d3d5b32">More...</a><br /></td></tr>
<tr class="separator:a60149fe3105375396f31f8357d3d5b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd58fcedab737ea4a2fc128cad8f8708"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#afd58fcedab737ea4a2fc128cad8f8708">row_sel_store_mysql_field_func</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *mysql_rec, <a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *rec_index, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *prebuilt_index, const ulint *offsets, ulint field_no, const <a class="el" href="structmysql__row__templ__t.html">mysql_row_templ_t</a> *templ, ulint sec_field_no, <a class="el" href="structlob_1_1undo__vers__t.html">lob::undo_vers_t</a> *lob_undo, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&amp;blob_heap)</td></tr>
<tr class="memdesc:afd58fcedab737ea4a2fc128cad8f8708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a field in the Innobase format to a field in the MySQL format.  <a href="#afd58fcedab737ea4a2fc128cad8f8708">More...</a><br /></td></tr>
<tr class="separator:afd58fcedab737ea4a2fc128cad8f8708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af60d50ccfcda40fecde998b9aa6223fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#af60d50ccfcda40fecde998b9aa6223fd">row_sel_store_mysql_rec</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *mysql_rec, <a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *vrow, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> rec_clust, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *rec_index, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *prebuilt_index, const ulint *offsets, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> clust_templ_for_sec, <a class="el" href="structlob_1_1undo__vers__t.html">lob::undo_vers_t</a> *lob_undo, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&amp;blob_heap)</td></tr>
<tr class="memdesc:af60d50ccfcda40fecde998b9aa6223fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a row in the Innobase format to a row in the MySQL format.  <a href="#af60d50ccfcda40fecde998b9aa6223fd">More...</a><br /></td></tr>
<tr class="separator:af60d50ccfcda40fecde998b9aa6223fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa181b7750e6176ead4193f95e34a466"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#afa181b7750e6176ead4193f95e34a466">row_sel_build_prev_vers_for_mysql</a> (<a class="el" href="classReadView.html">ReadView</a> *read_view, <a class="el" href="structdict__index__t.html">dict_index_t</a> *clust_index, <a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **offset_heap, <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **old_vers, const <a class="el" href="structdtuple__t.html">dtuple_t</a> **vrow, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="structlob_1_1undo__vers__t.html">lob::undo_vers_t</a> *lob_undo)</td></tr>
<tr class="memdesc:afa181b7750e6176ead4193f95e34a466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a previous version of a clustered index record for a consistent read.  <a href="#afa181b7750e6176ead4193f95e34a466">More...</a><br /></td></tr>
<tr class="separator:afa181b7750e6176ead4193f95e34a466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e4a33ed48b323433b9771d21819e20"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a61e4a33ed48b323433b9771d21819e20">sel_restore_position_for_mysql</a> (ibool *same_user_rec, ulint latch_mode, <a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur, ibool moves_up, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a61e4a33ed48b323433b9771d21819e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores cursor position after it has been stored.  <a href="#a61e4a33ed48b323433b9771d21819e20">More...</a><br /></td></tr>
<tr class="separator:a61e4a33ed48b323433b9771d21819e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd265ee18ee4525add172b4d40ec6384"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#abd265ee18ee4525add172b4d40ec6384">row_sel_copy_cached_field_for_mysql</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *buf, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *cache, const <a class="el" href="structmysql__row__templ__t.html">mysql_row_templ_t</a> *templ)</td></tr>
<tr class="memdesc:abd265ee18ee4525add172b4d40ec6384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a cached field for MySQL from the fetch cache.  <a href="#abd265ee18ee4525add172b4d40ec6384">More...</a><br /></td></tr>
<tr class="separator:abd265ee18ee4525add172b4d40ec6384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059f90de50bfc9dc852538e87a1bb7b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a059f90de50bfc9dc852538e87a1bb7b7">row_sel_copy_cached_fields_for_mysql</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *buf, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *cached_rec, <a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt)</td></tr>
<tr class="memdesc:a059f90de50bfc9dc852538e87a1bb7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy used fields from cached row.  <a href="#a059f90de50bfc9dc852538e87a1bb7b7">More...</a><br /></td></tr>
<tr class="separator:a059f90de50bfc9dc852538e87a1bb7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c263c36be70d77c53350d433cbf616d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classRecord__buffer.html">Record_buffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a8c263c36be70d77c53350d433cbf616d">row_sel_get_record_buffer</a> (const <a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt)</td></tr>
<tr class="memdesc:a8c263c36be70d77c53350d433cbf616d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the record buffer provided by the server, if there is one.  <a href="#a8c263c36be70d77c53350d433cbf616d">More...</a><br /></td></tr>
<tr class="separator:a8c263c36be70d77c53350d433cbf616d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecac7a5b39493949bffcd96d9c8ab42"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a8ecac7a5b39493949bffcd96d9c8ab42">row_sel_dequeue_cached_row_for_mysql</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *buf, <a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt)</td></tr>
<tr class="memdesc:a8ecac7a5b39493949bffcd96d9c8ab42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pops a cached row for MySQL from the fetch cache.  <a href="#a8ecac7a5b39493949bffcd96d9c8ab42">More...</a><br /></td></tr>
<tr class="separator:a8ecac7a5b39493949bffcd96d9c8ab42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3425e26a9cfdb61d0abcd305b947989"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#ac3425e26a9cfdb61d0abcd305b947989">row_sel_prefetch_cache_init</a> (<a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt)</td></tr>
<tr class="memdesc:ac3425e26a9cfdb61d0abcd305b947989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise the prefetch cache.  <a href="#ac3425e26a9cfdb61d0abcd305b947989">More...</a><br /></td></tr>
<tr class="separator:ac3425e26a9cfdb61d0abcd305b947989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae538275b8bdf4458f46bdb35da9ea6ad"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#ae538275b8bdf4458f46bdb35da9ea6ad">row_sel_fetch_last_buf</a> (<a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt)</td></tr>
<tr class="memdesc:ae538275b8bdf4458f46bdb35da9ea6ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last fetch cache buffer from the queue.  <a href="#ae538275b8bdf4458f46bdb35da9ea6ad">More...</a><br /></td></tr>
<tr class="separator:ae538275b8bdf4458f46bdb35da9ea6ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048771f93fa1397faef48571a288e117"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a048771f93fa1397faef48571a288e117">row_sel_enqueue_cache_row_for_mysql</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *mysql_rec, <a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt)</td></tr>
<tr class="memdesc:a048771f93fa1397faef48571a288e117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes a row for MySQL to the fetch cache.  <a href="#a048771f93fa1397faef48571a288e117">More...</a><br /></td></tr>
<tr class="separator:a048771f93fa1397faef48571a288e117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa67d47594f2bf11dfe5e085e0dab2b9"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#aaa67d47594f2bf11dfe5e085e0dab2b9">row_sel_try_search_shortcut_for_mysql</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **out_rec, <a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **heap, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aaa67d47594f2bf11dfe5e085e0dab2b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to do a shortcut to fetch a clustered index record with a unique key, using the hash index if possible (not always).  <a href="#aaa67d47594f2bf11dfe5e085e0dab2b9">More...</a><br /></td></tr>
<tr class="separator:aaa67d47594f2bf11dfe5e085e0dab2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d880ad36edbe71e45d60534e2eeafd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="my__icp_8h.html#af09bac1481262588acf702d2093c919b">ICP_RESULT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a68d880ad36edbe71e45d60534e2eeafd">row_search_idx_cond_check</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *mysql_rec, <a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const ulint *offsets)</td></tr>
<tr class="memdesc:a68d880ad36edbe71e45d60534e2eeafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a pushed-down index condition.  <a href="#a68d880ad36edbe71e45d60534e2eeafd">More...</a><br /></td></tr>
<tr class="separator:a68d880ad36edbe71e45d60534e2eeafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b750b3d5f7a4a030ba627ffdc7aa20"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#ad9b750b3d5f7a4a030ba627ffdc7aa20">row_search_end_range_check</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *mysql_rec, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> clust_templ_for_sec, const ulint *offsets, <a class="el" href="classRecord__buffer.html">Record_buffer</a> *record_buffer)</td></tr>
<tr class="memdesc:ad9b750b3d5f7a4a030ba627ffdc7aa20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the pushed-down end-range condition to avoid extra traversal if records are not with in view and also to avoid prefetching too many records into the record buffer.  <a href="#ad9b750b3d5f7a4a030ba627ffdc7aa20">More...</a><br /></td></tr>
<tr class="separator:ad9b750b3d5f7a4a030ba627ffdc7aa20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f0fb4944c70720c87922fbecba9227"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a47f0fb4944c70720c87922fbecba9227">row_search_traverse</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> moves_up, ulint match_mode, <a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a47f0fb4944c70720c87922fbecba9227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse to next/previous record.  <a href="#a47f0fb4944c70720c87922fbecba9227">More...</a><br /></td></tr>
<tr class="separator:a47f0fb4944c70720c87922fbecba9227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d49e0cb76c4fcd172e702a486f547d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a66d49e0cb76c4fcd172e702a486f547d">row_search_no_mvcc</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *buf, <a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a> mode, <a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt, ulint match_mode, ulint direction)</td></tr>
<tr class="memdesc:a66d49e0cb76c4fcd172e702a486f547d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for rows in the database using cursor.  <a href="#a66d49e0cb76c4fcd172e702a486f547d">More...</a><br /></td></tr>
<tr class="separator:a66d49e0cb76c4fcd172e702a486f547d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2cbd4ebffc095b51ffc4b03674736b6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#ad2cbd4ebffc095b51ffc4b03674736b6">row_sel_fill_vrow</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> **vrow, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:ad2cbd4ebffc095b51ffc4b03674736b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract virtual column data from a virtual index record and fill a dtuple.  <a href="#ad2cbd4ebffc095b51ffc4b03674736b6">More...</a><br /></td></tr>
<tr class="separator:ad2cbd4ebffc095b51ffc4b03674736b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e9d72181123651dd67b8073b3a7a5b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structrow__to__range__relation__t.html">row_to_range_relation_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a45e9d72181123651dd67b8073b3a7a5b">row_compare_row_to_range</a> (const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> set_also_gap_locks, const <a class="el" href="structtrx__t.html">trx_t</a> *const trx, const ibool unique_search, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *const <a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *const clust_index, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *const rec, const ibool comp, const <a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a> mode, const ulint direction, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *search_tuple, const ulint *const offsets, const ibool moves_up, const <a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *const prebuilt)</td></tr>
<tr class="memdesc:a45e9d72181123651dd67b8073b3a7a5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function extracted from row_search_mvcc() which compares the row being processed with the range of the scan.  <a href="#a45e9d72181123651dd67b8073b3a7a5b">More...</a><br /></td></tr>
<tr class="separator:a45e9d72181123651dd67b8073b3a7a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119ae5fc72d59b4e0855ccebb201f00c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a119ae5fc72d59b4e0855ccebb201f00c">row_search_debug_copy_rec_order_prefix</a> (const <a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, ulint *n_fields, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> **buf, size_t *<a class="el" href="create__def_8cc.html#a83a426bc389379d92979b5248e18877c">buf_size</a>)</td></tr>
<tr class="memdesc:a119ae5fc72d59b4e0855ccebb201f00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the record is not old version, copies an initial segment of a physical record to be compared later for debug assertion code.  <a href="#a119ae5fc72d59b4e0855ccebb201f00c">More...</a><br /></td></tr>
<tr class="separator:a119ae5fc72d59b4e0855ccebb201f00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cc5faba2588347d5e5f05903de0d5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a54cc5faba2588347d5e5f05903de0d5f">row_search_mvcc</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *buf, <a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a> mode, <a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt, ulint match_mode, const ulint direction)</td></tr>
<tr class="memdesc:a54cc5faba2588347d5e5f05903de0d5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches for rows in the database using cursor.  <a href="#a54cc5faba2588347d5e5f05903de0d5f">More...</a><br /></td></tr>
<tr class="separator:a54cc5faba2588347d5e5f05903de0d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad489c2c617f5abe6c0fd89e26a1e3581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#ad489c2c617f5abe6c0fd89e26a1e3581">row_count_rtree_recs</a> (<a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *prebuilt, ulint *n_rows, ulint *n_dups)</td></tr>
<tr class="memdesc:ad489c2c617f5abe6c0fd89e26a1e3581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count rows in a R-Tree leaf level.  <a href="#ad489c2c617f5abe6c0fd89e26a1e3581">More...</a><br /></td></tr>
<tr class="separator:ad489c2c617f5abe6c0fd89e26a1e3581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a0f0e2c2641ba33ed8605a65018b89"><td class="memItemLeft" align="right" valign="top">static ib_uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#aa8a0f0e2c2641ba33ed8605a65018b89">row_search_autoinc_read_column</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, ulint col_no, ulint mtype, ibool unsigned_type)</td></tr>
<tr class="memdesc:aa8a0f0e2c2641ba33ed8605a65018b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the AUTOINC column from the current row.  <a href="#aa8a0f0e2c2641ba33ed8605a65018b89">More...</a><br /></td></tr>
<tr class="separator:aa8a0f0e2c2641ba33ed8605a65018b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acc32873686f9e04aaf5b0de1af9256"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a3acc32873686f9e04aaf5b0de1af9256">row_search_get_max_rec</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a3acc32873686f9e04aaf5b0de1af9256"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum and non-delete-marked record in an index.  <a href="#a3acc32873686f9e04aaf5b0de1af9256">More...</a><br /></td></tr>
<tr class="separator:a3acc32873686f9e04aaf5b0de1af9256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707e988bfa2ef04ad2d27baa6eb1398b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a707e988bfa2ef04ad2d27baa6eb1398b">row_search_max_autoinc</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const char *col_name, ib_uint64_t *<a class="el" href="persisted__variable_8cc.html#a211d620ef86d6a09b1d29b51b6e44f06">value</a>)</td></tr>
<tr class="memdesc:a707e988bfa2ef04ad2d27baa6eb1398b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the max AUTOINC value from an index.  <a href="#a707e988bfa2ef04ad2d27baa6eb1398b">More...</a><br /></td></tr>
<tr class="separator:a707e988bfa2ef04ad2d27baa6eb1398b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce8c8ab8beee67aa19051f7d1e50799"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a3ce8c8ab8beee67aa19051f7d1e50799">convert_to_table_stats_record</a> (<a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *clust_rec, <a class="el" href="structdict__index__t.html">dict_index_t</a> *clust_index, ulint *clust_offsets, <a class="el" href="classTableStatsRecord.html">TableStatsRecord</a> &amp;tbl_stats)</td></tr>
<tr class="memdesc:a3ce8c8ab8beee67aa19051f7d1e50799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the innodb_table_stats clustered index record to table_stats format.  <a href="#a3ce8c8ab8beee67aa19051f7d1e50799">More...</a><br /></td></tr>
<tr class="separator:a3ce8c8ab8beee67aa19051f7d1e50799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad874ef55b928e4c6c55364d1731ff9c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#ad874ef55b928e4c6c55364d1731ff9c8">row_search_table_stats</a> (const char *db_name, const char *tbl_name, <a class="el" href="classTableStatsRecord.html">TableStatsRecord</a> &amp;table_stats)</td></tr>
<tr class="memdesc:ad874ef55b928e4c6c55364d1731ff9c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the record present in innodb_table_stats table using db_name, table_name and fill it in table stats structure.  <a href="#ad874ef55b928e4c6c55364d1731ff9c8">More...</a><br /></td></tr>
<tr class="separator:ad874ef55b928e4c6c55364d1731ff9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a6bd5f2cd6eee8cb75eb31a4e0434c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="row0sel_8cc.html#a04a6bd5f2cd6eee8cb75eb31a4e0434c">row_search_index_stats</a> (const char *db_name, const char *tbl_name, const char *index_name, ulint col_offset, <a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *cardinality)</td></tr>
<tr class="memdesc:a04a6bd5f2cd6eee8cb75eb31a4e0434c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the record present in innodb_index_stats using db_name, table name and index_name and fill the cardinality for the each column.  <a href="#a04a6bd5f2cd6eee8cb75eb31a4e0434c">More...</a><br /></td></tr>
<tr class="separator:a04a6bd5f2cd6eee8cb75eb31a4e0434c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Select. </p>
<p>Created 12/19/1997 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a15ef793c9a6004778655aa2f478679ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ef793c9a6004778655aa2f478679ca">&#9670;&nbsp;</a></span>row_sel_field_store_in_mysql_format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define row_sel_field_store_in_mysql_format</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">dest, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">templ, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">idx, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">field, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">src, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="ctype_8cc.html#abe7970caf4b4a5acc5ddc69da9a6ddb1">sec</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="row0sel_8cc.html#a60149fe3105375396f31f8357d3d5b32">row_sel_field_store_in_mysql_format_func</a>(dest, templ, idx, field, src, len,  \</div><div class="line">                                           <a class="code" href="ctype_8cc.html#abe7970caf4b4a5acc5ddc69da9a6ddb1">sec</a>)</div><div class="ttc" id="row0sel_8cc_html_a60149fe3105375396f31f8357d3d5b32"><div class="ttname"><a href="row0sel_8cc.html#a60149fe3105375396f31f8357d3d5b32">row_sel_field_store_in_mysql_format_func</a></div><div class="ttdeci">void row_sel_field_store_in_mysql_format_func(byte *dest, const mysql_row_templ_t *templ, const dict_index_t *index, ulint field_no, const byte *data, ulint len, ulint sec_field)</div><div class="ttdoc">Stores a non-SQL-NULL field in the MySQL format. </div><div class="ttdef"><b>Definition:</b> row0sel.cc:2576</div></div>
<div class="ttc" id="ctype_8cc_html_abe7970caf4b4a5acc5ddc69da9a6ddb1"><div class="ttname"><a href="ctype_8cc.html#abe7970caf4b4a5acc5ddc69da9a6ddb1">sec</a></div><div class="ttdeci">static struct my_cs_file_section_st sec[]</div><div class="ttdef"><b>Definition:</b> ctype.cc:159</div></div>
</div><!-- fragment -->
<p>Convert a non-SQL-NULL field from Innobase format to MySQL format. </p>

</div>
</div>
<a id="a57ebbcfe3c889aaa52b04f820667b7ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ebbcfe3c889aaa52b04f820667b7ef">&#9670;&nbsp;</a></span>row_sel_store_mysql_field</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define row_sel_store_mysql_field</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="ctype-mb_8cc.html#a6bc6b007533335efe02bafff799ec64c">p</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="pfs__example__plugin__employee_8cc.html#ab3f8ffa864d702be7152eed806293ad9">r</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ri, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pi, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">o, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">f, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">t, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">s, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">l, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bh&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="row0sel_8cc.html#afd58fcedab737ea4a2fc128cad8f8708">row_sel_store_mysql_field_func</a>(m, <a class="el" href="ctype-mb_8cc.html#a6bc6b007533335efe02bafff799ec64c">p</a>, <a class="el" href="pfs__example__plugin__employee_8cc.html#ab3f8ffa864d702be7152eed806293ad9">r</a>, ri, pi, o, f, t, s, l, bh)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a field from Innobase format to MySQL format. </p>

</div>
</div>
<a id="a50a403b172b5e16197799778348b38c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a403b172b5e16197799778348b38c1">&#9670;&nbsp;</a></span>SEL_COST_LIMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SEL_COST_LIMIT&#160;&#160;&#160;100</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When a select has accessed about this many pages, it returns control back to que_run_threads: this is to allow canceling runaway queries. </p>

</div>
</div>
<a id="a238b6d3e5d1266f5ba148ad5d0b3cefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238b6d3e5d1266f5ba148ad5d0b3cefe">&#9670;&nbsp;</a></span>SEL_EXHAUSTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SEL_EXHAUSTED&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c7e9f6d33cc34931bf6eb6e41439b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c7e9f6d33cc34931bf6eb6e41439b00">&#9670;&nbsp;</a></span>SEL_FOUND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SEL_FOUND&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags for search shortcut. </p>

</div>
</div>
<a id="a01430b79ede5d4cf453f45462592cf76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01430b79ede5d4cf453f45462592cf76">&#9670;&nbsp;</a></span>SEL_MAX_N_PREFETCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SEL_MAX_N_PREFETCH&#160;&#160;&#160;16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of rows to prefetch; MySQL interface has another parameter. </p>

</div>
</div>
<a id="a1a5204c5b2e2b11a0521a67a7e4a1a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5204c5b2e2b11a0521a67a7e4a1a98">&#9670;&nbsp;</a></span>SEL_PREFETCH_LIMIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SEL_PREFETCH_LIMIT&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of rows fetched, after which to start prefetching; MySQL interface has another parameter. </p>

</div>
</div>
<a id="a557e37795152ecf2d7c00774107a8c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557e37795152ecf2d7c00774107a8c11">&#9670;&nbsp;</a></span>SEL_RETRY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SEL_RETRY&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3ce8c8ab8beee67aa19051f7d1e50799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce8c8ab8beee67aa19051f7d1e50799">&#9670;&nbsp;</a></span>convert_to_table_stats_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void convert_to_table_stats_record </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>clust_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>clust_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>clust_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTableStatsRecord.html">TableStatsRecord</a> &amp;&#160;</td>
          <td class="paramname"><em>tbl_stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the innodb_table_stats clustered index record to table_stats format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_rec</td><td>clustered index record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_index</td><td>clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_offsets</td><td>offsets of the clustered index record </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tbl_stats</td><td>table_stats information to be filled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad103921b4ed077de358b93f5f6e31a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad103921b4ed077de358b93f5f6e31a0">&#9670;&nbsp;</a></span>fetch_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structque__thr__t.html">que_thr_t</a>* fetch_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a fetch for a cursor. </p>
<dl class="section return"><dt>Returns</dt><dd>query thread to run next or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad02b3d214e35ad30142146f32c6fbaa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02b3d214e35ad30142146f32c6fbaa0">&#9670;&nbsp;</a></span>plan_reset_cursor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void plan_reset_cursor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplan__t.html">plan_t</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets a plan cursor to a closed state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>in: plan </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45e9d72181123651dd67b8073b3a7a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e9d72181123651dd67b8073b3a7a5b">&#9670;&nbsp;</a></span>row_compare_row_to_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structrow__to__range__relation__t.html">row_to_range_relation_t</a> row_compare_row_to_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>set_also_gap_locks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *const&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ibool&#160;</td>
          <td class="paramname"><em>unique_search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *const&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *const&#160;</td>
          <td class="paramname"><em>clust_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *const&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ibool&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>search_tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *const&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ibool&#160;</td>
          <td class="paramname"><em>moves_up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *const&#160;</td>
          <td class="paramname"><em>prebuilt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A helper function extracted from row_search_mvcc() which compares the row being processed with the range of the scan. </p>
<p>It does not modify any of it's arguments and returns a summary of situation. All the arguments are named the same way as local variables at place of call, and have same values. </p>

</div>
</div>
<a id="ad489c2c617f5abe6c0fd89e26a1e3581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad489c2c617f5abe6c0fd89e26a1e3581">&#9670;&nbsp;</a></span>row_count_rtree_recs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_count_rtree_recs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_dups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count rows in a R-Tree leaf level. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if successful </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prebuilt</td><td>in: prebuilt struct for the table handle; this contains the info of search_tuple, index; if search tuple contains 0 fields then we position the cursor at the start or the end of the index, depending on 'mode' </td></tr>
    <tr><td class="paramname">n_rows</td><td>out: number of entries seen in the consistent read </td></tr>
    <tr><td class="paramname">n_dups</td><td>out: number of dup entries </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8a0f0e2c2641ba33ed8605a65018b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a0f0e2c2641ba33ed8605a65018b89">&#9670;&nbsp;</a></span>row_search_autoinc_read_column()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ib_uint64_t row_search_autoinc_read_column </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>col_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>unsigned_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the AUTOINC column from the current row. </p>
<p>If the value is less than 0 and the type is not unsigned then we reset the value to 0. </p><dl class="section return"><dt>Returns</dt><dd>value read from the column </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index to read from </td></tr>
    <tr><td class="paramname">rec</td><td>in: current rec </td></tr>
    <tr><td class="paramname">col_no</td><td>in: column number </td></tr>
    <tr><td class="paramname">mtype</td><td>in: column main type </td></tr>
    <tr><td class="paramname">unsigned_type</td><td>in: signed or unsigned flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a119ae5fc72d59b4e0855ccebb201f00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119ae5fc72d59b4e0855ccebb201f00c">&#9670;&nbsp;</a></span>row_search_debug_copy_rec_order_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a>* row_search_debug_copy_rec_order_prefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> **&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the record is not old version, copies an initial segment of a physical record to be compared later for debug assertion code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcur</td><td>cursor whose position has been stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>record for which to copy prefix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">n_fields</td><td>number of fields copied </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf</td><td>memory buffer for the copied prefix, or nullptr </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buf_size</td><td>buffer size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the prefix record if not old version. or nullptr if old </dd></dl>

</div>
</div>
<a id="ad9b750b3d5f7a4a030ba627ffdc7aa20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b750b3d5f7a4a030ba627ffdc7aa20">&#9670;&nbsp;</a></span>row_search_end_range_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_search_end_range_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>mysql_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>clust_templ_for_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classRecord__buffer.html">Record_buffer</a> *&#160;</td>
          <td class="paramname"><em>record_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check the pushed-down end-range condition to avoid extra traversal if records are not with in view and also to avoid prefetching too many records into the record buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mysql_rec</td><td>record in MySQL format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>InnoDB record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prebuilt</td><td>prebuilt struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_templ_for_sec</td><td>true if <em>rec</em> belongs to the secondary index but the <em>prebuilt</em> template is in clustered index format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>information about column offsets in the secondary index, if virtual columns need to be copied into <em>mysql_rec</em> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">record_buffer</td><td>the record buffer we are reading into, or <code>nullptr</code> if there is no buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the row in <em>mysql_rec</em> is out of range </td></tr>
    <tr><td class="paramname">false</td><td>if the row in <em>mysql_rec</em> is in range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3acc32873686f9e04aaf5b0de1af9256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3acc32873686f9e04aaf5b0de1af9256">&#9670;&nbsp;</a></span>row_search_get_max_rec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a>* row_search_get_max_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum and non-delete-marked record in an index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Index tree </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction (may be committed and restarted) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>maximum record, page s-latched in mtr </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>if there are no records, or if all of them are delete-marked </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68d880ad36edbe71e45d60534e2eeafd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d880ad36edbe71e45d60534e2eeafd">&#9670;&nbsp;</a></span>row_search_idx_cond_check()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="my__icp_8h.html#af09bac1481262588acf702d2093c919b">ICP_RESULT</a> row_search_idx_cond_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>mysql_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check a pushed-down index condition. </p>
<dl class="section return"><dt>Returns</dt><dd>ICP_NO_MATCH, ICP_MATCH, or ICP_OUT_OF_RANGE </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mysql_rec</td><td>out: record in MySQL format (invalid unless prebuilt-&gt;idx_cond == true and we return ICP_MATCH) </td></tr>
    <tr><td class="paramname">prebuilt</td><td>in/out: prebuilt struct for the table handle </td></tr>
    <tr><td class="paramname">rec</td><td>in: InnoDB record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets() </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a04a6bd5f2cd6eee8cb75eb31a4e0434c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04a6bd5f2cd6eee8cb75eb31a4e0434c">&#9670;&nbsp;</a></span>row_search_index_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_search_index_stats </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tbl_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>index_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>col_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__inttypes_8h.html#a22152088aba12c47e916b7f0ffee0f51">ulonglong</a> *&#160;</td>
          <td class="paramname"><em>cardinality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the record present in innodb_index_stats using db_name, table name and index_name and fill the cardinality for the each column. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">db_name</td><td>database name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tbl_name</td><td>table name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index_name</td><td>index name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">col_offset</td><td>offset of the column in the index </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">cardinality</td><td>cardinality of the column. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful else false. </dd></dl>
<p>Number of fields to search in the table.</p>
<p>Column number of innodb_index_stats.database_name.</p>
<p>Column number of innodb_index_stats.table_name.</p>
<p>Column number of innodb_index_stats.index_name.</p>
<p>Column number of innodb_index_stats.stat_value.</p>
<p>Search the innodb_index_stats table using (database_name, table_name, index_name). </p>

</div>
</div>
<a id="a707e988bfa2ef04ad2d27baa6eb1398b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707e988bfa2ef04ad2d27baa6eb1398b">&#9670;&nbsp;</a></span>row_search_max_autoinc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_search_max_autoinc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>col_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ib_uint64_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the max AUTOINC value from an index. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS if all OK else error code, DB_RECORD_NOT_FOUND if column name can't be found in index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: index to search </td></tr>
    <tr><td class="paramname">col_name</td><td>in: name of autoinc column </td></tr>
    <tr><td class="paramname">value</td><td>out: AUTOINC value read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54cc5faba2588347d5e5f05903de0d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54cc5faba2588347d5e5f05903de0d5f">&#9670;&nbsp;</a></span>row_search_mvcc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_search_mvcc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>match_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for rows in the database using cursor. </p>
<p>Function is mainly used for tables that are shared accorss connection and so it employs technique that can help re-construct the rows that transaction is suppose to see. It also has optimization such as pre-caching the rows, using AHI, etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>buffer for the fetched row in MySQL format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>search mode PAGE_CUR_L </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">prebuilt</td><td>prebuilt struct for the table handler; this contains the info to search_tuple, index; if search tuple contains 0 field then we position the cursor at start or the end of index, depending on 'mode' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">match_mode</td><td>0 or ROW_SEL_EXACT or ROW_SEL_EXACT_PREFIX </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>0 or ROW_SEL_NEXT or ROW_SEL_PREV; Note: if this is != 0, then prebuilt must has a pcur with stored position! In opening of a cursor 'direction' should be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<p>Compare the last record of the page with end range passed to InnoDB when there is no ICP and number of loops in row_search_mvcc for rows found but not reporting due to search views etc. </p><pre class="fragment">Secondary index record but the template
</pre><p> based on PK.</p>
<p>Create offsets based on prebuilt index. </p><pre class="fragment">In case of prebuilt-&gt;fetch,
</pre><p> set the error in prebuilt-&gt;end_range. </p>

</div>
</div>
<a id="a66d49e0cb76c4fcd172e702a486f547d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d49e0cb76c4fcd172e702a486f547d">&#9670;&nbsp;</a></span>row_search_no_mvcc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_search_no_mvcc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#a09a7c28cbc96005a4ad8497a1a195dba">page_cur_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>match_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches for rows in the database using cursor. </p>
<p>Function is for temporary tables that are not shared accross connections and so lot of complexity is reduced especially locking and transaction related. The cursor is an iterator over the table/index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>buffer for the fetched row in MySQL format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>search mode PAGE_CUR_L </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">prebuilt</td><td>prebuilt struct for the table handler; this contains the info to search_tuple, index; if search tuple contains 0 field then we position the cursor at start or the end of index, depending on 'mode' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">match_mode</td><td>0 or ROW_SEL_EXACT or ROW_SEL_EXACT_PREFIX </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>0 or ROW_SEL_NEXT or ROW_SEL_PREV; Note: if this is != 0, then prebuilt must has a pcur with stored position! In opening of a cursor 'direction' should be 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>

</div>
</div>
<a id="ad874ef55b928e4c6c55364d1731ff9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad874ef55b928e4c6c55364d1731ff9c8">&#9670;&nbsp;</a></span>row_search_table_stats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_search_table_stats </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>db_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tbl_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTableStatsRecord.html">TableStatsRecord</a> &amp;&#160;</td>
          <td class="paramname"><em>table_stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the record present in innodb_table_stats table using db_name, table_name and fill it in table stats structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">db_name</td><td>database name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tbl_name</td><td>table name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">table_stats</td><td>stats table structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful else false. </dd></dl>

</div>
</div>
<a id="a47f0fb4944c70720c87922fbecba9227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f0fb4944c70720c87922fbecba9227">&#9670;&nbsp;</a></span>row_search_traverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_search_traverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>moves_up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>match_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse to next/previous record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">moves_up</td><td>If true, move to next record else previous </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">match_mode</td><td>0 or ROW_SEL_EXACT or ROW_SEL_EXACT_PREFIX </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">pcur</td><td>Cursor to record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>

</div>
</div>
<a id="ab15177c7361d85ffc92c8cf1f9be45ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15177c7361d85ffc92c8cf1f9be45ab">&#9670;&nbsp;</a></span>row_sel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_sel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a select step. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: select node </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a13e4944614123cae0d09aa0475c2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a13e4944614123cae0d09aa0475c2ad">&#9670;&nbsp;</a></span>row_sel_build_committed_vers_for_mysql()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_sel_build_committed_vers_for_mysql </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>clust_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>offset_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **&#160;</td>
          <td class="paramname"><em>old_vers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> **&#160;</td>
          <td class="paramname"><em>vrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds the last committed version of a clustered index record for a semi-consistent read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clust_index</td><td>in: clustered index </td></tr>
    <tr><td class="paramname">prebuilt</td><td>in: prebuilt struct </td></tr>
    <tr><td class="paramname">rec</td><td>in: record in a clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in/out: offsets returned by rec_get_offsets(rec, clust_index) </td></tr>
    <tr><td class="paramname">offset_heap</td><td>in/out: memory heap from which the offsets are allocated </td></tr>
    <tr><td class="paramname">old_vers</td><td>out: old version, or NULL if the record does not exist in the view: i.e., it was freshly inserted afterwards </td></tr>
    <tr><td class="paramname">vrow</td><td>out: to be filled with old virtual column version if any </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a423d72b48db4c76ce21ba31541ac1a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423d72b48db4c76ce21ba31541ac1a7f">&#9670;&nbsp;</a></span>row_sel_build_prev_vers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_sel_build_prev_vers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classReadView.html">ReadView</a> *&#160;</td>
          <td class="paramname"><em>read_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>offset_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>old_vers_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **&#160;</td>
          <td class="paramname"><em>old_vers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a previous version of a clustered index record for a consistent read. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">read_view</td><td>in: read view </td></tr>
    <tr><td class="paramname">index</td><td>in: plan node for table </td></tr>
    <tr><td class="paramname">rec</td><td>in: record in a clustered index </td></tr>
    <tr><td class="paramname">offsets</td><td>in/out: offsets returned by rec_get_offsets(rec, plan-&gt;index) </td></tr>
    <tr><td class="paramname">offset_heap</td><td>in/out: memory heap from which the offsets are allocated </td></tr>
    <tr><td class="paramname">old_vers_heap</td><td>out: old version heap to use </td></tr>
    <tr><td class="paramname">old_vers</td><td>out: old version, or NULL if the record does not exist in the view: i.e., it was freshly inserted afterwards </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa181b7750e6176ead4193f95e34a466"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa181b7750e6176ead4193f95e34a466">&#9670;&nbsp;</a></span>row_sel_build_prev_vers_for_mysql()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_sel_build_prev_vers_for_mysql </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classReadView.html">ReadView</a> *&#160;</td>
          <td class="paramname"><em>read_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>clust_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>offset_heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **&#160;</td>
          <td class="paramname"><em>old_vers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> **&#160;</td>
          <td class="paramname"><em>vrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlob_1_1undo__vers__t.html">lob::undo_vers_t</a> *&#160;</td>
          <td class="paramname"><em>lob_undo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a previous version of a clustered index record for a consistent read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">read_view</td><td>read view </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_index</td><td>clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prebuilt</td><td>prebuilt struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>record in clustered index </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offsets</td><td>offsets returned by rec_get_offsets(rec, clust_index) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">offset_heap</td><td>memory heap from which the offsets are allocated </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">old_vers</td><td>old version, or NULL if the record does not exist in the view: i.e., it was freshly inserted afterwards </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vrow</td><td>dtuple to hold old virtual column data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>the mini-transaction context. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">lob_undo</td><td>Undo information for BLOBs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>

</div>
</div>
<a id="abf589959a6267769bebaf443f31eb6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf589959a6267769bebaf443f31eb6ce">&#9670;&nbsp;</a></span>row_sel_convert_mysql_key_to_innobase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_sel_convert_mysql_key_to_innobase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>buf_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>key_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>key_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a key value stored in MySQL format to an Innobase dtuple. </p>
<p>The last field of the key value may be just a prefix of a fixed length field: hence the parameter key_len. But currently we do not allow search keys where the last field is only a prefix of the full key field len and print a warning if such appears. A counterpart of this function is ha_innobase::store_key_val_for_row() in ha_innodb.cc. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>in/out: tuple where to build; NOTE: we assume that the type info in the tuple is already according to index! </td></tr>
    <tr><td class="paramname">buf</td><td>in: buffer to use in field conversions; NOTE that dtuple-&gt;data may end up pointing inside buf so do not discard that buffer while the tuple is being used. See row_mysql_store_col_in_innobase_format() in the case of DATA_INT </td></tr>
    <tr><td class="paramname">buf_len</td><td>in: buffer length </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the key value </td></tr>
    <tr><td class="paramname">key_ptr</td><td>in: MySQL key value </td></tr>
    <tr><td class="paramname">key_len</td><td>in: MySQL key value length </td></tr>
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd265ee18ee4525add172b4d40ec6384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd265ee18ee4525add172b4d40ec6384">&#9670;&nbsp;</a></span>row_sel_copy_cached_field_for_mysql()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_sel_copy_cached_field_for_mysql </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmysql__row__templ__t.html">mysql_row_templ_t</a> *&#160;</td>
          <td class="paramname"><em>templ</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies a cached field for MySQL from the fetch cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: row buffer </td></tr>
    <tr><td class="paramname">cache</td><td>in: cached row </td></tr>
    <tr><td class="paramname">templ</td><td>in: column template </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a059f90de50bfc9dc852538e87a1bb7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059f90de50bfc9dc852538e87a1bb7b7">&#9670;&nbsp;</a></span>row_sel_copy_cached_fields_for_mysql()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_sel_copy_cached_fields_for_mysql </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>cached_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy used fields from cached row. </p>
<p>Copy cache record field by field, don't touch fields that are not covered by current key. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>Where to copy the MySQL row. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cached_rec</td><td>What to copy (in MySQL row format). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prebuilt</td><td>prebuilt struct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3aaf62195104ca1c15083caf9a77f767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aaf62195104ca1c15083caf9a77f767">&#9670;&nbsp;</a></span>row_sel_copy_input_variable_vals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void row_sel_copy_input_variable_vals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the input variable values when an explicit cursor is opened. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: select node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ecac7a5b39493949bffcd96d9c8ab42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecac7a5b39493949bffcd96d9c8ab42">&#9670;&nbsp;</a></span>row_sel_dequeue_cached_row_for_mysql()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void row_sel_dequeue_cached_row_for_mysql </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pops a cached row for MySQL from the fetch cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>in/out: buffer where to copy the row </td></tr>
    <tr><td class="paramname">prebuilt</td><td>in: prebuilt struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a048771f93fa1397faef48571a288e117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048771f93fa1397faef48571a288e117">&#9670;&nbsp;</a></span>row_sel_enqueue_cache_row_for_mysql()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void row_sel_enqueue_cache_row_for_mysql </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>mysql_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes a row for MySQL to the fetch cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mysql_rec</td><td>in/out: MySQL record </td></tr>
    <tr><td class="paramname">prebuilt</td><td>in/out: prebuilt struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab977dadcd29cdaa12354bf464b231ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab977dadcd29cdaa12354bf464b231ca8">&#9670;&nbsp;</a></span>row_sel_fetch_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_sel_fetch_columns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>allow_null_lob</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetches the column values from a record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">trx</td><td>the current transaction or nullptr </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>record index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>record in a clustered or non-clustered index; must be protected by a page latch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">column</td><td>first column in a column list, or NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allow_null_lob</td><td>allow null lob if true. default is false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae538275b8bdf4458f46bdb35da9ea6ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae538275b8bdf4458f46bdb35da9ea6ad">&#9670;&nbsp;</a></span>row_sel_fetch_last_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* row_sel_fetch_last_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the last fetch cache buffer from the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>pointer to buffer. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prebuilt</td><td>in/out: prebuilt struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60149fe3105375396f31f8357d3d5b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60149fe3105375396f31f8357d3d5b32">&#9670;&nbsp;</a></span>row_sel_field_store_in_mysql_format_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void row_sel_field_store_in_mysql_format_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmysql__row__templ__t.html">mysql_row_templ_t</a> *&#160;</td>
          <td class="paramname"><em>templ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>field_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>sec_field</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a non-SQL-NULL field in the MySQL format. </p>
<p>The counterpart of this function is row_mysql_store_col_in_innobase_format() in row0mysql.cc. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dest</td><td>buffer where to store; NOTE that BLOBs are not in themselves stored here: the caller must allocate and copy the BLOB into buffer before, and pass the pointer to the BLOB in 'data' </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">templ</td><td>MySQL column template. Its following fields are referenced: type, is_unsigned, mysql_col_len, mbminlen, mbmaxlen </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>InnoDB index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field_no</td><td>templ-&gt;rec_field_no or templ-&gt;clust_rec_field_no or templ-&gt;icp_rec_field_no </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>data to store </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>length of the data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_field</td><td>secondary index field no if the secondary index record but the prebuilt template is in clustered index format and used only for end range comparison. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2cbd4ebffc095b51ffc4b03674736b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2cbd4ebffc095b51ffc4b03674736b6">&#9670;&nbsp;</a></span>row_sel_fill_vrow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_sel_fill_vrow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> **&#160;</td>
          <td class="paramname"><em>vrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract virtual column data from a virtual index record and fill a dtuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>the virtual (secondary) index record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>the virtual index </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vrow</td><td>the dtuple where data extract to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">heap</td><td>memory heap to allocate memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7eaa11e526b865674e274ef489013844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eaa11e526b865674e274ef489013844">&#9670;&nbsp;</a></span>row_sel_get_clust_rec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_sel_get_clust_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplan__t.html">plan_t</a> *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **&#160;</td>
          <td class="paramname"><em>out_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the clustered index record corresponding to a record in a non-clustered index. </p>
<p>Does the necessary locking. </p><dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: select_node </td></tr>
    <tr><td class="paramname">plan</td><td>in: plan node for table </td></tr>
    <tr><td class="paramname">rec</td><td>in: record in a non-clustered index </td></tr>
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
    <tr><td class="paramname">out_rec</td><td>out: clustered record or an old version of it, NULL if the old version did not exist in the read view, i.e., it was a fresh inserted version </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr used to get access to the non-clustered record; the same mtr is used to access the clustered index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c263c36be70d77c53350d433cbf616d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c263c36be70d77c53350d433cbf616d">&#9670;&nbsp;</a></span>row_sel_get_record_buffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classRecord__buffer.html">Record_buffer</a>* row_sel_get_record_buffer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the record buffer provided by the server, if there is one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prebuilt</td><td>prebuilt struct </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the record buffer, or nullptr if none was provided </dd></dl>

</div>
</div>
<a id="a8be48be22748ddb6cf3a043b1d89a068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be48be22748ddb6cf3a043b1d89a068">&#9670;&nbsp;</a></span>row_sel_open_pcur()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_sel_open_pcur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplan__t.html">plan_t</a> *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>search_latch_locked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opens a pcur to a table index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>in: table plan </td></tr>
    <tr><td class="paramname">search_latch_locked</td><td>in: TRUE if the thread currently has the search latch locked in s-mode </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3425e26a9cfdb61d0abcd305b947989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3425e26a9cfdb61d0abcd305b947989">&#9670;&nbsp;</a></span>row_sel_prefetch_cache_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void row_sel_prefetch_cache_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise the prefetch cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prebuilt</td><td>in/out: prebuilt struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7369f9771a6c0036ada6c4f37e849eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7369f9771a6c0036ada6c4f37e849eb">&#9670;&nbsp;</a></span>row_sel_restore_pcur_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool row_sel_restore_pcur_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplan__t.html">plan_t</a> *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restores a stored pcur position to a table index. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the cursor should be moved to the next record after we return from this function (moved to the previous, in the case of a descending cursor) without processing again the current cursor record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>in: table plan </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e085f0f39f707f45fbbbbb2c238d676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e085f0f39f707f45fbbbbb2c238d676">&#9670;&nbsp;</a></span>row_sel_sec_rec_is_for_blob()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool row_sel_sec_rec_is_for_blob </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>prtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mbminmaxlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>clust_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>clust_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>sec_field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>sec_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>prefix_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__table__t.html">dict_table_t</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns TRUE if the user-defined column in a secondary index record is alphabetically the same as the corresponding BLOB column in the clustered index record. </p>
<p>NOTE: the comparison is NOT done as a binary comparison, but character fields are compared with collation! </p><dl class="section return"><dt>Returns</dt><dd>true if the columns are equal </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: the operating transaction </td></tr>
    <tr><td class="paramname">mtype</td><td>in: main type </td></tr>
    <tr><td class="paramname">prtype</td><td>in: precise type </td></tr>
    <tr><td class="paramname">mbminmaxlen</td><td>in: minimum and maximum length of a multi-byte character </td></tr>
    <tr><td class="paramname">clust_field</td><td>in: the locally stored part of the clustered index column, including the BLOB pointer; the clustered index record must be covered by a lock or a page latch to protect it against deletion (rollback or purge) </td></tr>
    <tr><td class="paramname">clust_len</td><td>in: length of clust_field </td></tr>
    <tr><td class="paramname">sec_field</td><td>in: column in secondary index </td></tr>
    <tr><td class="paramname">sec_len</td><td>in: length of sec_field </td></tr>
    <tr><td class="paramname">prefix_len</td><td>in: index column prefix length in bytes </td></tr>
    <tr><td class="paramname">table</td><td>in: table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2a071a68fc165d2730ca75030fbd2c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a071a68fc165d2730ca75030fbd2c1">&#9670;&nbsp;</a></span>row_sel_sec_rec_is_for_clust_rec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> row_sel_sec_rec_is_for_clust_rec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>sec_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>sec_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>clust_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>clust_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> &amp;&#160;</td>
          <td class="paramname"><em>is_equal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns TRUE if the user-defined column values in a secondary index record are alphabetically the same as the corresponding columns in the clustered index record. </p>
<p>NOTE: the comparison is NOT done as a binary comparison, but character fields are compared with collation! </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_rec</td><td>secondary index record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_index</td><td>secondary index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_rec</td><td>clustered index record; must be protected by a page s-latch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_index</td><td>clustered index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">is_equal</td><td>set to true if the secondary record is equal to the corresponding fields in the clustered record, when compared with collation; false if not equal or if the clustered record has been marked for deletion; only valid if DB_SUCCESS was returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>

</div>
</div>
<a id="a495b63075e783048fed8d49aae97e826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495b63075e783048fed8d49aae97e826">&#9670;&nbsp;</a></span>row_sel_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structque__thr__t.html">que_thr_t</a>* row_sel_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a select step. </p>
<p>This is a high-level function used in SQL execution graphs. </p><dl class="section return"><dt>Returns</dt><dd>query thread to run next or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thr</td><td>in: query thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd58fcedab737ea4a2fc128cad8f8708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd58fcedab737ea4a2fc128cad8f8708">&#9670;&nbsp;</a></span>row_sel_store_mysql_field_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_sel_store_mysql_field_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>mysql_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>rec_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>field_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmysql__row__templ__t.html">mysql_row_templ_t</a> *&#160;</td>
          <td class="paramname"><em>templ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>sec_field_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlob_1_1undo__vers__t.html">lob::undo_vers_t</a> *&#160;</td>
          <td class="paramname"><em>lob_undo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&amp;&#160;</td>
          <td class="paramname"><em>blob_heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a field in the Innobase format to a field in the MySQL format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mysql_rec</td><td>Record in the MySQL format </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">prebuilt</td><td>Prebuilt struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>InnoDB record; must be protected by a page latch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec_index</td><td>Index of rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prebuilt_index</td><td>prebuilt-&gt;index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>Array returned by rec_get_offsets() </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">field_no</td><td>templ-&gt;rec_field_no or templ-&gt;clust_rec_field_no or templ-&gt;icp_rec_field_no or sec field no if clust_templ_for_sec is true </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">templ</td><td>row template </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sec_field_no</td><td>Secondary index field no if the secondary index record but the prebuilt template is in clustered index format and used only for end range comparison. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lob_undo</td><td>the LOB undo information. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">blob_heap</td><td>If not null then use this heap for BLOBs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af60d50ccfcda40fecde998b9aa6223fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60d50ccfcda40fecde998b9aa6223fd">&#9670;&nbsp;</a></span>row_sel_store_mysql_rec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> row_sel_store_mysql_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>mysql_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>vrow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>rec_clust</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>rec_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>clust_templ_for_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlob_1_1undo__vers__t.html">lob::undo_vers_t</a> *&#160;</td>
          <td class="paramname"><em>lob_undo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&amp;&#160;</td>
          <td class="paramname"><em>blob_heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a row in the Innobase format to a row in the MySQL format. </p>
<p>Note that the template in prebuilt may advise us to copy only a few columns to mysql_rec, other columns are left blank. All columns may not be needed in the query. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mysql_rec</td><td>row in the MySQL format </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">prebuilt</td><td>prebuilt structure </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>Innobase record in the index which was described in prebuilt's template, or in the clustered index; must be protected by a page latch </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vrow</td><td>virtual columns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec_clust</td><td>true if rec is in the clustered index instead of index which could belong to prebuilt-&gt;index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec_index</td><td>index of rec </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prebuilt_index</td><td>prebuilt-&gt;index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>array returned by rec_get_offsets(rec) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">clust_templ_for_sec</td><td>true if rec belongs to secondary index but the prebuilt-&gt;template is in clustered index format and it is used only for end range comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lob_undo</td><td>the LOB undo information. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">blob_heap</td><td>If not null then use this heap for BLOBs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false if not all columns could be retrieved </dd></dl>

</div>
</div>
<a id="aaaa73d727df43d710b029a0932d3edda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaa73d727df43d710b029a0932d3edda">&#9670;&nbsp;</a></span>row_sel_store_row_id_to_prebuilt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void row_sel_store_row_id_to_prebuilt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>index_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores the row id to the prebuilt struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prebuilt</td><td>in/out: prebuilt </td></tr>
    <tr><td class="paramname">index_rec</td><td>in: record </td></tr>
    <tr><td class="paramname">index</td><td>in: index of the record </td></tr>
    <tr><td class="paramname">offsets</td><td>in: rec_get_offsets (index_rec, index) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e5ec5c1cf72b61ecffc6a10077b9e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e5ec5c1cf72b61ecffc6a10077b9e0c">&#9670;&nbsp;</a></span>row_sel_test_end_conds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool row_sel_test_end_conds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplan__t.html">plan_t</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests the conditions which determine when the index segment we are searching through has been exhausted. </p>
<dl class="section return"><dt>Returns</dt><dd>true if row passed the tests </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>in: plan for the table; the column values must already have been retrieved and the right sides of comparisons evaluated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab45d63f8767a1d238d6a83ba20030d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab45d63f8767a1d238d6a83ba20030d9d">&#9670;&nbsp;</a></span>row_sel_test_other_conds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool row_sel_test_other_conds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplan__t.html">plan_t</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests the other conditions. </p>
<dl class="section return"><dt>Returns</dt><dd>true if row passed the tests </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>in: plan for the table; the column values must already have been retrieved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afca6a6d16666e6aa78564b2e3c041c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca6a6d16666e6aa78564b2e3c041c90">&#9670;&nbsp;</a></span>row_sel_try_search_shortcut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint row_sel_try_search_shortcut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structplan__t.html">plan_t</a> *&#160;</td>
          <td class="paramname"><em>plan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>search_latch_locked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to do a shortcut to fetch a clustered index record with a unique key, using the hash index if possible (not always). </p>
<dl class="section return"><dt>Returns</dt><dd>SEL_FOUND, SEL_EXHAUSTED, SEL_RETRY </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: trx doing the operation. </td></tr>
    <tr><td class="paramname">node</td><td>in: select node for a consistent read </td></tr>
    <tr><td class="paramname">plan</td><td>in: plan for a unique search in clustered index </td></tr>
    <tr><td class="paramname">search_latch_locked</td><td>in: whether the search holds latch on search system. </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa67d47594f2bf11dfe5e085e0dab2b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa67d47594f2bf11dfe5e085e0dab2b9">&#9670;&nbsp;</a></span>row_sel_try_search_shortcut_for_mysql()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint row_sel_try_search_shortcut_for_mysql </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> **&#160;</td>
          <td class="paramname"><em>out_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structrow__prebuilt__t.html">row_prebuilt_t</a> *&#160;</td>
          <td class="paramname"><em>prebuilt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> **&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tries to do a shortcut to fetch a clustered index record with a unique key, using the hash index if possible (not always). </p>
<p>We assume that the search mode is PAGE_CUR_GE, it is a consistent read, there is a read view in trx, btr search latch has been locked in S-mode if AHI is enabled. </p><dl class="section return"><dt>Returns</dt><dd>SEL_FOUND, SEL_EXHAUSTED, SEL_RETRY </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_rec</td><td>out: record if found </td></tr>
    <tr><td class="paramname">prebuilt</td><td>in: prebuilt struct </td></tr>
    <tr><td class="paramname">offsets</td><td>in/out: for rec_get_offsets(*out_rec) </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: heap for rec_get_offsets() </td></tr>
    <tr><td class="paramname">mtr</td><td>in: started mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e906a9b7458e18363283b109ba79865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e906a9b7458e18363283b109ba79865">&#9670;&nbsp;</a></span>sel_assign_into_var_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void sel_assign_into_var_values </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assigns the values in the select list to the possible into-variables in SELECT ... </p>
<p>INTO ... </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">var</td><td>in: first variable in a list of variables </td></tr>
    <tr><td class="paramname">node</td><td>in: select node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cd568c4b26f7b2aff1eb304c2733a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd568c4b26f7b2aff1eb304c2733a6f">&#9670;&nbsp;</a></span>sel_col_prefetch_buf_alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sel_col_prefetch_buf_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsym__node__t.html">sym_node_t</a> *&#160;</td>
          <td class="paramname"><em>column</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a prefetch buffer for a column when prefetch is first time done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">column</td><td>in: symbol table node for a column </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a315cd18c35a39e3ab7e0b4137330062e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315cd18c35a39e3ab7e0b4137330062e">&#9670;&nbsp;</a></span>sel_col_prefetch_buf_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sel_col_prefetch_buf_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__buf__t.html">sel_buf_t</a> *&#160;</td>
          <td class="paramname"><em>prefetch_buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a prefetch buffer for a column, including the dynamically allocated memory for data stored there. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefetch_buf</td><td>in, own: prefetch buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68d31f6c8c4befd6f11ff69380831784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d31f6c8c4befd6f11ff69380831784">&#9670;&nbsp;</a></span>sel_dequeue_prefetched_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void sel_dequeue_prefetched_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplan__t.html">plan_t</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pops the column values for a prefetched, cached row from the column prefetch buffers and places them to the val fields in the column nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>in: plan node for a table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad14a1423e8ffac387af7cd2ec31f1870"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14a1423e8ffac387af7cd2ec31f1870">&#9670;&nbsp;</a></span>sel_enqueue_prefetched_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void sel_enqueue_prefetched_row </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structplan__t.html">plan_t</a> *&#160;</td>
          <td class="paramname"><em>plan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pushes the column values for a prefetched, cached row to the column prefetch buffers from the val fields in the column nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">plan</td><td>in: plan node for a table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbac18f23c6c2777e4348deb8a43b653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbac18f23c6c2777e4348deb8a43b653">&#9670;&nbsp;</a></span>sel_eval_select_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void sel_eval_select_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the values in a select list. </p>
<p>If there are aggregate functions, their argument value is added to the aggregate total. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: select node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07758ef3ddfed71103ca09905852fa53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07758ef3ddfed71103ca09905852fa53">&#9670;&nbsp;</a></span>sel_node_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsel__node__t.html">sel_node_t</a>* sel_node_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a select node struct. </p>
<dl class="section return"><dt>Returns</dt><dd>own: select node struct </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">heap</td><td>in: memory heap where created </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01de404cd77d6c2b9ccc3b2cd0c8199e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01de404cd77d6c2b9ccc3b2cd0c8199e">&#9670;&nbsp;</a></span>sel_node_free_private()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sel_node_free_private </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory private to a select node when a query graph is freed, does not free the heap where the node was originally created. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: select node struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0d82f18cec6edca4d4a146ee825420d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d82f18cec6edca4d4a146ee825420d">&#9670;&nbsp;</a></span>sel_reset_aggregate_vals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void sel_reset_aggregate_vals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsel__node__t.html">sel_node_t</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the aggregate value totals in the select list of an aggregate type query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>in: select node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61e4a33ed48b323433b9771d21819e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e4a33ed48b323433b9771d21819e20">&#9670;&nbsp;</a></span>sel_restore_position_for_mysql()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool sel_restore_position_for_mysql </td>
          <td>(</td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>same_user_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>moves_up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restores cursor position after it has been stored. </p>
<p>We have to take into account that the record cursor was positioned on may have been deleted. Then we may have to move the cursor one step up or down. </p><dl class="section return"><dt>Returns</dt><dd>true if we may need to process the record the cursor is now positioned on (i.e. we should not go to the next record yet) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">same_user_rec</td><td>out: TRUE if we were able to restore the cursor on a user record with the same ordering prefix in in the B-tree index </td></tr>
    <tr><td class="paramname">latch_mode</td><td>in: latch mode wished in restoration </td></tr>
    <tr><td class="paramname">pcur</td><td>in: cursor whose position has been stored </td></tr>
    <tr><td class="paramname">moves_up</td><td>in: TRUE if the cursor moves up in the index </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr; CAUTION: may commit mtr temporarily! </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8583919bdcf40c9686e654ce8f6dace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8583919bdcf40c9686e654ce8f6dace">&#9670;&nbsp;</a></span>sel_set_rec_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> sel_set_rec_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a>&#160;</td>
          <td class="paramname"><em>sel_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a lock on a record. </p>
<p>mostly due to we cannot reposition a record in R-Tree (with the nature of splitting) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcur</td><td>cursor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sel_mode</td><td>select mode: SELECT_ORDINARY, SELECT_SKIP_LOKCED, or SELECT_NO_WAIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>lock mode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>LOCK_ORDINARY, LOCK_GAP, or LOC_REC_NOT_GAP </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>mtr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, or error code </dd></dl>

</div>
</div>
<a id="a6ba38dae60f42534bf8cd11fa1905a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ba38dae60f42534bf8cd11fa1905a2e">&#9670;&nbsp;</a></span>sel_set_rtr_rec_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> sel_set_rtr_rec_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>first_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lock0types_8h.html#ab5c6ab6fca939782acb38f91e297d41c">select_mode</a>&#160;</td>
          <td class="paramname"><em>sel_mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a lock on a page of R-Tree record. </p>
<p>This is all or none action, mostly due to we cannot reposition a record in R-Tree (with the nature of splitting) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pcur</td><td>cursor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first_rec</td><td>record </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsets</td><td>rec_get_offsets(rec, index) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sel_mode</td><td>select mode: SELECT_ORDINARY, SELECT_SKIP_LOKCED, or SELECT_NO_WAIT </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>lock mode </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>LOCK_ORDINARY, LOCK_GAP, or LOC_REC_NOT_GAP </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thr</td><td>query thread </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>mtr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_SUCCESS_LOCKED_REC, or error code </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_4dd6d22ab21a818a66544a670705c483.html">row</a></li><li class="navelem"><a class="el" href="row0sel_8cc.html">row0sel.cc</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
