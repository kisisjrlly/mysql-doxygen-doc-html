<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: MaterializeIterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classMaterializeIterator.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classMaterializeIterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MaterializeIterator Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Handles materialization; the first call to Init() will scan the given iterator to the end, store the results in a temporary table (optionally with deduplication), and then Read() will allow you to read that table repeatedly without the cost of executing the given subquery many times (unless you ask for rematerialization).  
 <a href="classMaterializeIterator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="composite__iterators_8h_source.html">composite_iterators.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MaterializeIterator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classMaterializeIterator.png" usemap="#MaterializeIterator_map" alt=""/>
  <map id="MaterializeIterator_map" name="MaterializeIterator_map">
<area href="classTableRowIterator.html" alt="TableRowIterator" shape="rect" coords="0,56,114,80"/>
<area href="classRowIterator.html" title="A context for reading through a single table using a chosen access method: index read, scan, etc, use of cache, etc. " alt="RowIterator" shape="rect" coords="0,0,114,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMaterializeIterator_1_1Invalidator.html">Invalidator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMaterializeIterator_1_1QueryBlock.html">QueryBlock</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad14541eb4842dd215cb6f29e48268c5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#ad14541eb4842dd215cb6f29e48268c5b">MaterializeIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>, <a class="el" href="classMem__root__array.html">Mem_root_array</a>&lt; <a class="el" href="structMaterializeIterator_1_1QueryBlock.html">QueryBlock</a> &gt; query_blocks_to_materialize, <a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="classTableRowIterator.html#a5f1d19ba7984ab821a048b6274e712a9">table</a>, <a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt; table_iterator, <a class="el" href="classCommon__table__expr.html">Common_table_expr</a> *cte, <a class="el" href="classSELECT__LEX__UNIT.html">SELECT_LEX_UNIT</a> *unit, <a class="el" href="classJOIN.html">JOIN</a> *join, int ref_slice, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> rematerialize, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> limit_rows, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reject_multiple_rows)</td></tr>
<tr class="separator:ad14541eb4842dd215cb6f29e48268c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f07e23eb7a48b1891e375ecef0ac28a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#a7f07e23eb7a48b1891e375ecef0ac28a">MaterializeIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>, <a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt; subquery_iterator, <a class="el" href="classTemp__table__param.html">Temp_table_param</a> *temp_table_param, <a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="classTableRowIterator.html#a5f1d19ba7984ab821a048b6274e712a9">table</a>, <a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt; table_iterator, <a class="el" href="classCommon__table__expr.html">Common_table_expr</a> *cte, int select_number, <a class="el" href="classSELECT__LEX__UNIT.html">SELECT_LEX_UNIT</a> *unit, <a class="el" href="classJOIN.html">JOIN</a> *join, int ref_slice, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> copy_fields_and_items, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> rematerialize, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> limit_rows, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reject_multiple_rows)</td></tr>
<tr class="memdesc:a7f07e23eb7a48b1891e375ecef0ac28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience form for materializing a single table only.  <a href="#a7f07e23eb7a48b1891e375ecef0ac28a">More...</a><br /></td></tr>
<tr class="separator:a7f07e23eb7a48b1891e375ecef0ac28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ce20c561a845f60ea38a36ccbc1a42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#af1ce20c561a845f60ea38a36ccbc1a42">Init</a> () override</td></tr>
<tr class="memdesc:af1ce20c561a845f60ea38a36ccbc1a42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize or reinitialize the iterator.  <a href="#af1ce20c561a845f60ea38a36ccbc1a42">More...</a><br /></td></tr>
<tr class="separator:af1ce20c561a845f60ea38a36ccbc1a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62a21cd6672854dc7b9c58a6f98effe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#aa62a21cd6672854dc7b9c58a6f98effe">Read</a> () override</td></tr>
<tr class="memdesc:aa62a21cd6672854dc7b9c58a6f98effe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single row.  <a href="#aa62a21cd6672854dc7b9c58a6f98effe">More...</a><br /></td></tr>
<tr class="separator:aa62a21cd6672854dc7b9c58a6f98effe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24308bb40abc0b62de2f98d3d1f242a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#a24308bb40abc0b62de2f98d3d1f242a0">SetNullRowFlag</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_null_row) override</td></tr>
<tr class="memdesc:a24308bb40abc0b62de2f98d3d1f242a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the current row buffer as containing a NULL row or not, so that if you read from it and the flag is true, you'll get only NULLs no matter what is actually in the buffer (typically some old leftover row).  <a href="#a24308bb40abc0b62de2f98d3d1f242a0">More...</a><br /></td></tr>
<tr class="separator:a24308bb40abc0b62de2f98d3d1f242a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127aaf0b59a22ca422f54eea8cede14c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#a127aaf0b59a22ca422f54eea8cede14c">StartPSIBatchMode</a> () override</td></tr>
<tr class="memdesc:a127aaf0b59a22ca422f54eea8cede14c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start performance schema batch mode, if supported (otherwise ignored).  <a href="#a127aaf0b59a22ca422f54eea8cede14c">More...</a><br /></td></tr>
<tr class="separator:a127aaf0b59a22ca422f54eea8cede14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ac441603c6e25d03900837216d9621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#a75ac441603c6e25d03900837216d9621">EndPSIBatchModeIfStarted</a> () override</td></tr>
<tr class="memdesc:a75ac441603c6e25d03900837216d9621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends performance schema batch mode, if started.  <a href="#a75ac441603c6e25d03900837216d9621">More...</a><br /></td></tr>
<tr class="separator:a75ac441603c6e25d03900837216d9621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62653c7b8eb76c998382db6977f0d75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#aa62653c7b8eb76c998382db6977f0d75">UnlockRow</a> () override</td></tr>
<tr class="separator:aa62653c7b8eb76c998382db6977f0d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c985d0a33540c76371d17c1185bbb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#a60c985d0a33540c76371d17c1185bbb2">AddInvalidator</a> (const <a class="el" href="classCacheInvalidatorIterator.html">CacheInvalidatorIterator</a> *invalidator)</td></tr>
<tr class="memdesc:a60c985d0a33540c76371d17c1185bbb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a cache invalidator that must be checked on every Init().  <a href="#a60c985d0a33540c76371d17c1185bbb2">More...</a><br /></td></tr>
<tr class="separator:a60c985d0a33540c76371d17c1185bbb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classTableRowIterator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classTableRowIterator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classTableRowIterator.html">TableRowIterator</a></td></tr>
<tr class="memitem:a6cebbaf17776a508905ab89dda56bb80 inherit pub_methods_classTableRowIterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableRowIterator.html#a6cebbaf17776a508905ab89dda56bb80">TableRowIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>, <a class="el" href="structTABLE.html">TABLE</a> *<a class="el" href="classTableRowIterator.html#a5f1d19ba7984ab821a048b6274e712a9">table</a>)</td></tr>
<tr class="separator:a6cebbaf17776a508905ab89dda56bb80 inherit pub_methods_classTableRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c97ddb280f9183ebf46a9cbcc4a9202 inherit pub_methods_classTableRowIterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableRowIterator.html#a1c97ddb280f9183ebf46a9cbcc4a9202">UnlockRow</a> () override</td></tr>
<tr class="memdesc:a1c97ddb280f9183ebf46a9cbcc4a9202 inherit pub_methods_classTableRowIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">The default implementation of unlock-row method of RowIterator, used in all access methods except EQRefIterator.  <a href="classTableRowIterator.html#a1c97ddb280f9183ebf46a9cbcc4a9202">More...</a><br /></td></tr>
<tr class="separator:a1c97ddb280f9183ebf46a9cbcc4a9202 inherit pub_methods_classTableRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b44792464cb2c5070c1305f121f68a5 inherit pub_methods_classTableRowIterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableRowIterator.html#a8b44792464cb2c5070c1305f121f68a5">SetNullRowFlag</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> is_null_row) override</td></tr>
<tr class="memdesc:a8b44792464cb2c5070c1305f121f68a5 inherit pub_methods_classTableRowIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the current row buffer as containing a NULL row or not, so that if you read from it and the flag is true, you'll get only NULLs no matter what is actually in the buffer (typically some old leftover row).  <a href="classTableRowIterator.html#a8b44792464cb2c5070c1305f121f68a5">More...</a><br /></td></tr>
<tr class="separator:a8b44792464cb2c5070c1305f121f68a5 inherit pub_methods_classTableRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a779598be87550cbb91e8cbb9a6c8ac38 inherit pub_methods_classTableRowIterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableRowIterator.html#a779598be87550cbb91e8cbb9a6c8ac38">StartPSIBatchMode</a> () override</td></tr>
<tr class="memdesc:a779598be87550cbb91e8cbb9a6c8ac38 inherit pub_methods_classTableRowIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start performance schema batch mode, if supported (otherwise ignored).  <a href="classTableRowIterator.html#a779598be87550cbb91e8cbb9a6c8ac38">More...</a><br /></td></tr>
<tr class="separator:a779598be87550cbb91e8cbb9a6c8ac38 inherit pub_methods_classTableRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4eefdbacd421a23d688cc2adab1a3e inherit pub_methods_classTableRowIterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableRowIterator.html#a3e4eefdbacd421a23d688cc2adab1a3e">EndPSIBatchModeIfStarted</a> () override</td></tr>
<tr class="memdesc:a3e4eefdbacd421a23d688cc2adab1a3e inherit pub_methods_classTableRowIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends performance schema batch mode, if started.  <a href="classTableRowIterator.html#a3e4eefdbacd421a23d688cc2adab1a3e">More...</a><br /></td></tr>
<tr class="separator:a3e4eefdbacd421a23d688cc2adab1a3e inherit pub_methods_classTableRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classRowIterator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classRowIterator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classRowIterator.html">RowIterator</a></td></tr>
<tr class="memitem:a9e730a0c6722be2f9841fd6b7a3f6a52 inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#a9e730a0c6722be2f9841fd6b7a3f6a52">RowIterator</a> (<a class="el" href="classTHD.html">THD</a> *<a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a>)</td></tr>
<tr class="separator:a9e730a0c6722be2f9841fd6b7a3f6a52 inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8778b8e93d01e1e47f0e98804882ea8e inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#a8778b8e93d01e1e47f0e98804882ea8e">~RowIterator</a> ()</td></tr>
<tr class="separator:a8778b8e93d01e1e47f0e98804882ea8e inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb75cd99708ea3f1d62b41c8072f1d96 inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#acb75cd99708ea3f1d62b41c8072f1d96">TimingString</a> () const</td></tr>
<tr class="separator:acb75cd99708ea3f1d62b41c8072f1d96 inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c66d3011c7b1be88eead51270c53d74 inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classRowIterator.html">RowIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#a3c66d3011c7b1be88eead51270c53d74">real_iterator</a> ()</td></tr>
<tr class="memdesc:a3c66d3011c7b1be88eead51270c53d74 inherit pub_methods_classRowIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this iterator is wrapping a different iterator (e.g.  <a href="classRowIterator.html#a3c66d3011c7b1be88eead51270c53d74">More...</a><br /></td></tr>
<tr class="separator:a3c66d3011c7b1be88eead51270c53d74 inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0baf633d8ed8803dc77c86a2c9faeda inherit pub_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classRowIterator.html">RowIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#ad0baf633d8ed8803dc77c86a2c9faeda">real_iterator</a> () const</td></tr>
<tr class="separator:ad0baf633d8ed8803dc77c86a2c9faeda inherit pub_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a357a9d0845635b4dd6d83c2a0fdb69bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#a357a9d0845635b4dd6d83c2a0fdb69bd">doing_hash_deduplication</a> () const</td></tr>
<tr class="memdesc:a357a9d0845635b4dd6d83c2a0fdb69bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether we are deduplicating using a hash field on the temporary table.  <a href="#a357a9d0845635b4dd6d83c2a0fdb69bd">More...</a><br /></td></tr>
<tr class="separator:a357a9d0845635b4dd6d83c2a0fdb69bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512587635ac3c98ff2d949794c2277f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#a512587635ac3c98ff2d949794c2277f2">doing_deduplication</a> () const</td></tr>
<tr class="memdesc:a512587635ac3c98ff2d949794c2277f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether we are deduplicating, whether through a hash field or a regular unique index.  <a href="#a512587635ac3c98ff2d949794c2277f2">More...</a><br /></td></tr>
<tr class="separator:a512587635ac3c98ff2d949794c2277f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cbdcf42b0ee3013fa8a57e67792b6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#a91cbdcf42b0ee3013fa8a57e67792b6f">MaterializeRecursive</a> ()</td></tr>
<tr class="memdesc:a91cbdcf42b0ee3013fa8a57e67792b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursive materialization happens much like regular materialization, but some steps are repeated multiple times.  <a href="#a91cbdcf42b0ee3013fa8a57e67792b6f">More...</a><br /></td></tr>
<tr class="separator:a91cbdcf42b0ee3013fa8a57e67792b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fdb0cf5a8fd2a3f2ed1f6f5dacb8be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#ab7fdb0cf5a8fd2a3f2ed1f6f5dacb8be">MaterializeQueryBlock</a> (const <a class="el" href="structMaterializeIterator_1_1QueryBlock.html">QueryBlock</a> &amp;query_block, <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *stored_rows)</td></tr>
<tr class="separator:ab7fdb0cf5a8fd2a3f2ed1f6f5dacb8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a5cab4027acdcfd7b5e557931e55f5734"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMem__root__array.html">Mem_root_array</a>&lt; <a class="el" href="structMaterializeIterator_1_1QueryBlock.html">QueryBlock</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#a5cab4027acdcfd7b5e557931e55f5734">m_query_blocks_to_materialize</a></td></tr>
<tr class="separator:a5cab4027acdcfd7b5e557931e55f5734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722bd788467806c689b1865cbd5b07f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#a722bd788467806c689b1865cbd5b07f7">m_table_iterator</a></td></tr>
<tr class="separator:a722bd788467806c689b1865cbd5b07f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13adf26d4d8ca66d85ed249c2f3c51a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCommon__table__expr.html">Common_table_expr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#a13adf26d4d8ca66d85ed249c2f3c51a0">m_cte</a></td></tr>
<tr class="memdesc:a13adf26d4d8ca66d85ed249c2f3c51a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we are materializing a CTE, points to it (otherwise nullptr).  <a href="#a13adf26d4d8ca66d85ed249c2f3c51a0">More...</a><br /></td></tr>
<tr class="separator:a13adf26d4d8ca66d85ed249c2f3c51a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1769aadcd69c1af06f7981a03fc448e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSELECT__LEX__UNIT.html">SELECT_LEX_UNIT</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#a1769aadcd69c1af06f7981a03fc448e7">m_unit</a></td></tr>
<tr class="memdesc:a1769aadcd69c1af06f7981a03fc448e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The query expression we are materializing.  <a href="#a1769aadcd69c1af06f7981a03fc448e7">More...</a><br /></td></tr>
<tr class="separator:a1769aadcd69c1af06f7981a03fc448e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9783ed1655f8c5e82c239a32675daa23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classJOIN.html">JOIN</a> *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#a9783ed1655f8c5e82c239a32675daa23">m_join</a></td></tr>
<tr class="memdesc:a9783ed1655f8c5e82c239a32675daa23"><td class="mdescLeft">&#160;</td><td class="mdescRight">See constructor.  <a href="#a9783ed1655f8c5e82c239a32675daa23">More...</a><br /></td></tr>
<tr class="separator:a9783ed1655f8c5e82c239a32675daa23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bf347c181919c83f339250b2534bfd"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#ae5bf347c181919c83f339250b2534bfd">m_ref_slice</a></td></tr>
<tr class="memdesc:ae5bf347c181919c83f339250b2534bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The slice to set when accessing temporary table; used if anything upstream (e.g.  <a href="#ae5bf347c181919c83f339250b2534bfd">More...</a><br /></td></tr>
<tr class="separator:ae5bf347c181919c83f339250b2534bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae296ae09644c2fd187633a4175cd2093"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#ae296ae09644c2fd187633a4175cd2093">m_rematerialize</a></td></tr>
<tr class="memdesc:ae296ae09644c2fd187633a4175cd2093"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, we need to materialize anew for each Init() (because the contents of the table will depend on some outer non-constant value).  <a href="#ae296ae09644c2fd187633a4175cd2093">More...</a><br /></td></tr>
<tr class="separator:ae296ae09644c2fd187633a4175cd2093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab874495d31eeb2838091f60f99dcf8a4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#ab874495d31eeb2838091f60f99dcf8a4">m_reject_multiple_rows</a></td></tr>
<tr class="memdesc:ab874495d31eeb2838091f60f99dcf8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">See constructor.  <a href="#ab874495d31eeb2838091f60f99dcf8a4">More...</a><br /></td></tr>
<tr class="separator:ab874495d31eeb2838091f60f99dcf8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272a5f8c0c4273e624dab835dc766991"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#a272a5f8c0c4273e624dab835dc766991">m_limit_rows</a></td></tr>
<tr class="memdesc:a272a5f8c0c4273e624dab835dc766991"><td class="mdescLeft">&#160;</td><td class="mdescRight">See constructor.  <a href="#a272a5f8c0c4273e624dab835dc766991">More...</a><br /></td></tr>
<tr class="separator:a272a5f8c0c4273e624dab835dc766991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985b5522e30f163362cf0853cd424f2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMem__root__array.html">Mem_root_array</a>&lt; <a class="el" href="structMaterializeIterator_1_1Invalidator.html">Invalidator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMaterializeIterator.html#a985b5522e30f163362cf0853cd424f2a">m_invalidators</a></td></tr>
<tr class="separator:a985b5522e30f163362cf0853cd424f2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classTableRowIterator"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classTableRowIterator')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classTableRowIterator.html">TableRowIterator</a></td></tr>
<tr class="memitem:a2781c058240b4ee66675869a8f992cc7 inherit pro_methods_classTableRowIterator"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableRowIterator.html#a2781c058240b4ee66675869a8f992cc7">HandleError</a> (int <a class="el" href="udf__utils_8h.html#a94574db9da98006dc95d6c2fb37c3978acb5e100e5a9a3e7f6d1fd97512215282">error</a>)</td></tr>
<tr class="separator:a2781c058240b4ee66675869a8f992cc7 inherit pro_methods_classTableRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456045aad51c0414e3fee2c5274684cd inherit pro_methods_classTableRowIterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableRowIterator.html#a456045aad51c0414e3fee2c5274684cd">PrintError</a> (int <a class="el" href="udf__utils_8h.html#a94574db9da98006dc95d6c2fb37c3978acb5e100e5a9a3e7f6d1fd97512215282">error</a>)</td></tr>
<tr class="separator:a456045aad51c0414e3fee2c5274684cd inherit pro_methods_classTableRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1d19ba7984ab821a048b6274e712a9 inherit pro_methods_classTableRowIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableRowIterator.html#a5f1d19ba7984ab821a048b6274e712a9">table</a> () const</td></tr>
<tr class="separator:a5f1d19ba7984ab821a048b6274e712a9 inherit pro_methods_classTableRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classRowIterator"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classRowIterator')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classRowIterator.html">RowIterator</a></td></tr>
<tr class="memitem:a2bc0f8df841b7807092480fc1bd0224e inherit pro_methods_classRowIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTHD.html">THD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRowIterator.html#a2bc0f8df841b7807092480fc1bd0224e">thd</a> () const</td></tr>
<tr class="separator:a2bc0f8df841b7807092480fc1bd0224e inherit pro_methods_classRowIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Handles materialization; the first call to Init() will scan the given iterator to the end, store the results in a temporary table (optionally with deduplication), and then Read() will allow you to read that table repeatedly without the cost of executing the given subquery many times (unless you ask for rematerialization). </p>
<p>When materializing, MaterializeIterator takes care of evaluating any items that need so, and storing the results in the fields of the outgoing table &ndash; which items is governed by the temporary table parameters.</p>
<p>Conceptually (although not performance-wise!), the MaterializeIterator is a no-op if you don't ask for deduplication, and in some cases (e.g. when scanning a table only once), we elide it. However, it's not necessarily straightforward to do so by just not inserting the iterator, as the optimizer will have set up everything (e.g., read sets, or what table upstream items will read from) assuming the materialization will happen, so the realistic option is setting up everything as if materialization would happen but not actually write to the table; see StreamingIterator for details.</p>
<p>MaterializeIterator conceptually materializes iterators, not JOINs or SELECT_LEX_UNITs. However, there are many details that leak out (e.g., setting performance schema batch mode, slices, reusing CTEs, etc.), so we need to send them in anyway. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad14541eb4842dd215cb6f29e48268c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14541eb4842dd215cb6f29e48268c5b">&#9670;&nbsp;</a></span>MaterializeIterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MaterializeIterator::MaterializeIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMem__root__array.html">Mem_root_array</a>&lt; <a class="el" href="structMaterializeIterator_1_1QueryBlock.html">QueryBlock</a> &gt;&#160;</td>
          <td class="paramname"><em>query_blocks_to_materialize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt;&#160;</td>
          <td class="paramname"><em>table_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCommon__table__expr.html">Common_table_expr</a> *&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX__UNIT.html">SELECT_LEX_UNIT</a> *&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>rematerialize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td>
          <td class="paramname"><em>limit_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>reject_multiple_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler. </td></tr>
    <tr><td class="paramname">query_blocks_to_materialize</td><td>List of query blocks to materialize. </td></tr>
    <tr><td class="paramname">table</td><td>Handle to table to materialize into. </td></tr>
    <tr><td class="paramname">table_iterator</td><td>Iterator used for scanning the temporary table after materialization. </td></tr>
    <tr><td class="paramname">cte</td><td>If materializing a CTE, points to it (see m_cte), otherwise nullptr. </td></tr>
    <tr><td class="paramname">unit</td><td>The query expression we are materializing (see m_unit). </td></tr>
    <tr><td class="paramname">join</td><td>When materializing within the same JOIN (e.g., into a temporary table before sorting), as opposed to a derived table or a CTE, we may need to change the slice on the join before returning rows from the result table. If so, join and ref_slice would need to be set, and query_blocks_to_materialize should contain only one member, with the same join. </td></tr>
    <tr><td class="paramname">ref_slice</td><td>See join. If we are materializing across JOINs, e.g. derived tables, ref_slice should be left at -1. </td></tr>
    <tr><td class="paramname">rematerialize</td><td>true if rematerializing on every Init() call (e.g., because we have a dependency on a value from outside the query block). </td></tr>
    <tr><td class="paramname">limit_rows</td><td>Used for when pushing LIMIT down to MaterializeIterator; this is more efficient than having a LimitOffsetIterator above the MaterializeIterator, since we can stop materializing when there are enough rows. (This is especially important for recursive CTEs.) Note that we cannot have a LimitOffsetIterator <em>below</em> the MaterializeIterator, as that would count wrong if we have deduplication, and would not work at all for recursive CTEs. Set to HA_POS_ERROR for no limit. </td></tr>
    <tr><td class="paramname">reject_multiple_rows</td><td>true if this is the top level iterator for a materialized derived table transformed from a scalar subquery which needs run-time cardinality check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f07e23eb7a48b1891e375ecef0ac28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f07e23eb7a48b1891e375ecef0ac28a">&#9670;&nbsp;</a></span>MaterializeIterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MaterializeIterator::MaterializeIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTHD.html">THD</a> *&#160;</td>
          <td class="paramname"><em>thd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt;&#160;</td>
          <td class="paramname"><em>subquery_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTemp__table__param.html">Temp_table_param</a> *&#160;</td>
          <td class="paramname"><em>temp_table_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTABLE.html">TABLE</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt; <a class="el" href="classRowIterator.html">RowIterator</a> &gt;&#160;</td>
          <td class="paramname"><em>table_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classCommon__table__expr.html">Common_table_expr</a> *&#160;</td>
          <td class="paramname"><em>cte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>select_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSELECT__LEX__UNIT.html">SELECT_LEX_UNIT</a> *&#160;</td>
          <td class="paramname"><em>unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classJOIN.html">JOIN</a> *&#160;</td>
          <td class="paramname"><em>join</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ref_slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>copy_fields_and_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>rematerialize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a>&#160;</td>
          <td class="paramname"><em>limit_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>reject_multiple_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience form for materializing a single table only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thd</td><td>Thread handler. </td></tr>
    <tr><td class="paramname">subquery_iterator</td><td>The iterator to read the actual rows from. </td></tr>
    <tr><td class="paramname">temp_table_param</td><td>If copy_fields_and_items is true, used for copying the Field objects into the temporary table row. Otherwise unused. </td></tr>
    <tr><td class="paramname">table</td><td>Handle to table to materialize into. </td></tr>
    <tr><td class="paramname">table_iterator</td><td>Iterator used for scanning the temporary table after materialization. </td></tr>
    <tr><td class="paramname">cte</td><td>If materializing a CTE, points to it (see m_cte), otherwise nullptr. </td></tr>
    <tr><td class="paramname">select_number</td><td>Used only for optimizer trace. </td></tr>
    <tr><td class="paramname">unit</td><td>The query expression we are materializing (see m_unit). </td></tr>
    <tr><td class="paramname">join</td><td>When materializing within the same JOIN (e.g., into a temporary table before sorting), as opposed to a derived table or a CTE, we may need to change the slice on the join before returning rows from the result table. If so, join and ref_slice would need to be set, and query_blocks_to_materialize should contain only one member, with the same join. </td></tr>
    <tr><td class="paramname">ref_slice</td><td>See join. If we are materializing across JOINs, e.g. derived tables, ref_slice should be left at -1. </td></tr>
    <tr><td class="paramname">copy_fields_and_items</td><td>If set to false, the Field objects in the output row are presumed already to be filled out. This is the case iff there's an AggregateIterator earlier in the chain. </td></tr>
    <tr><td class="paramname">rematerialize</td><td>true if rematerializing on every Init() call (e.g., because we have a dependency on a value from outside the query block). </td></tr>
    <tr><td class="paramname">limit_rows</td><td>See limit_rows on the other constructor. </td></tr>
    <tr><td class="paramname">reject_multiple_rows</td><td>true if this is the top level iterator for a materialized derived table transformed from a scalar subquery which needs run-time cardinality check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a60c985d0a33540c76371d17c1185bbb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c985d0a33540c76371d17c1185bbb2">&#9670;&nbsp;</a></span>AddInvalidator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MaterializeIterator::AddInvalidator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCacheInvalidatorIterator.html">CacheInvalidatorIterator</a> *&#160;</td>
          <td class="paramname"><em>invalidator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a cache invalidator that must be checked on every Init(). </p>
<p>If its generation has increased since last materialize, we need to rematerialize even if m_rematerialize is false. </p>

</div>
</div>
<a id="a512587635ac3c98ff2d949794c2277f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512587635ac3c98ff2d949794c2277f2">&#9670;&nbsp;</a></span>doing_deduplication()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MaterializeIterator::doing_deduplication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether we are deduplicating, whether through a hash field or a regular unique index. </p>

</div>
</div>
<a id="a357a9d0845635b4dd6d83c2a0fdb69bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357a9d0845635b4dd6d83c2a0fdb69bd">&#9670;&nbsp;</a></span>doing_hash_deduplication()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MaterializeIterator::doing_hash_deduplication </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether we are deduplicating using a hash field on the temporary table. </p>
<p>(This condition mirrors check_unique_constraint().) If so, we compute a hash value for every row, look up all rows with the same hash and manually compare them to the row we are trying to insert.</p>
<p>Note that this is <em>not</em> the common way of deduplicating as we go. The common method is to have a regular index on the table over the right columns, and in that case, ha_write_row() will fail with an ignorable error, so that the row is ignored even though check_unique_constraint() is not called. However, B-tree indexes have limitations, in particular on length, that sometimes require us to do this instead. See create_tmp_table() for details. </p>

</div>
</div>
<a id="a75ac441603c6e25d03900837216d9621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ac441603c6e25d03900837216d9621">&#9670;&nbsp;</a></span>EndPSIBatchModeIfStarted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MaterializeIterator::EndPSIBatchModeIfStarted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ends performance schema batch mode, if started. </p>
<p>It's always safe to call this.</p>
<p>Iterators that have children (composite iterators) must forward the EndPSIBatchModeIfStarted() call to every iterator they could conceivably have called StartPSIBatchMode() on. This ensures that after such a call to on the root iterator, all handlers are out of batch mode. </p>

<p>Reimplemented from <a class="el" href="classRowIterator.html#a9d2300ee51cfa38a5d6bfe0793d12540">RowIterator</a>.</p>

</div>
</div>
<a id="af1ce20c561a845f60ea38a36ccbc1a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ce20c561a845f60ea38a36ccbc1a42">&#9670;&nbsp;</a></span>Init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MaterializeIterator::Init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize or reinitialize the iterator. </p>
<p>You must always call Init() before trying a Read() (but Init() does not imply Read()).</p>
<p>You can call Init() multiple times; subsequent calls will rewind the iterator (or reposition it, depending on whether the iterator takes in e.g. a TABLE_REF) and allow you to read the records anew. </p>

<p>Implements <a class="el" href="classRowIterator.html#affadaf033307f837d0ef187e994f9e28">RowIterator</a>.</p>

</div>
</div>
<a id="ab7fdb0cf5a8fd2a3f2ed1f6f5dacb8be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7fdb0cf5a8fd2a3f2ed1f6f5dacb8be">&#9670;&nbsp;</a></span>MaterializeQueryBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MaterializeIterator::MaterializeQueryBlock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMaterializeIterator_1_1QueryBlock.html">QueryBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>query_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> *&#160;</td>
          <td class="paramname"><em>stored_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a91cbdcf42b0ee3013fa8a57e67792b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91cbdcf42b0ee3013fa8a57e67792b6f">&#9670;&nbsp;</a></span>MaterializeRecursive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MaterializeIterator::MaterializeRecursive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursive materialization happens much like regular materialization, but some steps are repeated multiple times. </p>
<p>Our general strategy is:</p>
<ol type="1">
<li>Materialize all non-recursive query blocks, once.</li>
<li>Materialize all recursive query blocks in turn.</li>
<li>Repeat #2 until no query block writes any more rows (ie., we have converged) &ndash; for UNION DISTINCT queries, rows removed by deduplication do not count. Each materialization sees only rows that were newly added since the previous iteration; see FollowTailIterator for more details on the implementation.</li>
</ol>
<p>Note that the result table is written to while other iterators are still reading from it; again, see FollowTailIterator. This means that each run of #2 can potentially run many actual CTE iterations &ndash; possibly the entire query to completion if we have only one query block.</p>
<p>This is not how the SQL standard specifies recursive CTE execution (it assumes building up the new result set from scratch for each iteration, using the previous iteration's results), but it is equivalent, and more efficient for the class of queries we support, since we don't need to re-create the same rows over and over again. </p>

</div>
</div>
<a id="aa62a21cd6672854dc7b9c58a6f98effe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62a21cd6672854dc7b9c58a6f98effe">&#9670;&nbsp;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MaterializeIterator::Read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a single row. </p>
<p>The row data is not actually returned from the function; it is put in the table's (or tables', in case of a join) record buffer, ie., table-&gt;records[0].</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>OK </td></tr>
    <tr><td class="paramname">-1</td><td>End of records </td></tr>
    <tr><td class="paramname">1</td><td>Error </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classRowIterator.html#adcd98414b1c657236d1156cab8e6e867">RowIterator</a>.</p>

</div>
</div>
<a id="a24308bb40abc0b62de2f98d3d1f242a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24308bb40abc0b62de2f98d3d1f242a0">&#9670;&nbsp;</a></span>SetNullRowFlag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MaterializeIterator::SetNullRowFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>is_null_row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the current row buffer as containing a NULL row or not, so that if you read from it and the flag is true, you'll get only NULLs no matter what is actually in the buffer (typically some old leftover row). </p>
<p>This is used for outer joins, when an iterator hasn't produced any rows and we need to produce a NULL-complemented row. Init() or Read() won't necessarily reset this flag, so if you ever set is to true, make sure to also set it to false when needed.</p>
<p>Note that this can be called without Init() having been called first. For example, NestedLoopIterator can hit EOF immediately on the outer iterator, which means the inner iterator doesn't get an Init() call, but will still forward SetNullRowFlag to both inner and outer iterators.</p>
<p>TODO: We shouldn't need this. See the comments on AggregateIterator for a bit more discussion on abstracting out a row interface. </p>

<p>Implements <a class="el" href="classRowIterator.html#a2fb51c6b0d8b763265d8b20710a31cb1">RowIterator</a>.</p>

</div>
</div>
<a id="a127aaf0b59a22ca422f54eea8cede14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127aaf0b59a22ca422f54eea8cede14c">&#9670;&nbsp;</a></span>StartPSIBatchMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MaterializeIterator::StartPSIBatchMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start performance schema batch mode, if supported (otherwise ignored). </p>
<p>PFS batch mode is a mitigation to reduce the overhead of performance schema, typically applied at the innermost table of the entire join. If you start it before scanning the table and then end it afterwards, the entire set of handler calls will be timed only once, as a group, and the costs will be distributed evenly out. This reduces timer overhead.</p>
<p>If you start PFS batch mode, you must also take care to end it at the end of the scan, one way or the other. Do note that this is true even if the query ends abruptly (LIMIT is reached, or an error happens). The easiest workaround for this is to simply call EndPSIBatchModeIfStarted() on the root iterator at the end of the scan. See the PFSBatchMode class for a useful helper.</p>
<p>The rules for starting batch and ending mode are:</p>
<ol type="1">
<li>If you are an iterator with exactly one child (FilterIterator etc.), forward any StartPSIBatchMode() calls to it.</li>
<li>If you drive an iterator (read rows from it using a for loop or similar), use PFSBatchMode as described above.</li>
<li>If you have multiple children, ignore the call and do your own handling of batch mode as appropriate. For materialization, #2 would typically apply. For joins, it depends on the join type (e.g., NestedLoopIterator applies batch mode only when scanning the innermost table).</li>
</ol>
<p>The upshot of this is that when scanning a single table, batch mode will typically be activated for that table (since we call StartPSIBatchMode() on the root iterator, and it will trickle all the way down to the table iterator), but for a join, the call will be ignored and the join iterator will activate batch mode by itself as needed. </p>

<p>Reimplemented from <a class="el" href="classRowIterator.html#a3c60f99cb3a1bc36776d718636aab5a0">RowIterator</a>.</p>

</div>
</div>
<a id="aa62653c7b8eb76c998382db6977f0d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62653c7b8eb76c998382db6977f0d75">&#9670;&nbsp;</a></span>UnlockRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MaterializeIterator::UnlockRow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classRowIterator.html#a7590a98b54a85d3624cd9667c2da0764">RowIterator</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a13adf26d4d8ca66d85ed249c2f3c51a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13adf26d4d8ca66d85ed249c2f3c51a0">&#9670;&nbsp;</a></span>m_cte</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCommon__table__expr.html">Common_table_expr</a>* MaterializeIterator::m_cte</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If we are materializing a CTE, points to it (otherwise nullptr). </p>
<p>Used so that we see if some other iterator already materialized the table, avoiding duplicate work. </p>

</div>
</div>
<a id="a985b5522e30f163362cf0853cd424f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985b5522e30f163362cf0853cd424f2a">&#9670;&nbsp;</a></span>m_invalidators</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMem__root__array.html">Mem_root_array</a>&lt;<a class="el" href="structMaterializeIterator_1_1Invalidator.html">Invalidator</a>&gt; MaterializeIterator::m_invalidators</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9783ed1655f8c5e82c239a32675daa23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9783ed1655f8c5e82c239a32675daa23">&#9670;&nbsp;</a></span>m_join</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classJOIN.html">JOIN</a>* const MaterializeIterator::m_join</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See constructor. </p>

</div>
</div>
<a id="a272a5f8c0c4273e624dab835dc766991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272a5f8c0c4273e624dab835dc766991">&#9670;&nbsp;</a></span>m_limit_rows</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="my__base_8h.html#a8e16914016eb2acc5eefdbbcad5d9eb5">ha_rows</a> MaterializeIterator::m_limit_rows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See constructor. </p>

</div>
</div>
<a id="a5cab4027acdcfd7b5e557931e55f5734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cab4027acdcfd7b5e557931e55f5734">&#9670;&nbsp;</a></span>m_query_blocks_to_materialize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMem__root__array.html">Mem_root_array</a>&lt;<a class="el" href="structMaterializeIterator_1_1QueryBlock.html">QueryBlock</a>&gt; MaterializeIterator::m_query_blocks_to_materialize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5bf347c181919c83f339250b2534bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bf347c181919c83f339250b2534bfd">&#9670;&nbsp;</a></span>m_ref_slice</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int MaterializeIterator::m_ref_slice</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The slice to set when accessing temporary table; used if anything upstream (e.g. </p>
<p>WHERE, HAVING) wants to evaluate values based on its contents. See constructor. </p>

</div>
</div>
<a id="ab874495d31eeb2838091f60f99dcf8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab874495d31eeb2838091f60f99dcf8a4">&#9670;&nbsp;</a></span>m_reject_multiple_rows</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MaterializeIterator::m_reject_multiple_rows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>See constructor. </p>

</div>
</div>
<a id="ae296ae09644c2fd187633a4175cd2093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae296ae09644c2fd187633a4175cd2093">&#9670;&nbsp;</a></span>m_rematerialize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> MaterializeIterator::m_rematerialize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If true, we need to materialize anew for each Init() (because the contents of the table will depend on some outer non-constant value). </p>

</div>
</div>
<a id="a722bd788467806c689b1865cbd5b07f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722bd788467806c689b1865cbd5b07f7">&#9670;&nbsp;</a></span>m_table_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__alloc_8h.html#aefc3f0449dec4e54570dcfe7f33f23ba">unique_ptr_destroy_only</a>&lt;<a class="el" href="classRowIterator.html">RowIterator</a>&gt; MaterializeIterator::m_table_iterator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1769aadcd69c1af06f7981a03fc448e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1769aadcd69c1af06f7981a03fc448e7">&#9670;&nbsp;</a></span>m_unit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSELECT__LEX__UNIT.html">SELECT_LEX_UNIT</a>* MaterializeIterator::m_unit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The query expression we are materializing. </p>
<p>For derived tables, we materialize the entire query expression; for materialization within a query expression (e.g. for sorting or for windowing functions), we materialize only parts of it. Used to clear correlated CTEs within the unit when we rematerialize, since they depend on values from outside the query expression, and those values may have changed since last materialization. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sql/<a class="el" href="composite__iterators_8h_source.html">composite_iterators.h</a></li>
<li>sql/<a class="el" href="composite__iterators_8cc.html">composite_iterators.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classMaterializeIterator.html">MaterializeIterator</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
