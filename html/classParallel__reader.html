<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: Parallel_reader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classParallel__reader.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classParallel__reader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Parallel_reader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The core idea is to find the left and right paths down the B+Tree.These paths correspond to the scan start and scan end search.  
 <a href="classParallel__reader.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="row0pread_8h_source.html">row0pread.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel__reader_1_1Config.html">Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan (Scan_ctx) configuration.  <a href="structParallel__reader_1_1Config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader_1_1Ctx.html">Ctx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel reader execution context.  <a href="classParallel__reader_1_1Ctx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader_1_1Scan__ctx.html">Scan_ctx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel reader context.  <a href="classParallel__reader_1_1Scan__ctx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel__reader_1_1Scan__range.html">Scan_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the range from where to start the scan and where to end it.  <a href="structParallel__reader_1_1Scan__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParallel__reader_1_1Thread__ctx.html">Thread_ctx</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread related context information.  <a href="structParallel__reader_1_1Thread__ctx.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0af53f22e39d63cdafff80dc8e9ac17d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a0af53f22e39d63cdafff80dc8e9ac17d">Links</a> = std::vector&lt; <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>, <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> &gt; &gt;</td></tr>
<tr class="separator:a0af53f22e39d63cdafff80dc8e9ac17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e9898f005a7e900d0adaf69e1717ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#af2e9898f005a7e900d0adaf69e1717ef">Start</a> = std::function&lt; <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>(<a class="el" href="structParallel__reader_1_1Thread__ctx.html">Thread_ctx</a> *thread_ctx)&gt;</td></tr>
<tr class="memdesc:af2e9898f005a7e900d0adaf69e1717ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to initialise callers state.  <a href="#af2e9898f005a7e900d0adaf69e1717ef">More...</a><br /></td></tr>
<tr class="separator:af2e9898f005a7e900d0adaf69e1717ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051c285f6fcc13a223bd02d5510bef1b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a051c285f6fcc13a223bd02d5510bef1b">Finish</a> = std::function&lt; <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>(<a class="el" href="structParallel__reader_1_1Thread__ctx.html">Thread_ctx</a> *thread_ctx)&gt;</td></tr>
<tr class="memdesc:a051c285f6fcc13a223bd02d5510bef1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to finalise callers state.  <a href="#a051c285f6fcc13a223bd02d5510bef1b">More...</a><br /></td></tr>
<tr class="separator:a051c285f6fcc13a223bd02d5510bef1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb76966c3a4f93141e5c586a98b82845"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#afb76966c3a4f93141e5c586a98b82845">F</a> = std::function&lt; <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>(const <a class="el" href="classParallel__reader_1_1Ctx.html">Ctx</a> *)&gt;</td></tr>
<tr class="memdesc:afb76966c3a4f93141e5c586a98b82845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback to process the rows.  <a href="#afb76966c3a4f93141e5c586a98b82845">More...</a><br /></td></tr>
<tr class="separator:afb76966c3a4f93141e5c586a98b82845"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8eaac4a7ecad850c4f6484ae66484a62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a8eaac4a7ecad850c4f6484ae66484a62">Parallel_reader</a> (size_t <a class="el" href="classParallel__reader.html#a0266efec11fed6770a2b626ad86bb364">max_threads</a>, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sync=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>)</td></tr>
<tr class="memdesc:a8eaac4a7ecad850c4f6484ae66484a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a8eaac4a7ecad850c4f6484ae66484a62">More...</a><br /></td></tr>
<tr class="separator:a8eaac4a7ecad850c4f6484ae66484a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ca1fafc3b84830194d42127405ec9d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#aa8ca1fafc3b84830194d42127405ec9d">~Parallel_reader</a> ()</td></tr>
<tr class="memdesc:aa8ca1fafc3b84830194d42127405ec9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#aa8ca1fafc3b84830194d42127405ec9d">More...</a><br /></td></tr>
<tr class="separator:aa8ca1fafc3b84830194d42127405ec9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278a76d2aaea2adb7e23ff2153662b03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a278a76d2aaea2adb7e23ff2153662b03">fallback_to_single_threaded_mode</a> ()</td></tr>
<tr class="memdesc:a278a76d2aaea2adb7e23ff2153662b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fallback to single threaded mode in case of out of resource issue where extra threads cannot be spawned.  <a href="#a278a76d2aaea2adb7e23ff2153662b03">More...</a><br /></td></tr>
<tr class="separator:a278a76d2aaea2adb7e23ff2153662b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee90a2e6480d39f26848ef8a1fc6cfd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#aee90a2e6480d39f26848ef8a1fc6cfd7">add_scan</a> (<a class="el" href="structtrx__t.html">trx_t</a> *trx, const <a class="el" href="structParallel__reader_1_1Config.html">Config</a> &amp;<a class="el" href="structconfig.html">config</a>, <a class="el" href="classParallel__reader.html#afb76966c3a4f93141e5c586a98b82845">F</a> &amp;&amp;f)</td></tr>
<tr class="memdesc:aee90a2e6480d39f26848ef8a1fc6cfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add scan context.  <a href="#aee90a2e6480d39f26848ef8a1fc6cfd7">More...</a><br /></td></tr>
<tr class="separator:aee90a2e6480d39f26848ef8a1fc6cfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa858156e37c4595e13ea5208a1745eac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#aa858156e37c4595e13ea5208a1745eac">join</a> ()</td></tr>
<tr class="memdesc:aa858156e37c4595e13ea5208a1745eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the join of threads spawned by the parallel reader.  <a href="#aa858156e37c4595e13ea5208a1745eac">More...</a><br /></td></tr>
<tr class="separator:aa858156e37c4595e13ea5208a1745eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eec2f14cea9dbb0eb67313e7069c630"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a5eec2f14cea9dbb0eb67313e7069c630">get_error_state</a> () const</td></tr>
<tr class="memdesc:a5eec2f14cea9dbb0eb67313e7069c630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the error stored in the global error state.  <a href="#a5eec2f14cea9dbb0eb67313e7069c630">More...</a><br /></td></tr>
<tr class="separator:a5eec2f14cea9dbb0eb67313e7069c630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af273cc85341df9b1b7b0351ced9b7745"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#af273cc85341df9b1b7b0351ced9b7745">is_tree_empty</a> () const</td></tr>
<tr class="separator:af273cc85341df9b1b7b0351ced9b7745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aebac31f83bbd6725e78a00b3f0b55f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a7aebac31f83bbd6725e78a00b3f0b55f">set_start_callback</a> (<a class="el" href="classParallel__reader.html#af2e9898f005a7e900d0adaf69e1717ef">Start</a> &amp;&amp;f)</td></tr>
<tr class="memdesc:a7aebac31f83bbd6725e78a00b3f0b55f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback that must be called before any processing.  <a href="#a7aebac31f83bbd6725e78a00b3f0b55f">More...</a><br /></td></tr>
<tr class="separator:a7aebac31f83bbd6725e78a00b3f0b55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1be5c13a4b84071cb11c290887f3806"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#aa1be5c13a4b84071cb11c290887f3806">set_finish_callback</a> (<a class="el" href="classParallel__reader.html#a051c285f6fcc13a223bd02d5510bef1b">Finish</a> &amp;&amp;f)</td></tr>
<tr class="memdesc:aa1be5c13a4b84071cb11c290887f3806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback that must be called after all processing.  <a href="#aa1be5c13a4b84071cb11c290887f3806">More...</a><br /></td></tr>
<tr class="separator:aa1be5c13a4b84071cb11c290887f3806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c908764f85c6d86cf5dccd1de2a56a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a47c908764f85c6d86cf5dccd1de2a56a">run</a> ()</td></tr>
<tr class="memdesc:a47c908764f85c6d86cf5dccd1de2a56a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the threads to do the parallel read for the specified range.  <a href="#a47c908764f85c6d86cf5dccd1de2a56a">More...</a><br /></td></tr>
<tr class="separator:a47c908764f85c6d86cf5dccd1de2a56a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0266efec11fed6770a2b626ad86bb364"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a0266efec11fed6770a2b626ad86bb364">max_threads</a> () const</td></tr>
<tr class="separator:a0266efec11fed6770a2b626ad86bb364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9ea186eeb3dbbb25a2318bcbe4ba25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a7b9ea186eeb3dbbb25a2318bcbe4ba25">is_error_set</a> () const</td></tr>
<tr class="separator:a7b9ea186eeb3dbbb25a2318bcbe4ba25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2370d967a68f4c5621cf0dd107ec05d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#ae2370d967a68f4c5621cf0dd107ec05d">set_error_state</a> (<a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> err)</td></tr>
<tr class="memdesc:ae2370d967a68f4c5621cf0dd107ec05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the error state.  <a href="#ae2370d967a68f4c5621cf0dd107ec05d">More...</a><br /></td></tr>
<tr class="separator:ae2370d967a68f4c5621cf0dd107ec05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f045924b80d2a453ee8cf51c80325f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a5f045924b80d2a453ee8cf51c80325f1">Parallel_reader</a> (const <a class="el" href="classParallel__reader.html">Parallel_reader</a> &amp;)=delete</td></tr>
<tr class="separator:a5f045924b80d2a453ee8cf51c80325f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa18236a6ed4f03653f9c9e95482e91b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#afa18236a6ed4f03653f9c9e95482e91b">Parallel_reader</a> (const <a class="el" href="classParallel__reader.html">Parallel_reader</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:afa18236a6ed4f03653f9c9e95482e91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aaf1913114396b8b65881a0e56ad68a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParallel__reader.html">Parallel_reader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a6aaf1913114396b8b65881a0e56ad68a">operator=</a> (<a class="el" href="classParallel__reader.html">Parallel_reader</a> &amp;&amp;)=delete</td></tr>
<tr class="separator:a6aaf1913114396b8b65881a0e56ad68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82475a49d24a030f64db0369d7626b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParallel__reader.html">Parallel_reader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#af82475a49d24a030f64db0369d7626b1">operator=</a> (const <a class="el" href="classParallel__reader.html">Parallel_reader</a> &amp;)=delete</td></tr>
<tr class="separator:af82475a49d24a030f64db0369d7626b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a053158b2d7cf2d860f1131092bea18bf"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a053158b2d7cf2d860f1131092bea18bf">available_threads</a> (size_t n_required, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> use_reserved=<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a>)</td></tr>
<tr class="memdesc:a053158b2d7cf2d860f1131092bea18bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check how many threads are available for parallel reads.  <a href="#a053158b2d7cf2d860f1131092bea18bf">More...</a><br /></td></tr>
<tr class="separator:a053158b2d7cf2d860f1131092bea18bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9aec47b318d790c5bfe9f6873f6767"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#acf9aec47b318d790c5bfe9f6873f6767">release_threads</a> (size_t n_threads)</td></tr>
<tr class="memdesc:acf9aec47b318d790c5bfe9f6873f6767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release the parallel read threads.  <a href="#acf9aec47b318d790c5bfe9f6873f6767">More...</a><br /></td></tr>
<tr class="separator:acf9aec47b318d790c5bfe9f6873f6767"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a9d613cde4c08c2cf6611b4cb12a78dea"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a9d613cde4c08c2cf6611b4cb12a78dea">MAX_THREADS</a> {256}</td></tr>
<tr class="memdesc:a9d613cde4c08c2cf6611b4cb12a78dea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for innodb-parallel-read-threads.  <a href="#a9d613cde4c08c2cf6611b4cb12a78dea">More...</a><br /></td></tr>
<tr class="separator:a9d613cde4c08c2cf6611b4cb12a78dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc758c5bc9977aa46b404d5c7a54109"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a1fc758c5bc9977aa46b404d5c7a54109">MAX_RESERVED_THREADS</a> {16}</td></tr>
<tr class="memdesc:a1fc758c5bc9977aa46b404d5c7a54109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for reserved parallel read threads for data load so that at least this many threads are always available for data load.  <a href="#a1fc758c5bc9977aa46b404d5c7a54109">More...</a><br /></td></tr>
<tr class="separator:a1fc758c5bc9977aa46b404d5c7a54109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f34983f6131c86c5006ef26c8a8a3d"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a48f34983f6131c86c5006ef26c8a8a3d">MAX_TOTAL_THREADS</a> {<a class="el" href="classParallel__reader.html#a9d613cde4c08c2cf6611b4cb12a78dea">MAX_THREADS</a> + <a class="el" href="classParallel__reader.html#a1fc758c5bc9977aa46b404d5c7a54109">MAX_RESERVED_THREADS</a>}</td></tr>
<tr class="memdesc:a48f34983f6131c86c5006ef26c8a8a3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value for at most number of parallel read threads that can be spawned.  <a href="#a48f34983f6131c86c5006ef26c8a8a3d">More...</a><br /></td></tr>
<tr class="separator:a48f34983f6131c86c5006ef26c8a8a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:acb90480fd7e96259e4b2524502788663"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#acb90480fd7e96259e4b2524502788663">Ctxs</a> = <a class="el" href="test__udf__registration_8cc.html#a96e3cff2f3e1d8eda47115215d03ff32">std::list</a>&lt; std::shared_ptr&lt; <a class="el" href="classParallel__reader_1_1Ctx.html">Ctx</a> &gt;, <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; std::shared_ptr&lt; <a class="el" href="classParallel__reader_1_1Ctx.html">Ctx</a> &gt; &gt;&gt;</td></tr>
<tr class="separator:acb90480fd7e96259e4b2524502788663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb617fe6a4af53646c9ec2624f5b610b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#afb617fe6a4af53646c9ec2624f5b610b">Scan_ctxs</a> = <a class="el" href="test__udf__registration_8cc.html#a96e3cff2f3e1d8eda47115215d03ff32">std::list</a>&lt; std::shared_ptr&lt; <a class="el" href="classParallel__reader_1_1Scan__ctx.html">Scan_ctx</a> &gt;, <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; std::shared_ptr&lt; <a class="el" href="classParallel__reader_1_1Scan__ctx.html">Scan_ctx</a> &gt; &gt;&gt;</td></tr>
<tr class="separator:afb617fe6a4af53646c9ec2624f5b610b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a6480b594572b43b945c0e9b239c32d98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a6480b594572b43b945c0e9b239c32d98">reset_error_state</a> ()</td></tr>
<tr class="memdesc:a6480b594572b43b945c0e9b239c32d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset error state.  <a href="#a6480b594572b43b945c0e9b239c32d98">More...</a><br /></td></tr>
<tr class="separator:a6480b594572b43b945c0e9b239c32d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe818d3231316c9bc5c5ee9046d5dd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a6fe818d3231316c9bc5c5ee9046d5dd9">release_unused_threads</a> (size_t unused_threads)</td></tr>
<tr class="memdesc:a6fe818d3231316c9bc5c5ee9046d5dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Release unused threads back to the pool.  <a href="#a6fe818d3231316c9bc5c5ee9046d5dd9">More...</a><br /></td></tr>
<tr class="separator:a6fe818d3231316c9bc5c5ee9046d5dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad817aa4ae81b2e3d04f49a388abaac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#adad817aa4ae81b2e3d04f49a388abaac">enqueue</a> (std::shared_ptr&lt; <a class="el" href="classParallel__reader_1_1Ctx.html">Ctx</a> &gt; ctx)</td></tr>
<tr class="memdesc:adad817aa4ae81b2e3d04f49a388abaac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an execution context to the run queue.  <a href="#adad817aa4ae81b2e3d04f49a388abaac">More...</a><br /></td></tr>
<tr class="separator:adad817aa4ae81b2e3d04f49a388abaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f826533a7f350a541d4d2f47bf77289"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classParallel__reader_1_1Ctx.html">Ctx</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a6f826533a7f350a541d4d2f47bf77289">dequeue</a> ()</td></tr>
<tr class="memdesc:a6f826533a7f350a541d4d2f47bf77289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fetch the next job execute.  <a href="#a6f826533a7f350a541d4d2f47bf77289">More...</a><br /></td></tr>
<tr class="separator:a6f826533a7f350a541d4d2f47bf77289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258b6462656c79e0e1f05104c789742a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a258b6462656c79e0e1f05104c789742a">is_queue_empty</a> () const</td></tr>
<tr class="separator:a258b6462656c79e0e1f05104c789742a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa374dc865db1941a8b323188b517329f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#aa374dc865db1941a8b323188b517329f">worker</a> (<a class="el" href="structParallel__reader_1_1Thread__ctx.html">Thread_ctx</a> *thread_ctx)</td></tr>
<tr class="memdesc:aa374dc865db1941a8b323188b517329f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Poll for requests and execute.  <a href="#aa374dc865db1941a8b323188b517329f">More...</a><br /></td></tr>
<tr class="separator:aa374dc865db1941a8b323188b517329f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073407f720e44d36a2ac028782044bfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a073407f720e44d36a2ac028782044bfb">parallel_read</a> ()</td></tr>
<tr class="memdesc:a073407f720e44d36a2ac028782044bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the threads and do a parallel read across the partitions.  <a href="#a073407f720e44d36a2ac028782044bfb">More...</a><br /></td></tr>
<tr class="separator:a073407f720e44d36a2ac028782044bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406b831f641d9078b876fc09ae3b2eb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a406b831f641d9078b876fc09ae3b2eb7">is_active</a> () const</td></tr>
<tr class="separator:a406b831f641d9078b876fc09ae3b2eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a609898e47f2e4034bd07c74afe6e7ddb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a609898e47f2e4034bd07c74afe6e7ddb">m_max_threads</a> {}</td></tr>
<tr class="memdesc:a609898e47f2e4034bd07c74afe6e7ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of worker threads to use.  <a href="#a609898e47f2e4034bd07c74afe6e7ddb">More...</a><br /></td></tr>
<tr class="separator:a609898e47f2e4034bd07c74afe6e7ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928ab6f2f454f0e96dd94231a9f39547"><td class="memItemLeft" align="right" valign="top">ib_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a928ab6f2f454f0e96dd94231a9f39547">m_mutex</a></td></tr>
<tr class="memdesc:a928ab6f2f454f0e96dd94231a9f39547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex protecting m_ctxs.  <a href="#a928ab6f2f454f0e96dd94231a9f39547">More...</a><br /></td></tr>
<tr class="separator:a928ab6f2f454f0e96dd94231a9f39547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe27e8648b02b5b574315d3adc16f511"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParallel__reader.html#acb90480fd7e96259e4b2524502788663">Ctxs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#afe27e8648b02b5b574315d3adc16f511">m_ctxs</a> {}</td></tr>
<tr class="memdesc:afe27e8648b02b5b574315d3adc16f511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contexts that must be executed.  <a href="#afe27e8648b02b5b574315d3adc16f511">More...</a><br /></td></tr>
<tr class="separator:afe27e8648b02b5b574315d3adc16f511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83675aeb1ef807dec4d4fdfc25d899bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParallel__reader.html#afb617fe6a4af53646c9ec2624f5b610b">Scan_ctxs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a83675aeb1ef807dec4d4fdfc25d899bc">m_scan_ctxs</a> {}</td></tr>
<tr class="memdesc:a83675aeb1ef807dec4d4fdfc25d899bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan contexts.  <a href="#a83675aeb1ef807dec4d4fdfc25d899bc">More...</a><br /></td></tr>
<tr class="separator:a83675aeb1ef807dec4d4fdfc25d899bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2808f5a9c5ee0e6b6b6f2301b361f78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#ae2808f5a9c5ee0e6b6b6f2301b361f78">m_single_threaded_mode</a> {<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a>}</td></tr>
<tr class="memdesc:ae2808f5a9c5ee0e6b6b6f2301b361f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if we fallback to single threaded mode in case of out of resource issue where extra threads cannot be spawned.  <a href="#ae2808f5a9c5ee0e6b6b6f2301b361f78">More...</a><br /></td></tr>
<tr class="separator:ae2808f5a9c5ee0e6b6b6f2301b361f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fede08924276a63bacf441a078ef84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a73fede08924276a63bacf441a078ef84">m_event</a> {}</td></tr>
<tr class="memdesc:a73fede08924276a63bacf441a078ef84"><td class="mdescLeft">&#160;</td><td class="mdescRight">For signalling worker threads about events.  <a href="#a73fede08924276a63bacf441a078ef84">More...</a><br /></td></tr>
<tr class="separator:a73fede08924276a63bacf441a078ef84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5013ce16300f7ea956acf44f3c2861a4"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a5013ce16300f7ea956acf44f3c2861a4">m_sig_count</a></td></tr>
<tr class="memdesc:a5013ce16300f7ea956acf44f3c2861a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value returned by previous call of os_event_reset() on m_event.  <a href="#a5013ce16300f7ea956acf44f3c2861a4">More...</a><br /></td></tr>
<tr class="separator:a5013ce16300f7ea956acf44f3c2861a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac702c3b792c96c26874f8def5bafc632"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#ac702c3b792c96c26874f8def5bafc632">m_scan_ctx_id</a> {}</td></tr>
<tr class="memdesc:ac702c3b792c96c26874f8def5bafc632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counter for allocating scan context IDs.  <a href="#ac702c3b792c96c26874f8def5bafc632">More...</a><br /></td></tr>
<tr class="separator:ac702c3b792c96c26874f8def5bafc632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2bb04b9dcb721af56306d5d2d33eeda"><td class="memItemLeft" align="right" valign="top">std::atomic_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#af2bb04b9dcb721af56306d5d2d33eeda">m_ctx_id</a> {}</td></tr>
<tr class="memdesc:af2bb04b9dcb721af56306d5d2d33eeda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context ID.  <a href="#af2bb04b9dcb721af56306d5d2d33eeda">More...</a><br /></td></tr>
<tr class="separator:af2bb04b9dcb721af56306d5d2d33eeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a98b4fea535297b2a19a5a1588b713f"><td class="memItemLeft" align="right" valign="top">std::atomic_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a0a98b4fea535297b2a19a5a1588b713f">m_n_completed</a> {}</td></tr>
<tr class="memdesc:a0a98b4fea535297b2a19a5a1588b713f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total tasks executed so far.  <a href="#a0a98b4fea535297b2a19a5a1588b713f">More...</a><br /></td></tr>
<tr class="separator:a0a98b4fea535297b2a19a5a1588b713f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71087a9a2653b9982e0dc423709ea624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParallel__reader.html#af2e9898f005a7e900d0adaf69e1717ef">Start</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a71087a9a2653b9982e0dc423709ea624">m_start_callback</a> {}</td></tr>
<tr class="memdesc:a71087a9a2653b9982e0dc423709ea624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback at start (before processing any rows).  <a href="#a71087a9a2653b9982e0dc423709ea624">More...</a><br /></td></tr>
<tr class="separator:a71087a9a2653b9982e0dc423709ea624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc5a2fb2b301c0f2946880b10d95beb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classParallel__reader.html#a051c285f6fcc13a223bd02d5510bef1b">Finish</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#aabc5a2fb2b301c0f2946880b10d95beb">m_finish_callback</a> {}</td></tr>
<tr class="memdesc:aabc5a2fb2b301c0f2946880b10d95beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback at end (adter processing all rows).  <a href="#aabc5a2fb2b301c0f2946880b10d95beb">More...</a><br /></td></tr>
<tr class="separator:aabc5a2fb2b301c0f2946880b10d95beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5107775cf08354a32f1f47af4e30ab"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a2d5107775cf08354a32f1f47af4e30ab">m_err</a> {<a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654da3a3f63d8e5653727f5af7fdeb326e16d">DB_SUCCESS</a>}</td></tr>
<tr class="memdesc:a2d5107775cf08354a32f1f47af4e30ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error during parallel read.  <a href="#a2d5107775cf08354a32f1f47af4e30ab">More...</a><br /></td></tr>
<tr class="separator:a2d5107775cf08354a32f1f47af4e30ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95bde13017c2826890600b2fa38db65"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIB__thread.html">IB_thread</a>, <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; <a class="el" href="classIB__thread.html">IB_thread</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#ab95bde13017c2826890600b2fa38db65">m_parallel_read_threads</a></td></tr>
<tr class="memdesc:ab95bde13017c2826890600b2fa38db65"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of threads used for paralle_read purpose.  <a href="#ab95bde13017c2826890600b2fa38db65">More...</a><br /></td></tr>
<tr class="separator:ab95bde13017c2826890600b2fa38db65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e73f8aee064d214d9c14e776d8ff50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#a20e73f8aee064d214d9c14e776d8ff50">m_sync</a></td></tr>
<tr class="memdesc:a20e73f8aee064d214d9c14e776d8ff50"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the caller wants to wait for the parallel_read to finish it's run.  <a href="#a20e73f8aee064d214d9c14e776d8ff50">More...</a><br /></td></tr>
<tr class="separator:a20e73f8aee064d214d9c14e776d8ff50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8b70e70aa74143f877230d321c259a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structParallel__reader_1_1Thread__ctx.html">Thread_ctx</a> *, <a class="el" href="classut__allocator.html">ut_allocator</a>&lt; <a class="el" href="structParallel__reader_1_1Thread__ctx.html">Thread_ctx</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#afa8b70e70aa74143f877230d321c259a">m_thread_ctxs</a></td></tr>
<tr class="memdesc:afa8b70e70aa74143f877230d321c259a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context information related to each parallel reader thread.  <a href="#afa8b70e70aa74143f877230d321c259a">More...</a><br /></td></tr>
<tr class="separator:afa8b70e70aa74143f877230d321c259a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:acc45a3bbed019f728c73a2c8c027feec"><td class="memItemLeft" align="right" valign="top">static std::atomic_size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#acc45a3bbed019f728c73a2c8c027feec">s_active_threads</a> {}</td></tr>
<tr class="memdesc:acc45a3bbed019f728c73a2c8c027feec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of threads currently doing parallel reads.  <a href="#acc45a3bbed019f728c73a2c8c027feec">More...</a><br /></td></tr>
<tr class="separator:acc45a3bbed019f728c73a2c8c027feec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa5854a9a6a7320dce15f5ec0a12fc74c"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#aa5854a9a6a7320dce15f5ec0a12fc74c">Ctx</a></td></tr>
<tr class="separator:aa5854a9a6a7320dce15f5ec0a12fc74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ab357c10bafec057067d01034a6a8d"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParallel__reader.html#aa3ab357c10bafec057067d01034a6a8d">Scan_ctx</a></td></tr>
<tr class="separator:aa3ab357c10bafec057067d01034a6a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The core idea is to find the left and right paths down the B+Tree.These paths correspond to the scan start and scan end search. </p>
<p>Follow the links at the appropriate btree level from the left to right and split the scan on each of these sub-tree root nodes.</p>
<p>If the user has set the maximum number of threads to use at say 4 threads and there are 5 sub-trees at the selected level then we will split the 5th sub-tree dynamically when it is ready for scan.</p>
<p>We want to allow multiple parallel range scans on diffrent indexes at the same time. To achieve this split out the scan context (Scan_ctx) from the execution context (Ctx). The Scan_ctx has the index and transaction information and the Ctx keeps track of the cursor for a specific thread during the scan.</p>
<p>To start a scan we need to instantiate a Parallel_reader. A parallel reader can contain several Scan_ctx instances and a Scan_ctx can contain several Ctx instances. Its' the Ctx instances that are eventually executed.</p>
<p>This design allows for a single Parallel_reader to scan multiple indexes at once. Each index range scan has to be added via its add_scan() method. This functionality is required to handle parallel partition scans because partitions are separate indexes. This can be used to scan completely different indexes and tables by one instance of a Parallel_reader.</p>
<p>To solve the imbalance problem we dynamically split the sub-trees as and when required. e.g., If you have 5 sub-trees to scan and 4 threads then it will tag the 5th sub-tree as "to_be_split" during phase I (add_scan()), the first thread that finishes scanning the first set of 4 partitions will then dynamically split the 5th sub-tree and add the newly created sub-trees to the execution context (Ctx) run queue in the Parallel_reader. As the other threads complete their sub-tree scans they will pick up more execution contexts (Ctx) from the Parallel_reader run queue and start scanning the sub-partitions as normal.</p>
<p>Note: The Ctx instances are in a virtual list. Each Ctx instance has a range to scan. The start point of this range instance is the end point of the Ctx instance scanning values less than its start point. A Ctx will scan from [Start, End) rows. We use std::shared_ptr to manage the reference counting, this allows us to dispose of the Ctx instances without worrying about dangling pointers.</p>
<p>NOTE: Secondary index scans are not supported currently. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="acb90480fd7e96259e4b2524502788663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb90480fd7e96259e4b2524502788663">&#9670;&nbsp;</a></span>Ctxs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classParallel__reader.html#acb90480fd7e96259e4b2524502788663">Parallel_reader::Ctxs</a> =  <a class="el" href="test__udf__registration_8cc.html#a96e3cff2f3e1d8eda47115215d03ff32">std::list</a>&lt;std::shared_ptr&lt;<a class="el" href="classParallel__reader_1_1Ctx.html">Ctx</a>&gt;, <a class="el" href="classut__allocator.html">ut_allocator</a>&lt;std::shared_ptr&lt;<a class="el" href="classParallel__reader_1_1Ctx.html">Ctx</a>&gt; &gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb76966c3a4f93141e5c586a98b82845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb76966c3a4f93141e5c586a98b82845">&#9670;&nbsp;</a></span>F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classParallel__reader.html#afb76966c3a4f93141e5c586a98b82845">Parallel_reader::F</a> =  std::function&lt;<a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>(const <a class="el" href="classParallel__reader_1_1Ctx.html">Ctx</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to process the rows. </p>

</div>
</div>
<a id="a051c285f6fcc13a223bd02d5510bef1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051c285f6fcc13a223bd02d5510bef1b">&#9670;&nbsp;</a></span>Finish</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classParallel__reader.html#a051c285f6fcc13a223bd02d5510bef1b">Parallel_reader::Finish</a> =  std::function&lt;<a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>(<a class="el" href="structParallel__reader_1_1Thread__ctx.html">Thread_ctx</a> *thread_ctx)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to finalise callers state. </p>

</div>
</div>
<a id="a0af53f22e39d63cdafff80dc8e9ac17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af53f22e39d63cdafff80dc8e9ac17d">&#9670;&nbsp;</a></span>Links</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classParallel__reader.html#a0af53f22e39d63cdafff80dc8e9ac17d">Parallel_reader::Links</a> =  std::vector&lt;<a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>, <a class="el" href="classut__allocator.html">ut_allocator</a>&lt;<a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb617fe6a4af53646c9ec2624f5b610b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb617fe6a4af53646c9ec2624f5b610b">&#9670;&nbsp;</a></span>Scan_ctxs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classParallel__reader.html#afb617fe6a4af53646c9ec2624f5b610b">Parallel_reader::Scan_ctxs</a> =  <a class="el" href="test__udf__registration_8cc.html#a96e3cff2f3e1d8eda47115215d03ff32">std::list</a>&lt;std::shared_ptr&lt;<a class="el" href="classParallel__reader_1_1Scan__ctx.html">Scan_ctx</a>&gt;, <a class="el" href="classut__allocator.html">ut_allocator</a>&lt;std::shared_ptr&lt;<a class="el" href="classParallel__reader_1_1Scan__ctx.html">Scan_ctx</a>&gt; &gt;&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af2e9898f005a7e900d0adaf69e1717ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e9898f005a7e900d0adaf69e1717ef">&#9670;&nbsp;</a></span>Start</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classParallel__reader.html#af2e9898f005a7e900d0adaf69e1717ef">Parallel_reader::Start</a> =  std::function&lt;<a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>(<a class="el" href="structParallel__reader_1_1Thread__ctx.html">Thread_ctx</a> *thread_ctx)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback to initialise callers state. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8eaac4a7ecad850c4f6484ae66484a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eaac4a7ecad850c4f6484ae66484a62">&#9670;&nbsp;</a></span>Parallel_reader() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Parallel_reader::Parallel_reader </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sync</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">max_threads</td><td>Maximum number of threads to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>true if the read is synchronous </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8ca1fafc3b84830194d42127405ec9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ca1fafc3b84830194d42127405ec9d">&#9670;&nbsp;</a></span>~Parallel_reader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Parallel_reader::~Parallel_reader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a id="a5f045924b80d2a453ee8cf51c80325f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f045924b80d2a453ee8cf51c80325f1">&#9670;&nbsp;</a></span>Parallel_reader() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Parallel_reader::Parallel_reader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParallel__reader.html">Parallel_reader</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa18236a6ed4f03653f9c9e95482e91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa18236a6ed4f03653f9c9e95482e91b">&#9670;&nbsp;</a></span>Parallel_reader() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Parallel_reader::Parallel_reader </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParallel__reader.html">Parallel_reader</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aee90a2e6480d39f26848ef8a1fc6cfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee90a2e6480d39f26848ef8a1fc6cfd7">&#9670;&nbsp;</a></span>add_scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> Parallel_reader::add_scan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structParallel__reader_1_1Config.html">Config</a> &amp;&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classParallel__reader.html#afb76966c3a4f93141e5c586a98b82845">Parallel_reader::F</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add scan context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">trx</td><td>Covering transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Scan condfiguration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Callback function. (default is 0 which is leaf level) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error. </dd></dl>

</div>
</div>
<a id="a053158b2d7cf2d860f1131092bea18bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053158b2d7cf2d860f1131092bea18bf">&#9670;&nbsp;</a></span>available_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Parallel_reader::available_threads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_required</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>use_reserved</em> = <code><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check how many threads are available for parallel reads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n_required</td><td>Number of threads required. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">use_reserved</td><td>true if reserved threads needs to be considered while checking for availability of threads </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of threads available. </dd></dl>

</div>
</div>
<a id="a6f826533a7f350a541d4d2f47bf77289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f826533a7f350a541d4d2f47bf77289">&#9670;&nbsp;</a></span>dequeue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="classParallel__reader_1_1Ctx.html">Parallel_reader::Ctx</a> &gt; Parallel_reader::dequeue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fetch the next job execute. </p>
<dl class="section return"><dt>Returns</dt><dd>job to execute or nullptr. </dd></dl>

</div>
</div>
<a id="adad817aa4ae81b2e3d04f49a388abaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad817aa4ae81b2e3d04f49a388abaac">&#9670;&nbsp;</a></span>enqueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel_reader::enqueue </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classParallel__reader_1_1Ctx.html">Ctx</a> &gt;&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an execution context to the run queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ctx</td><td>Execution context to add to the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a278a76d2aaea2adb7e23ff2153662b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a278a76d2aaea2adb7e23ff2153662b03">&#9670;&nbsp;</a></span>fallback_to_single_threaded_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel_reader::fallback_to_single_threaded_mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fallback to single threaded mode in case of out of resource issue where extra threads cannot be spawned. </p>

</div>
</div>
<a id="a5eec2f14cea9dbb0eb67313e7069c630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eec2f14cea9dbb0eb67313e7069c630">&#9670;&nbsp;</a></span>get_error_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> Parallel_reader::get_error_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the error stored in the global error state. </p>
<dl class="section return"><dt>Returns</dt><dd>global error state. </dd></dl>

</div>
</div>
<a id="a406b831f641d9078b876fc09ae3b2eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406b831f641d9078b876fc09ae3b2eb7">&#9670;&nbsp;</a></span>is_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Parallel_reader::is_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if tasks are still executing. </dd></dl>

</div>
</div>
<a id="a7b9ea186eeb3dbbb25a2318bcbe4ba25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9ea186eeb3dbbb25a2318bcbe4ba25">&#9670;&nbsp;</a></span>is_error_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Parallel_reader::is_error_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if in error state. </dd></dl>

</div>
</div>
<a id="a258b6462656c79e0e1f05104c789742a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258b6462656c79e0e1f05104c789742a">&#9670;&nbsp;</a></span>is_queue_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Parallel_reader::is_queue_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if job queue is empty. </dd></dl>

</div>
</div>
<a id="af273cc85341df9b1b7b0351ced9b7745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af273cc85341df9b1b7b0351ced9b7745">&#9670;&nbsp;</a></span>is_tree_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Parallel_reader::is_tree_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true if the tree is empty, else false. </dd></dl>

</div>
</div>
<a id="aa858156e37c4595e13ea5208a1745eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa858156e37c4595e13ea5208a1745eac">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel_reader::join </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for the join of threads spawned by the parallel reader. </p>

</div>
</div>
<a id="a0266efec11fed6770a2b626ad86bb364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0266efec11fed6770a2b626ad86bb364">&#9670;&nbsp;</a></span>max_threads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t Parallel_reader::max_threads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the configured max threads size. </dd></dl>

</div>
</div>
<a id="a6aaf1913114396b8b65881a0e56ad68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aaf1913114396b8b65881a0e56ad68a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParallel__reader.html">Parallel_reader</a>&amp; Parallel_reader::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParallel__reader.html">Parallel_reader</a> &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af82475a49d24a030f64db0369d7626b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82475a49d24a030f64db0369d7626b1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParallel__reader.html">Parallel_reader</a>&amp; Parallel_reader::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classParallel__reader.html">Parallel_reader</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a073407f720e44d36a2ac028782044bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073407f720e44d36a2ac028782044bfb">&#9670;&nbsp;</a></span>parallel_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel_reader::parallel_read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create the threads and do a parallel read across the partitions. </p>

</div>
</div>
<a id="acf9aec47b318d790c5bfe9f6873f6767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9aec47b318d790c5bfe9f6873f6767">&#9670;&nbsp;</a></span>release_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Parallel_reader::release_threads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release the parallel read threads. </p>

</div>
</div>
<a id="a6fe818d3231316c9bc5c5ee9046d5dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fe818d3231316c9bc5c5ee9046d5dd9">&#9670;&nbsp;</a></span>release_unused_threads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel_reader::release_unused_threads </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unused_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Release unused threads back to the pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">unused_threads</td><td>Number of threads to "release". </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6480b594572b43b945c0e9b239c32d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6480b594572b43b945c0e9b239c32d98">&#9670;&nbsp;</a></span>reset_error_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel_reader::reset_error_state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset error state. </p>

</div>
</div>
<a id="a47c908764f85c6d86cf5dccd1de2a56a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c908764f85c6d86cf5dccd1de2a56a">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> Parallel_reader::run </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the threads to do the parallel read for the specified range. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code. </dd></dl>

</div>
</div>
<a id="ae2370d967a68f4c5621cf0dd107ec05d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2370d967a68f4c5621cf0dd107ec05d">&#9670;&nbsp;</a></span>set_error_state()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel_reader::set_error_state </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td>
          <td class="paramname"><em>err</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the error state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">err</td><td>Error state to set to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1be5c13a4b84071cb11c290887f3806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1be5c13a4b84071cb11c290887f3806">&#9670;&nbsp;</a></span>set_finish_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel_reader::set_finish_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParallel__reader.html#a051c285f6fcc13a223bd02d5510bef1b">Finish</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the callback that must be called after all processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Call after last row is processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7aebac31f83bbd6725e78a00b3f0b55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aebac31f83bbd6725e78a00b3f0b55f">&#9670;&nbsp;</a></span>set_start_callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel_reader::set_start_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParallel__reader.html#af2e9898f005a7e900d0adaf69e1717ef">Start</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the callback that must be called before any processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Call before first row is processed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa374dc865db1941a8b323188b517329f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa374dc865db1941a8b323188b517329f">&#9670;&nbsp;</a></span>worker()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parallel_reader::worker </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structParallel__reader_1_1Thread__ctx.html">Parallel_reader::Thread_ctx</a> *&#160;</td>
          <td class="paramname"><em>thread_ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Poll for requests and execute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread_ctx</td><td>thread related context information </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aa5854a9a6a7320dce15f5ec0a12fc74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5854a9a6a7320dce15f5ec0a12fc74c">&#9670;&nbsp;</a></span>Ctx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classParallel__reader_1_1Ctx.html">Ctx</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3ab357c10bafec057067d01034a6a8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ab357c10bafec057067d01034a6a8d">&#9670;&nbsp;</a></span>Scan_ctx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classParallel__reader_1_1Scan__ctx.html">Scan_ctx</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af2bb04b9dcb721af56306d5d2d33eeda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2bb04b9dcb721af56306d5d2d33eeda">&#9670;&nbsp;</a></span>m_ctx_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic_size_t Parallel_reader::m_ctx_id {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Context ID. </p>
<p>Monotonically increasing ID. </p>

</div>
</div>
<a id="afe27e8648b02b5b574315d3adc16f511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe27e8648b02b5b574315d3adc16f511">&#9670;&nbsp;</a></span>m_ctxs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParallel__reader.html#acb90480fd7e96259e4b2524502788663">Ctxs</a> Parallel_reader::m_ctxs {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contexts that must be executed. </p>

</div>
</div>
<a id="a2d5107775cf08354a32f1f47af4e30ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5107775cf08354a32f1f47af4e30ab">&#9670;&nbsp;</a></span>m_err</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&gt; Parallel_reader::m_err {<a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654da3a3f63d8e5653727f5af7fdeb326e16d">DB_SUCCESS</a>}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Error during parallel read. </p>

</div>
</div>
<a id="a73fede08924276a63bacf441a078ef84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fede08924276a63bacf441a078ef84">&#9670;&nbsp;</a></span>m_event</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="os0event_8h.html#ae24909be432e4a95bd956a707e4d1d20">os_event_t</a> Parallel_reader::m_event {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For signalling worker threads about events. </p>

</div>
</div>
<a id="aabc5a2fb2b301c0f2946880b10d95beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabc5a2fb2b301c0f2946880b10d95beb">&#9670;&nbsp;</a></span>m_finish_callback</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParallel__reader.html#a051c285f6fcc13a223bd02d5510bef1b">Finish</a> Parallel_reader::m_finish_callback {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback at end (adter processing all rows). </p>

</div>
</div>
<a id="a609898e47f2e4034bd07c74afe6e7ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a609898e47f2e4034bd07c74afe6e7ddb">&#9670;&nbsp;</a></span>m_max_threads</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Parallel_reader::m_max_threads {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum number of worker threads to use. </p>

</div>
</div>
<a id="a928ab6f2f454f0e96dd94231a9f39547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928ab6f2f454f0e96dd94231a9f39547">&#9670;&nbsp;</a></span>m_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t Parallel_reader::m_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex protecting m_ctxs. </p>

</div>
</div>
<a id="a0a98b4fea535297b2a19a5a1588b713f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a98b4fea535297b2a19a5a1588b713f">&#9670;&nbsp;</a></span>m_n_completed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic_size_t Parallel_reader::m_n_completed {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Total tasks executed so far. </p>

</div>
</div>
<a id="ab95bde13017c2826890600b2fa38db65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95bde13017c2826890600b2fa38db65">&#9670;&nbsp;</a></span>m_parallel_read_threads</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classIB__thread.html">IB_thread</a>, <a class="el" href="classut__allocator.html">ut_allocator</a>&lt;<a class="el" href="classIB__thread.html">IB_thread</a>&gt; &gt; Parallel_reader::m_parallel_read_threads</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of threads used for paralle_read purpose. </p>

</div>
</div>
<a id="ac702c3b792c96c26874f8def5bafc632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac702c3b792c96c26874f8def5bafc632">&#9670;&nbsp;</a></span>m_scan_ctx_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Parallel_reader::m_scan_ctx_id {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Counter for allocating scan context IDs. </p>

</div>
</div>
<a id="a83675aeb1ef807dec4d4fdfc25d899bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83675aeb1ef807dec4d4fdfc25d899bc">&#9670;&nbsp;</a></span>m_scan_ctxs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParallel__reader.html#afb617fe6a4af53646c9ec2624f5b610b">Scan_ctxs</a> Parallel_reader::m_scan_ctxs {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scan contexts. </p>

</div>
</div>
<a id="a5013ce16300f7ea956acf44f3c2861a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5013ce16300f7ea956acf44f3c2861a4">&#9670;&nbsp;</a></span>m_sig_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t Parallel_reader::m_sig_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value returned by previous call of os_event_reset() on m_event. </p>

</div>
</div>
<a id="ae2808f5a9c5ee0e6b6b6f2301b361f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2808f5a9c5ee0e6b6b6f2301b361f78">&#9670;&nbsp;</a></span>m_single_threaded_mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Parallel_reader::m_single_threaded_mode {<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#a65e9886d74aaee76545e83dd09011727">false</a>}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if we fallback to single threaded mode in case of out of resource issue where extra threads cannot be spawned. </p>

</div>
</div>
<a id="a71087a9a2653b9982e0dc423709ea624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71087a9a2653b9982e0dc423709ea624">&#9670;&nbsp;</a></span>m_start_callback</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classParallel__reader.html#af2e9898f005a7e900d0adaf69e1717ef">Start</a> Parallel_reader::m_start_callback {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Callback at start (before processing any rows). </p>

</div>
</div>
<a id="a20e73f8aee064d214d9c14e776d8ff50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e73f8aee064d214d9c14e776d8ff50">&#9670;&nbsp;</a></span>m_sync</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> Parallel_reader::m_sync</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the caller wants to wait for the parallel_read to finish it's run. </p>

</div>
</div>
<a id="afa8b70e70aa74143f877230d321c259a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa8b70e70aa74143f877230d321c259a">&#9670;&nbsp;</a></span>m_thread_ctxs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structParallel__reader_1_1Thread__ctx.html">Thread_ctx</a> *, <a class="el" href="classut__allocator.html">ut_allocator</a>&lt;<a class="el" href="structParallel__reader_1_1Thread__ctx.html">Thread_ctx</a> *&gt; &gt; Parallel_reader::m_thread_ctxs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Context information related to each parallel reader thread. </p>

</div>
</div>
<a id="a1fc758c5bc9977aa46b404d5c7a54109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fc758c5bc9977aa46b404d5c7a54109">&#9670;&nbsp;</a></span>MAX_RESERVED_THREADS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t Parallel_reader::MAX_RESERVED_THREADS {16}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum value for reserved parallel read threads for data load so that at least this many threads are always available for data load. </p>

</div>
</div>
<a id="a9d613cde4c08c2cf6611b4cb12a78dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d613cde4c08c2cf6611b4cb12a78dea">&#9670;&nbsp;</a></span>MAX_THREADS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t Parallel_reader::MAX_THREADS {256}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum value for innodb-parallel-read-threads. </p>

</div>
</div>
<a id="a48f34983f6131c86c5006ef26c8a8a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f34983f6131c86c5006ef26c8a8a3d">&#9670;&nbsp;</a></span>MAX_TOTAL_THREADS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t Parallel_reader::MAX_TOTAL_THREADS {<a class="el" href="classParallel__reader.html#a9d613cde4c08c2cf6611b4cb12a78dea">MAX_THREADS</a> + <a class="el" href="classParallel__reader.html#a1fc758c5bc9977aa46b404d5c7a54109">MAX_RESERVED_THREADS</a>}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maximum value for at most number of parallel read threads that can be spawned. </p>

</div>
</div>
<a id="acc45a3bbed019f728c73a2c8c027feec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc45a3bbed019f728c73a2c8c027feec">&#9670;&nbsp;</a></span>s_active_threads</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic_size_t Parallel_reader::s_active_threads {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of threads currently doing parallel reads. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>storage/innobase/include/<a class="el" href="row0pread_8h_source.html">row0pread.h</a></li>
<li>storage/innobase/row/<a class="el" href="row0pread_8cc.html">row0pread.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classParallel__reader.html">Parallel_reader</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
