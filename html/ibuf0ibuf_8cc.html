<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MySQL: storage/innobase/ibuf/ibuf0ibuf.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="mysql.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo-mysql-110x55.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MySQL
   &#160;<span id="projectnumber">8.0.22</span>
   </div>
   <div id="projectbrief">Source Code Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('ibuf0ibuf_8cc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ibuf0ibuf.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Insert buffer.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &quot;<a class="el" href="btr0sea_8h_source.html">btr0sea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ha__prototypes_8h_source.html">ha_prototypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ibuf0ibuf_8h_source.html">ibuf0ibuf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sync0sync_8h_source.html">sync0sync.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="my__dbug_8h_source.html">my_dbug.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0btr_8h_source.html">btr0btr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0cur_8h_source.html">btr0cur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="btr0pcur_8h_source.html">btr0pcur.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0buf_8h_source.html">buf0buf.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="buf0rea_8h_source.html">buf0rea.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dict0boot_8h_source.html">dict0boot.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fil0fil_8h_source.html">fil0fil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fsp0fsp_8h_source.html">fsp0fsp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fsp0sysspace_8h_source.html">fsp0sysspace.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fut0lst_8h_source.html">fut0lst.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lock0lock_8h_source.html">lock0lock.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="log0recv_8h_source.html">log0recv.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="que0que_8h_source.html">que0que.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0cmp_8h_source.html">rem0cmp.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rem0rec_8h_source.html">rem0rec.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="row0upd_8h_source.html">row0upd.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="srv0start_8h_source.html">srv0start.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="trx0sys_8h_source.html">trx0sys.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a17808e98a8b20c598184d422c9265ab7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a17808e98a8b20c598184d422c9265ab7">IBUF_BITS_PER_PAGE</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:a17808e98a8b20c598184d422c9265ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bits describing a single page.  <a href="#a17808e98a8b20c598184d422c9265ab7">More...</a><br /></td></tr>
<tr class="separator:a17808e98a8b20c598184d422c9265ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9103d66d35eb0fc3c7dbe33f312fe1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a8d9103d66d35eb0fc3c7dbe33f312fe1">IBUF_BITMAP</a>&#160;&#160;&#160;<a class="el" href="page0types_8h.html#a204eb2227c76883f72599d6cdedd2aee">PAGE_DATA</a></td></tr>
<tr class="memdesc:a8d9103d66d35eb0fc3c7dbe33f312fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The start address for an insert buffer bitmap page bitmap.  <a href="#a8d9103d66d35eb0fc3c7dbe33f312fe1">More...</a><br /></td></tr>
<tr class="separator:a8d9103d66d35eb0fc3c7dbe33f312fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae06bec555ffbe7821e5a38e7360f9e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#aae06bec555ffbe7821e5a38e7360f9e7">IBUF_REC_FIELD_SPACE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:aae06bec555ffbe7821e5a38e7360f9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">in the pre-4.1 format, \ the page number.  <a href="#aae06bec555ffbe7821e5a38e7360f9e7">More...</a><br /></td></tr>
<tr class="separator:aae06bec555ffbe7821e5a38e7360f9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c7c9b80323c3124888a83a9577617a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a62c7c9b80323c3124888a83a9577617a">IBUF_REC_FIELD_MARKER</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a62c7c9b80323c3124888a83a9577617a"><td class="mdescLeft">&#160;</td><td class="mdescRight">starting with 4.1, a marker \ consisting of 1 byte that is 0  <a href="#a62c7c9b80323c3124888a83a9577617a">More...</a><br /></td></tr>
<tr class="separator:a62c7c9b80323c3124888a83a9577617a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c557cef1cf638059f102b2970ebdce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a74c557cef1cf638059f102b2970ebdce">IBUF_REC_FIELD_PAGE</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a74c557cef1cf638059f102b2970ebdce"><td class="mdescLeft">&#160;</td><td class="mdescRight">starting with 4.1, the \ page number  <a href="#a74c557cef1cf638059f102b2970ebdce">More...</a><br /></td></tr>
<tr class="separator:a74c557cef1cf638059f102b2970ebdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad164859cdab41469a353810b2d23996c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#ad164859cdab41469a353810b2d23996c">IBUF_REC_FIELD_METADATA</a>&#160;&#160;&#160;3 /* the <a class="el" href="persisted__variable_8cc.html#a17632c4b396fac52c8df4d4f83af6923">metadata</a> field */</td></tr>
<tr class="separator:ad164859cdab41469a353810b2d23996c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92218dd6ae616a26ff51ea90c76f64aa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a92218dd6ae616a26ff51ea90c76f64aa">IBUF_REC_FIELD_USER</a>&#160;&#160;&#160;4     /* first <a class="el" href="persisted__variable_8cc.html#a8b83cc1a954492359ecbdba847d13e53">user</a> field */</td></tr>
<tr class="separator:a92218dd6ae616a26ff51ea90c76f64aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Offsets to the per-page bits in the insert buffer bitmap</div></td></tr>
<tr class="memitem:a7c1f39462a9aad416f0161cdbbc30a8a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a7c1f39462a9aad416f0161cdbbc30a8a">IBUF_BITMAP_FREE</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a7c1f39462a9aad416f0161cdbbc30a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bits indicating the \ amount of free space.  <a href="#a7c1f39462a9aad416f0161cdbbc30a8a">More...</a><br /></td></tr>
<tr class="separator:a7c1f39462a9aad416f0161cdbbc30a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4819e161ef97e76e73672bc860d655"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a0e4819e161ef97e76e73672bc860d655">IBUF_BITMAP_BUFFERED</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a0e4819e161ef97e76e73672bc860d655"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE if there are buffered \ changes for the page.  <a href="#a0e4819e161ef97e76e73672bc860d655">More...</a><br /></td></tr>
<tr class="separator:a0e4819e161ef97e76e73672bc860d655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1a14e603f223cb79a9468d7c104860"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a8b1a14e603f223cb79a9468d7c104860">IBUF_BITMAP_IBUF</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a8b1a14e603f223cb79a9468d7c104860"><td class="mdescLeft">&#160;</td><td class="mdescRight">TRUE if page is a part of \ the ibuf tree, excluding the \ root page, or is in the free \ list of the ibuf.  <a href="#a8b1a14e603f223cb79a9468d7c104860">More...</a><br /></td></tr>
<tr class="separator:a8b1a14e603f223cb79a9468d7c104860"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a331cbeb660f476370ac711f7b7320e75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a331cbeb660f476370ac711f7b7320e75">srv_ibuf_disable_background_merge</a></td></tr>
<tr class="separator:a331cbeb660f476370ac711f7b7320e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85568eec4e8ee0e177b036e654e8ac71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a85568eec4e8ee0e177b036e654e8ac71">innodb_change_buffering</a> = <a class="el" href="ibuf0ibuf_8h.html#aaee299ba777e430d36fe90fd2ecb54e0a5080241bc703b62ff5e5680dc48d00d5">IBUF_USE_ALL</a></td></tr>
<tr class="memdesc:a85568eec4e8ee0e177b036e654e8ac71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operations that can currently be buffered.  <a href="#a85568eec4e8ee0e177b036e654e8ac71">More...</a><br /></td></tr>
<tr class="separator:a85568eec4e8ee0e177b036e654e8ac71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc741f0194ac361f6ca5c75ac319d92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a2dc741f0194ac361f6ca5c75ac319d92">ibuf_debug</a></td></tr>
<tr class="memdesc:a2dc741f0194ac361f6ca5c75ac319d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to control insert buffer debugging.  <a href="#a2dc741f0194ac361f6ca5c75ac319d92">More...</a><br /></td></tr>
<tr class="separator:a2dc741f0194ac361f6ca5c75ac319d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc138f660c81dccfb4179744e640a50d"><td class="memItemLeft" align="right" valign="top">ibuf_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#acc138f660c81dccfb4179744e640a50d">ibuf</a> = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td></tr>
<tr class="memdesc:acc138f660c81dccfb4179744e640a50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The insert buffer control structure.  <a href="#acc138f660c81dccfb4179744e640a50d">More...</a><br /></td></tr>
<tr class="separator:acc138f660c81dccfb4179744e640a50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Format of the IBUF_REC_FIELD_METADATA of an insert buffer record</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpf7ed454b6e7fbf82e1be7b689d752b2e"></a>The fourth column in the MySQL 5.5 format contains an operation type, counter, and some flags.</p>
</td></tr>
<tr class="memitem:a795987ff8076e14de070c2a454d70664"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a795987ff8076e14de070c2a454d70664">IBUF_REC_INFO_SIZE</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:a795987ff8076e14de070c2a454d70664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combined size of info fields at \ the beginning of the fourth field.  <a href="#a795987ff8076e14de070c2a454d70664">More...</a><br /></td></tr>
<tr class="separator:a795987ff8076e14de070c2a454d70664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413f399b3b0b242113f6aed6dfe6c7e2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a413f399b3b0b242113f6aed6dfe6c7e2">IBUF_REC_OFFSET_COUNTER</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a413f399b3b0b242113f6aed6dfe6c7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation counter.  <a href="#a413f399b3b0b242113f6aed6dfe6c7e2">More...</a><br /></td></tr>
<tr class="separator:a413f399b3b0b242113f6aed6dfe6c7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16288a0096c138b0df79212f6bb88fb8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a16288a0096c138b0df79212f6bb88fb8">IBUF_REC_OFFSET_TYPE</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a16288a0096c138b0df79212f6bb88fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of operation.  <a href="#a16288a0096c138b0df79212f6bb88fb8">More...</a><br /></td></tr>
<tr class="separator:a16288a0096c138b0df79212f6bb88fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492ea64c2d54ba2e17db286440ddebcd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a492ea64c2d54ba2e17db286440ddebcd">IBUF_REC_OFFSET_FLAGS</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a492ea64c2d54ba2e17db286440ddebcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Additional flags.  <a href="#a492ea64c2d54ba2e17db286440ddebcd">More...</a><br /></td></tr>
<tr class="separator:a492ea64c2d54ba2e17db286440ddebcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdab890fac60d88850e79ae98b3524e0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#acdab890fac60d88850e79ae98b3524e0">IBUF_REC_COMPACT</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="memdesc:acdab890fac60d88850e79ae98b3524e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set in \ IBUF_REC_OFFSET_FLAGS if the \ user index is in COMPACT \ format or later.  <a href="#acdab890fac60d88850e79ae98b3524e0">More...</a><br /></td></tr>
<tr class="separator:acdab890fac60d88850e79ae98b3524e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b4b4d8057e074044c7b7d1d1b7ca21"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a84b4b4d8057e074044c7b7d1d1b7ca21">ibuf_bitmap_page_get_bits</a>(<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>,  page_id,  page_size,  bit,  mtr)</td></tr>
<tr class="memdesc:a84b4b4d8057e074044c7b7d1d1b7ca21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the desired bits for a given page from a bitmap page.  <a href="#a84b4b4d8057e074044c7b7d1d1b7ca21">More...</a><br /></td></tr>
<tr class="separator:a84b4b4d8057e074044c7b7d1d1b7ca21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0102886f292905ba29c155e24e3badb4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a0102886f292905ba29c155e24e3badb4">ibuf_bitmap_get_map_page</a>(page_id,  page_size,  mtr)&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#ac35248751026f3714370ee97c3d59e81">ibuf_bitmap_get_map_page_func</a>(page_id, page_size, __FILE__, __LINE__, mtr)</td></tr>
<tr class="memdesc:a0102886f292905ba29c155e24e3badb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ibuf bitmap page where the bits describing a given file page are stored.  <a href="#a0102886f292905ba29c155e24e3badb4">More...</a><br /></td></tr>
<tr class="separator:a0102886f292905ba29c155e24e3badb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fca7d56175dfb2c0c362d31e83e805"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a32fca7d56175dfb2c0c362d31e83e805">ibuf_rec_get_page_no</a>(mtr,  rec)&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#afb0c13f0bc79a9c4d3b7c0cf549a21a3">ibuf_rec_get_page_no_func</a>(mtr, rec)</td></tr>
<tr class="separator:a32fca7d56175dfb2c0c362d31e83e805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a533d7db8eb51b83790a0a65d175b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a93a533d7db8eb51b83790a0a65d175b2">ibuf_rec_get_space</a>(mtr,  rec)&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#ad3f209b632ddd945f888861fccbffc4f">ibuf_rec_get_space_func</a>(mtr, rec)</td></tr>
<tr class="separator:a93a533d7db8eb51b83790a0a65d175b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14427b15c9f8763893a7faf81d3be94"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#af14427b15c9f8763893a7faf81d3be94">ibuf_rec_get_info</a>(mtr,  rec,  op,  comp,  info_len,  <a class="el" href="mysqlimport_8cc.html#ac15184336d5157ee1c2da1b78d0aa343">counter</a>)&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#aaffb8192226fceb60a1ad65ffb0e292c">ibuf_rec_get_info_func</a>(mtr, rec, op, comp, info_len, <a class="el" href="mysqlimport_8cc.html#ac15184336d5157ee1c2da1b78d0aa343">counter</a>)</td></tr>
<tr class="separator:af14427b15c9f8763893a7faf81d3be94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392959af1347659b86825ef81c30c6f2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a392959af1347659b86825ef81c30c6f2">ibuf_rec_get_op_type</a>(mtr,  rec)&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#a47a6081aec3b583cad21368758e5fb28">ibuf_rec_get_op_type_func</a>(mtr, rec)</td></tr>
<tr class="separator:a392959af1347659b86825ef81c30c6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7df5e3277df1e00e035a79f2f225cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#abd7df5e3277df1e00e035a79f2f225cb">ibuf_build_entry_from_ibuf_rec</a>(mtr,  ibuf_rec,  heap,  pindex)&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#a3b5bd1833b7e52a65481a65faf85671e">ibuf_build_entry_from_ibuf_rec_func</a>(mtr, ibuf_rec, heap, pindex)</td></tr>
<tr class="separator:abd7df5e3277df1e00e035a79f2f225cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ae4e80d89acb30784c575c96b96ede"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a48ae4e80d89acb30784c575c96b96ede">ibuf_rec_get_volume</a>(mtr,  rec)&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#a18f40a7ec90f149244bbfe95c8fc2137">ibuf_rec_get_volume_func</a>(mtr, rec)</td></tr>
<tr class="separator:a48ae4e80d89acb30784c575c96b96ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53cb04f2c2f8c9b83d327bf8b6a3b35"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#af53cb04f2c2f8c9b83d327bf8b6a3b35">ibuf_get_merge_page_nos</a>(contract,  rec,  mtr,  ids,  pages,  n_stored)&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#a44ef4556f064501b89e6192320d80b14">ibuf_get_merge_page_nos_func</a>(contract, rec, mtr, ids, pages, n_stored)</td></tr>
<tr class="separator:af53cb04f2c2f8c9b83d327bf8b6a3b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac419ae0d7d2d2c22fc453c7e17905c65"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#ac419ae0d7d2d2c22fc453c7e17905c65">ibuf_get_volume_buffered_count</a>(mtr,  rec,  <a class="el" href="innodb__memcache_2cache-src_2hash_8h.html#a1c12edaae63f2e86a5b276a18475f863">hash</a>,  size,  n_recs)&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#abbef0dffd86255a66dc584c75cccbfc7">ibuf_get_volume_buffered_count_func</a>(mtr, rec, <a class="el" href="innodb__memcache_2cache-src_2hash_8h.html#a1c12edaae63f2e86a5b276a18475f863">hash</a>, size, n_recs)</td></tr>
<tr class="separator:ac419ae0d7d2d2c22fc453c7e17905c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562a1bb33b1d1a69bd2809917ac269ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a562a1bb33b1d1a69bd2809917ac269ee">ibuf_get_entry_counter_low</a>(mtr,  rec,  space,  page_no)&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#aa38f23e667b7b426fa1213ae45d95990">ibuf_get_entry_counter_low_func</a>(mtr, rec, space, page_no)</td></tr>
<tr class="separator:a562a1bb33b1d1a69bd2809917ac269ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089b2d45875fa59b5fe800366aec2a98"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a089b2d45875fa59b5fe800366aec2a98">ibuf_get_entry_counter</a>(space,  page_no,  rec,  mtr,  exact_leaf)&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#a4192f98ff206c7d4925386cca3cc3c18">ibuf_get_entry_counter_func</a>(space, page_no, rec, mtr, exact_leaf)</td></tr>
<tr class="separator:a089b2d45875fa59b5fe800366aec2a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd85f1f591eddefcd597b102649b3e94"><td class="memItemLeft" align="right" valign="top">static ib_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#abd85f1f591eddefcd597b102649b3e94">ibuf_pessimistic_insert_mutex</a></td></tr>
<tr class="memdesc:abd85f1f591eddefcd597b102649b3e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mutex used to block pessimistic inserts to ibuf trees.  <a href="#abd85f1f591eddefcd597b102649b3e94">More...</a><br /></td></tr>
<tr class="separator:abd85f1f591eddefcd597b102649b3e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b2e6051ea83358e3fd922aab96bacb"><td class="memItemLeft" align="right" valign="top">static ib_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a81b2e6051ea83358e3fd922aab96bacb">ibuf_mutex</a></td></tr>
<tr class="memdesc:a81b2e6051ea83358e3fd922aab96bacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mutex protecting the insert buffer structs.  <a href="#a81b2e6051ea83358e3fd922aab96bacb">More...</a><br /></td></tr>
<tr class="separator:a81b2e6051ea83358e3fd922aab96bacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae503e7c47210cc6888ebe98e160a114c"><td class="memItemLeft" align="right" valign="top">static ib_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#ae503e7c47210cc6888ebe98e160a114c">ibuf_bitmap_mutex</a></td></tr>
<tr class="memdesc:ae503e7c47210cc6888ebe98e160a114c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The mutex protecting the insert buffer bitmaps.  <a href="#ae503e7c47210cc6888ebe98e160a114c">More...</a><br /></td></tr>
<tr class="separator:ae503e7c47210cc6888ebe98e160a114c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523cdb37299ccf373906c7e19d4ac26b"><td class="memItemLeft" align="right" valign="top">const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a523cdb37299ccf373906c7e19d4ac26b">IBUF_MERGE_AREA</a> = 8</td></tr>
<tr class="memdesc:a523cdb37299ccf373906c7e19d4ac26b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The area in pages from which contract looks for page numbers for merge.  <a href="#a523cdb37299ccf373906c7e19d4ac26b">More...</a><br /></td></tr>
<tr class="separator:a523cdb37299ccf373906c7e19d4ac26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5faeabeebb7a4a74ecf25f36ee354da"><td class="memItemLeft" align="right" valign="top">const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#ab5faeabeebb7a4a74ecf25f36ee354da">IBUF_MERGE_THRESHOLD</a> = 4</td></tr>
<tr class="memdesc:ab5faeabeebb7a4a74ecf25f36ee354da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inside the merge area, pages which have at most 1 per this number less buffered entries compared to maximum volume that can buffered for a single page are merged along with the page whose buffer became full.  <a href="#ab5faeabeebb7a4a74ecf25f36ee354da">More...</a><br /></td></tr>
<tr class="separator:ab5faeabeebb7a4a74ecf25f36ee354da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f30ffcb65b17eb8ca32b907b0bf3b6"><td class="memItemLeft" align="right" valign="top">const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a90f30ffcb65b17eb8ca32b907b0bf3b6">IBUF_MAX_N_PAGES_MERGED</a> = <a class="el" href="ibuf0ibuf_8cc.html#a523cdb37299ccf373906c7e19d4ac26b">IBUF_MERGE_AREA</a></td></tr>
<tr class="memdesc:a90f30ffcb65b17eb8ca32b907b0bf3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">In ibuf_contract at most this number of pages is read to memory in one batch, in order to merge the entries for them in the insert buffer.  <a href="#a90f30ffcb65b17eb8ca32b907b0bf3b6">More...</a><br /></td></tr>
<tr class="separator:a90f30ffcb65b17eb8ca32b907b0bf3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b7f0ba72053cd9b7cb46bbdc2f5676"><td class="memItemLeft" align="right" valign="top">const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#af1b7f0ba72053cd9b7cb46bbdc2f5676">IBUF_CONTRACT_ON_INSERT_NON_SYNC</a> = 0</td></tr>
<tr class="memdesc:af1b7f0ba72053cd9b7cb46bbdc2f5676"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the combined size of the ibuf trees exceeds ibuf-&gt;max_size by this many pages, we start to contract it in connection to inserts there, using non-synchronous contract.  <a href="#af1b7f0ba72053cd9b7cb46bbdc2f5676">More...</a><br /></td></tr>
<tr class="separator:af1b7f0ba72053cd9b7cb46bbdc2f5676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d441560d233aba40ee87c6dfcf7e4a"><td class="memItemLeft" align="right" valign="top">const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a28d441560d233aba40ee87c6dfcf7e4a">IBUF_CONTRACT_ON_INSERT_SYNC</a> = 5</td></tr>
<tr class="memdesc:a28d441560d233aba40ee87c6dfcf7e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the combined size of the ibuf trees exceeds ibuf-&gt;max_size by this many pages, we start to contract it in connection to inserts there, using synchronous contract.  <a href="#a28d441560d233aba40ee87c6dfcf7e4a">More...</a><br /></td></tr>
<tr class="separator:a28d441560d233aba40ee87c6dfcf7e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51df412c1f9e8c379dc45c0c75c60e27"><td class="memItemLeft" align="right" valign="top">const ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a51df412c1f9e8c379dc45c0c75c60e27">IBUF_CONTRACT_DO_NOT_INSERT</a> = 10</td></tr>
<tr class="memdesc:a51df412c1f9e8c379dc45c0c75c60e27"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the combined size of the ibuf trees exceeds ibuf-&gt;max_size by this many pages, we start to contract it synchronous contract, but do not insert.  <a href="#a51df412c1f9e8c379dc45c0c75c60e27">More...</a><br /></td></tr>
<tr class="separator:a51df412c1f9e8c379dc45c0c75c60e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83e6df705b87c1a60cb5b288e5ba221"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#ae83e6df705b87c1a60cb5b288e5ba221">ibuf_enter</a> (<a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ae83e6df705b87c1a60cb5b288e5ba221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the flag in the current mini-transaction record indicating we're inside an insert buffer routine.  <a href="#ae83e6df705b87c1a60cb5b288e5ba221">More...</a><br /></td></tr>
<tr class="separator:ae83e6df705b87c1a60cb5b288e5ba221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88081990d05b0e3ca5b7d47e577a69b3"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a88081990d05b0e3ca5b7d47e577a69b3">ibuf_exit</a> (<a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a88081990d05b0e3ca5b7d47e577a69b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the flag in the current mini-transaction record indicating we're exiting an insert buffer routine.  <a href="#a88081990d05b0e3ca5b7d47e577a69b3">More...</a><br /></td></tr>
<tr class="separator:a88081990d05b0e3ca5b7d47e577a69b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe02a85792977a0e5817100d58368c0"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#abbe02a85792977a0e5817100d58368c0">ibuf_btr_pcur_commit_specify_mtr</a> (<a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:abbe02a85792977a0e5817100d58368c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commits an insert buffer mini-transaction and sets the persistent cursor latch mode to BTR_NO_LATCHES, that is, detaches the cursor.  <a href="#abbe02a85792977a0e5817100d58368c0">More...</a><br /></td></tr>
<tr class="separator:abbe02a85792977a0e5817100d58368c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ea9526304807774ce29c698d623580"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#ad9ea9526304807774ce29c698d623580">ibuf_header_page_get</a> (<a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ad9ea9526304807774ce29c698d623580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ibuf header page and x-latches it.  <a href="#ad9ea9526304807774ce29c698d623580">More...</a><br /></td></tr>
<tr class="separator:ad9ea9526304807774ce29c698d623580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093e4377121e636de579e5053e4369cc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a093e4377121e636de579e5053e4369cc">ibuf_tree_root_get</a> (<a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a093e4377121e636de579e5053e4369cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the root page and sx-latches it.  <a href="#a093e4377121e636de579e5053e4369cc">More...</a><br /></td></tr>
<tr class="separator:a093e4377121e636de579e5053e4369cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92f84210db9d5f5058837d846310617"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#af92f84210db9d5f5058837d846310617">ibuf_close</a> (void)</td></tr>
<tr class="memdesc:af92f84210db9d5f5058837d846310617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes insert buffer and frees the data structures.  <a href="#af92f84210db9d5f5058837d846310617">More...</a><br /></td></tr>
<tr class="separator:af92f84210db9d5f5058837d846310617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db9ba14887bee3c7f73289c8115849f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a6db9ba14887bee3c7f73289c8115849f">ibuf_size_update</a> (const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *root)</td></tr>
<tr class="memdesc:a6db9ba14887bee3c7f73289c8115849f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the size information of the ibuf, assuming the segment size has not changed.  <a href="#a6db9ba14887bee3c7f73289c8115849f">More...</a><br /></td></tr>
<tr class="separator:a6db9ba14887bee3c7f73289c8115849f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e48beeba32c00c6843836063eba6d57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a3e48beeba32c00c6843836063eba6d57">ibuf_init_at_db_start</a> (void)</td></tr>
<tr class="memdesc:a3e48beeba32c00c6843836063eba6d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the insert buffer data structure at a database startup and initializes the data structures for the insert buffer.  <a href="#a3e48beeba32c00c6843836063eba6d57">More...</a><br /></td></tr>
<tr class="separator:a3e48beeba32c00c6843836063eba6d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a2e5e0dc11ead78fff74deecf3aa8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a57a2e5e0dc11ead78fff74deecf3aa8e">ibuf_max_size_update</a> (ulint new_val)</td></tr>
<tr class="memdesc:a57a2e5e0dc11ead78fff74deecf3aa8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the max_size value for ibuf.  <a href="#a57a2e5e0dc11ead78fff74deecf3aa8e">More...</a><br /></td></tr>
<tr class="separator:a57a2e5e0dc11ead78fff74deecf3aa8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1ad625b86b7d790d3a81d3b07a188a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#aae1ad625b86b7d790d3a81d3b07a188a">ibuf_bitmap_page_init</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aae1ad625b86b7d790d3a81d3b07a188a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an ibuf bitmap page.  <a href="#aae1ad625b86b7d790d3a81d3b07a188a">More...</a><br /></td></tr>
<tr class="separator:aae1ad625b86b7d790d3a81d3b07a188a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311721976f8324336bb73f36f36cf7a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a311721976f8324336bb73f36f36cf7a9">ibuf_parse_bitmap_init</a> (<a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *ptr, <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *end_ptr, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a311721976f8324336bb73f36f36cf7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a redo log record of an ibuf bitmap page init.  <a href="#a311721976f8324336bb73f36f36cf7a9">More...</a><br /></td></tr>
<tr class="separator:a311721976f8324336bb73f36f36cf7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30dc465081bffe82e76883e8a1c7a93c"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a30dc465081bffe82e76883e8a1c7a93c">ibuf_bitmap_page_get_bits_low</a> (const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, ulint latch_type, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, ulint bit)</td></tr>
<tr class="memdesc:a30dc465081bffe82e76883e8a1c7a93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the desired bits for a given page from a bitmap page.  <a href="#a30dc465081bffe82e76883e8a1c7a93c">More...</a><br /></td></tr>
<tr class="separator:a30dc465081bffe82e76883e8a1c7a93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223980b54495092f6fdcfc554f956630"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a223980b54495092f6fdcfc554f956630">ibuf_bitmap_page_set_bits</a> (<a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *<a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, ulint bit, ulint val, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a223980b54495092f6fdcfc554f956630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the desired bit for a given page in a bitmap page.  <a href="#a223980b54495092f6fdcfc554f956630">More...</a><br /></td></tr>
<tr class="separator:a223980b54495092f6fdcfc554f956630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dec8fa240b0af706d7a8df85f97496"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE const <a class="el" href="classpage__id__t.html">page_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a56dec8fa240b0af706d7a8df85f97496">ibuf_bitmap_page_no_calc</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size)</td></tr>
<tr class="memdesc:a56dec8fa240b0af706d7a8df85f97496"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the bitmap page number for a given page number.  <a href="#a56dec8fa240b0af706d7a8df85f97496">More...</a><br /></td></tr>
<tr class="separator:a56dec8fa240b0af706d7a8df85f97496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35248751026f3714370ee97c3d59e81"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#ac35248751026f3714370ee97c3d59e81">ibuf_bitmap_get_map_page_func</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ac35248751026f3714370ee97c3d59e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ibuf bitmap page where the bits describing a given file page are stored.  <a href="#ac35248751026f3714370ee97c3d59e81">More...</a><br /></td></tr>
<tr class="separator:ac35248751026f3714370ee97c3d59e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad182ff93c99b4fd4fdcc7bb01e08920"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#aad182ff93c99b4fd4fdcc7bb01e08920">ibuf_set_free_bits_low</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint val, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aad182ff93c99b4fd4fdcc7bb01e08920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the free bits of the page in the ibuf bitmap.  <a href="#aad182ff93c99b4fd4fdcc7bb01e08920">More...</a><br /></td></tr>
<tr class="separator:aad182ff93c99b4fd4fdcc7bb01e08920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2efdf8e91e2ceae7820cfa3196aa3c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#aa2efdf8e91e2ceae7820cfa3196aa3c2">ibuf_set_free_bits_func</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint val)</td></tr>
<tr class="memdesc:aa2efdf8e91e2ceae7820cfa3196aa3c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the free bit of the page in the ibuf bitmap.  <a href="#aa2efdf8e91e2ceae7820cfa3196aa3c2">More...</a><br /></td></tr>
<tr class="separator:aa2efdf8e91e2ceae7820cfa3196aa3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70b118022336ffdce6188d3582b8460"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#ad70b118022336ffdce6188d3582b8460">ibuf_reset_free_bits</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block)</td></tr>
<tr class="memdesc:ad70b118022336ffdce6188d3582b8460"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the free bits of the page in the ibuf bitmap.  <a href="#ad70b118022336ffdce6188d3582b8460">More...</a><br /></td></tr>
<tr class="separator:ad70b118022336ffdce6188d3582b8460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5134025f7c9d02218eff1f7f9303b912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a5134025f7c9d02218eff1f7f9303b912">ibuf_update_free_bits_low</a> (const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, ulint max_ins_size, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a5134025f7c9d02218eff1f7f9303b912"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the free bits for an uncompressed page to reflect the present state.  <a href="#a5134025f7c9d02218eff1f7f9303b912">More...</a><br /></td></tr>
<tr class="separator:a5134025f7c9d02218eff1f7f9303b912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d5afb4398250d474837a0493aa419f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#ab6d5afb4398250d474837a0493aa419f">ibuf_update_free_bits_zip</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ab6d5afb4398250d474837a0493aa419f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the free bits for a compressed page to reflect the present state.  <a href="#ab6d5afb4398250d474837a0493aa419f">More...</a><br /></td></tr>
<tr class="separator:ab6d5afb4398250d474837a0493aa419f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9078834fb41a289c431d7ad15ae76c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#aa9078834fb41a289c431d7ad15ae76c9">ibuf_update_free_bits_for_two_pages_low</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block1, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block2, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:aa9078834fb41a289c431d7ad15ae76c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the free bits for the two pages to reflect the present state.  <a href="#aa9078834fb41a289c431d7ad15ae76c9">More...</a><br /></td></tr>
<tr class="separator:aa9078834fb41a289c431d7ad15ae76c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee79c09530b7b843a05694f37f4b618"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a9ee79c09530b7b843a05694f37f4b618">ibuf_fixed_addr_page</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size)</td></tr>
<tr class="memdesc:a9ee79c09530b7b843a05694f37f4b618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns TRUE if the page is one of the fixed address ibuf pages.  <a href="#a9ee79c09530b7b843a05694f37f4b618">More...</a><br /></td></tr>
<tr class="separator:a9ee79c09530b7b843a05694f37f4b618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e38f2eaacffba888471173d6a900b00"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a3e38f2eaacffba888471173d6a900b00">ibuf_page_low</a> (const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, ibool x_latch, const char *file, ulint line, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a3e38f2eaacffba888471173d6a900b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a page is a level 2 or 3 page in the ibuf hierarchy of pages.  <a href="#a3e38f2eaacffba888471173d6a900b00">More...</a><br /></td></tr>
<tr class="separator:a3e38f2eaacffba888471173d6a900b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0c13f0bc79a9c4d3b7c0cf549a21a3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#afb0c13f0bc79a9c4d3b7c0cf549a21a3">ibuf_rec_get_page_no_func</a> (<a class="el" href="structmtr__t.html">mtr_t</a> *mtr, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec)</td></tr>
<tr class="memdesc:afb0c13f0bc79a9c4d3b7c0cf549a21a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the page number field of an ibuf record.  <a href="#afb0c13f0bc79a9c4d3b7c0cf549a21a3">More...</a><br /></td></tr>
<tr class="separator:afb0c13f0bc79a9c4d3b7c0cf549a21a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f209b632ddd945f888861fccbffc4f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#ad3f209b632ddd945f888861fccbffc4f">ibuf_rec_get_space_func</a> (<a class="el" href="structmtr__t.html">mtr_t</a> *mtr, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec)</td></tr>
<tr class="memdesc:ad3f209b632ddd945f888861fccbffc4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the space id field of an ibuf record.  <a href="#ad3f209b632ddd945f888861fccbffc4f">More...</a><br /></td></tr>
<tr class="separator:ad3f209b632ddd945f888861fccbffc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaffb8192226fceb60a1ad65ffb0e292c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#aaffb8192226fceb60a1ad65ffb0e292c">ibuf_rec_get_info_func</a> (<a class="el" href="structmtr__t.html">mtr_t</a> *mtr, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="ibuf0ibuf_8h.html#ae8116a402f0f6229af7671129bfab686">ibuf_op_t</a> *op, ibool *comp, ulint *info_len, ulint *<a class="el" href="mysqlimport_8cc.html#ac15184336d5157ee1c2da1b78d0aa343">counter</a>)</td></tr>
<tr class="memdesc:aaffb8192226fceb60a1ad65ffb0e292c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get various information about an ibuf record in &gt;= 4.1.x format.  <a href="#aaffb8192226fceb60a1ad65ffb0e292c">More...</a><br /></td></tr>
<tr class="separator:aaffb8192226fceb60a1ad65ffb0e292c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a6081aec3b583cad21368758e5fb28"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="ibuf0ibuf_8h.html#ae8116a402f0f6229af7671129bfab686">ibuf_op_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a47a6081aec3b583cad21368758e5fb28">ibuf_rec_get_op_type_func</a> (<a class="el" href="structmtr__t.html">mtr_t</a> *mtr, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec)</td></tr>
<tr class="memdesc:a47a6081aec3b583cad21368758e5fb28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the operation type field of an ibuf record.  <a href="#a47a6081aec3b583cad21368758e5fb28">More...</a><br /></td></tr>
<tr class="separator:a47a6081aec3b583cad21368758e5fb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad3605b1be9adb3c066befe5a5978e3"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#abad3605b1be9adb3c066befe5a5978e3">ibuf_rec_get_counter</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec)</td></tr>
<tr class="memdesc:abad3605b1be9adb3c066befe5a5978e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the first two bytes from a record's fourth field (counter field in new records; something else in older records).  <a href="#abad3605b1be9adb3c066befe5a5978e3">More...</a><br /></td></tr>
<tr class="separator:abad3605b1be9adb3c066befe5a5978e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e65b350cf383c7d6ff72217e10b605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a33e65b350cf383c7d6ff72217e10b605">ibuf_rec_has_multi_value</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec)</td></tr>
<tr class="memdesc:a33e65b350cf383c7d6ff72217e10b605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if there is any multi-value field data on the change buffer record.  <a href="#a33e65b350cf383c7d6ff72217e10b605">More...</a><br /></td></tr>
<tr class="separator:a33e65b350cf383c7d6ff72217e10b605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc668ee69e9f1abc19883ea01bca3cb5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#abc668ee69e9f1abc19883ea01bca3cb5">ibuf_add_ops</a> (ulint *arr, const ulint *ops)</td></tr>
<tr class="memdesc:abc668ee69e9f1abc19883ea01bca3cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add accumulated operation counts to a permanent array.  <a href="#abc668ee69e9f1abc19883ea01bca3cb5">More...</a><br /></td></tr>
<tr class="separator:abc668ee69e9f1abc19883ea01bca3cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd2b194355b9e387369545701f17a4a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#adcd2b194355b9e387369545701f17a4a">ibuf_print_ops</a> (const ulint *ops, FILE *file)</td></tr>
<tr class="memdesc:adcd2b194355b9e387369545701f17a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print operation counts.  <a href="#adcd2b194355b9e387369545701f17a4a">More...</a><br /></td></tr>
<tr class="separator:adcd2b194355b9e387369545701f17a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f39419dcd8a85fb85785e9e4113ad18"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a7f39419dcd8a85fb85785e9e4113ad18">ibuf_dummy_index_create</a> (ulint <a class="el" href="xcom__base_8cc.html#a76f11d9a0a47b94f72c2d0e77fb32240">n</a>, ibool comp)</td></tr>
<tr class="memdesc:a7f39419dcd8a85fb85785e9e4113ad18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dummy index for inserting a record to a non-clustered index.  <a href="#a7f39419dcd8a85fb85785e9e4113ad18">More...</a><br /></td></tr>
<tr class="separator:a7f39419dcd8a85fb85785e9e4113ad18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d20bc5b7e2c1547cf52589dfa554d34"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a3d20bc5b7e2c1547cf52589dfa554d34">ibuf_dummy_index_add_col</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structdtype__t.html">dtype_t</a> *type, ulint len)</td></tr>
<tr class="memdesc:a3d20bc5b7e2c1547cf52589dfa554d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a column to the dummy index.  <a href="#a3d20bc5b7e2c1547cf52589dfa554d34">More...</a><br /></td></tr>
<tr class="separator:a3d20bc5b7e2c1547cf52589dfa554d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1197b3bb03784fdef7c976db48c3cd34"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a1197b3bb03784fdef7c976db48c3cd34">ibuf_dummy_index_free</a> (<a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>)</td></tr>
<tr class="memdesc:a1197b3bb03784fdef7c976db48c3cd34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deallocates a dummy index for inserting a record to a non-clustered index.  <a href="#a1197b3bb03784fdef7c976db48c3cd34">More...</a><br /></td></tr>
<tr class="separator:a1197b3bb03784fdef7c976db48c3cd34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5bd1833b7e52a65481a65faf85671e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a3b5bd1833b7e52a65481a65faf85671e">ibuf_build_entry_from_ibuf_rec_func</a> (<a class="el" href="structmtr__t.html">mtr_t</a> *mtr, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *ibuf_rec, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, <a class="el" href="structdict__index__t.html">dict_index_t</a> **pindex)</td></tr>
<tr class="memdesc:a3b5bd1833b7e52a65481a65faf85671e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the entry used to.  <a href="#a3b5bd1833b7e52a65481a65faf85671e">More...</a><br /></td></tr>
<tr class="separator:a3b5bd1833b7e52a65481a65faf85671e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a870fd57d93e5caee740bf83e2a5a7"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a79a870fd57d93e5caee740bf83e2a5a7">ibuf_rec_get_size</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *types, ulint n_fields, ulint comp)</td></tr>
<tr class="memdesc:a79a870fd57d93e5caee740bf83e2a5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the data size.  <a href="#a79a870fd57d93e5caee740bf83e2a5a7">More...</a><br /></td></tr>
<tr class="separator:a79a870fd57d93e5caee740bf83e2a5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f40a7ec90f149244bbfe95c8fc2137"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a18f40a7ec90f149244bbfe95c8fc2137">ibuf_rec_get_volume_func</a> (<a class="el" href="structmtr__t.html">mtr_t</a> *mtr, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *ibuf_rec)</td></tr>
<tr class="memdesc:a18f40a7ec90f149244bbfe95c8fc2137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the space taken by a stored non-clustered index entry if converted to an index record.  <a href="#a18f40a7ec90f149244bbfe95c8fc2137">More...</a><br /></td></tr>
<tr class="separator:a18f40a7ec90f149244bbfe95c8fc2137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0114d9fea86e42c2d5b04b09ee015eea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a0114d9fea86e42c2d5b04b09ee015eea">ibuf_entry_build</a> (<a class="el" href="ibuf0ibuf_8h.html#ae8116a402f0f6229af7671129bfab686">ibuf_op_t</a> op, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space, <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> page_no, ulint <a class="el" href="mysqlimport_8cc.html#ac15184336d5157ee1c2da1b78d0aa343">counter</a>, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a0114d9fea86e42c2d5b04b09ee015eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the tuple to insert to an ibuf tree when we have an entry for a non-clustered index.  <a href="#a0114d9fea86e42c2d5b04b09ee015eea">More...</a><br /></td></tr>
<tr class="separator:a0114d9fea86e42c2d5b04b09ee015eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6512ef909a7d0326ba7c31aaa28c211d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a6512ef909a7d0326ba7c31aaa28c211d">ibuf_search_tuple_build</a> (<a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space, <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> page_no, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap)</td></tr>
<tr class="memdesc:a6512ef909a7d0326ba7c31aaa28c211d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a search tuple used to search buffered inserts for an index page.  <a href="#a6512ef909a7d0326ba7c31aaa28c211d">More...</a><br /></td></tr>
<tr class="separator:a6512ef909a7d0326ba7c31aaa28c211d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa868dafa286d2a80ea7d1bae6f3dfbc9"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#aa868dafa286d2a80ea7d1bae6f3dfbc9">ibuf_data_enough_free_for_insert</a> (void)</td></tr>
<tr class="memdesc:aa868dafa286d2a80ea7d1bae6f3dfbc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are enough pages in the free list of the ibuf tree that we dare to start a pessimistic insert to the insert buffer.  <a href="#aa868dafa286d2a80ea7d1bae6f3dfbc9">More...</a><br /></td></tr>
<tr class="separator:aa868dafa286d2a80ea7d1bae6f3dfbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbf77c4c3c12d70f6dbfde46425e5ef"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a1bbf77c4c3c12d70f6dbfde46425e5ef">ibuf_data_too_much_free</a> (void)</td></tr>
<tr class="memdesc:a1bbf77c4c3c12d70f6dbfde46425e5ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if there are enough pages in the free list of the ibuf tree that we should remove them and free to the file space management.  <a href="#a1bbf77c4c3c12d70f6dbfde46425e5ef">More...</a><br /></td></tr>
<tr class="separator:a1bbf77c4c3c12d70f6dbfde46425e5ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23bca304f95d63120f8ef8c69ddacc0"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#ac23bca304f95d63120f8ef8c69ddacc0">ibuf_add_free_page</a> (void)</td></tr>
<tr class="memdesc:ac23bca304f95d63120f8ef8c69ddacc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new page from the ibuf file segment and adds it to the free list.  <a href="#ac23bca304f95d63120f8ef8c69ddacc0">More...</a><br /></td></tr>
<tr class="separator:ac23bca304f95d63120f8ef8c69ddacc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a89ec4874fba869064f36ce54662010"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a7a89ec4874fba869064f36ce54662010">ibuf_remove_free_page</a> (void)</td></tr>
<tr class="memdesc:a7a89ec4874fba869064f36ce54662010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a page from the free list and frees it to the fsp system.  <a href="#a7a89ec4874fba869064f36ce54662010">More...</a><br /></td></tr>
<tr class="separator:a7a89ec4874fba869064f36ce54662010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5a27a1178804f1c39b94ae7a15380e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a9e5a27a1178804f1c39b94ae7a15380e">ibuf_free_excess_pages</a> (void)</td></tr>
<tr class="memdesc:a9e5a27a1178804f1c39b94ae7a15380e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees excess pages from the ibuf free list.  <a href="#a9e5a27a1178804f1c39b94ae7a15380e">More...</a><br /></td></tr>
<tr class="separator:a9e5a27a1178804f1c39b94ae7a15380e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ef4556f064501b89e6192320d80b14"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a44ef4556f064501b89e6192320d80b14">ibuf_get_merge_page_nos_func</a> (ibool contract, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> *space_ids, <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> *page_nos, ulint *n_stored)</td></tr>
<tr class="memdesc:a44ef4556f064501b89e6192320d80b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads page numbers from a leaf in an ibuf tree.  <a href="#a44ef4556f064501b89e6192320d80b14">More...</a><br /></td></tr>
<tr class="separator:a44ef4556f064501b89e6192320d80b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bf96b35c7b7402b897397f28912ed7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#ac7bf96b35c7b7402b897397f28912ed7">ibuf_get_user_rec</a> (<a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ac7bf96b35c7b7402b897397f28912ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the matching records for space id.  <a href="#ac7bf96b35c7b7402b897397f28912ed7">More...</a><br /></td></tr>
<tr class="separator:ac7bf96b35c7b7402b897397f28912ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b282bb334d6d96ffd33d5aafbeec531"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a8b282bb334d6d96ffd33d5aafbeec531">ibuf_get_merge_pages</a> (<a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space, ulint limit, <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> *pages, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> *spaces, ulint *n_pages, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a8b282bb334d6d96ffd33d5aafbeec531"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads page numbers for a space id from an ibuf tree.  <a href="#a8b282bb334d6d96ffd33d5aafbeec531">More...</a><br /></td></tr>
<tr class="separator:a8b282bb334d6d96ffd33d5aafbeec531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bcbac56d9985cf098dab57150bfa69"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#aa1bcbac56d9985cf098dab57150bfa69">ibuf_merge_pages</a> (ulint *n_pages, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sync)</td></tr>
<tr class="memdesc:aa1bcbac56d9985cf098dab57150bfa69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contracts insert buffer trees by reading pages to the buffer pool.  <a href="#aa1bcbac56d9985cf098dab57150bfa69">More...</a><br /></td></tr>
<tr class="separator:aa1bcbac56d9985cf098dab57150bfa69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01ef8c893530efd9a6f0a5f392f69fe"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#ab01ef8c893530efd9a6f0a5f392f69fe">ibuf_merge_space</a> (<a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space)</td></tr>
<tr class="memdesc:ab01ef8c893530efd9a6f0a5f392f69fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contracts insert buffer trees by reading pages referring to space_id to the buffer pool.  <a href="#ab01ef8c893530efd9a6f0a5f392f69fe">More...</a><br /></td></tr>
<tr class="separator:ab01ef8c893530efd9a6f0a5f392f69fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716b77fbee3e9df98df99b678f10fc9a"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a716b77fbee3e9df98df99b678f10fc9a">ibuf_merge</a> (ulint *n_pages, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sync)</td></tr>
<tr class="memdesc:a716b77fbee3e9df98df99b678f10fc9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract the change buffer by reading pages to the buffer pool.  <a href="#a716b77fbee3e9df98df99b678f10fc9a">More...</a><br /></td></tr>
<tr class="separator:a716b77fbee3e9df98df99b678f10fc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc33326fce7103283eb802dba77e0977"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#adc33326fce7103283eb802dba77e0977">ibuf_contract</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> sync)</td></tr>
<tr class="memdesc:adc33326fce7103283eb802dba77e0977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract the change buffer by reading pages to the buffer pool.  <a href="#adc33326fce7103283eb802dba77e0977">More...</a><br /></td></tr>
<tr class="separator:adc33326fce7103283eb802dba77e0977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1378650a92f0fe8f198b74cd46fa929c"><td class="memItemLeft" align="right" valign="top">ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a1378650a92f0fe8f198b74cd46fa929c">ibuf_merge_in_background</a> (<a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> full)</td></tr>
<tr class="memdesc:a1378650a92f0fe8f198b74cd46fa929c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract the change buffer by reading pages to the buffer pool.  <a href="#a1378650a92f0fe8f198b74cd46fa929c">More...</a><br /></td></tr>
<tr class="separator:a1378650a92f0fe8f198b74cd46fa929c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78995512377d304729e15123b615a4e6"><td class="memItemLeft" align="right" valign="top">UNIV_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a78995512377d304729e15123b615a4e6">ibuf_contract_after_insert</a> (ulint entry_size)</td></tr>
<tr class="memdesc:a78995512377d304729e15123b615a4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contract insert buffer trees after insert if they are too big.  <a href="#a78995512377d304729e15123b615a4e6">More...</a><br /></td></tr>
<tr class="separator:a78995512377d304729e15123b615a4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4698955ceaa52dafaf4252da26085680"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a4698955ceaa52dafaf4252da26085680">ibuf_get_volume_buffered_hash</a> (const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *types, const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *data, ulint comp, ulint *<a class="el" href="innodb__memcache_2cache-src_2hash_8h.html#a1c12edaae63f2e86a5b276a18475f863">hash</a>, ulint size)</td></tr>
<tr class="memdesc:a4698955ceaa52dafaf4252da26085680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an insert buffer record has been encountered already.  <a href="#a4698955ceaa52dafaf4252da26085680">More...</a><br /></td></tr>
<tr class="separator:a4698955ceaa52dafaf4252da26085680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbef0dffd86255a66dc584c75cccbfc7"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#abbef0dffd86255a66dc584c75cccbfc7">ibuf_get_volume_buffered_count_func</a> (<a class="el" href="structmtr__t.html">mtr_t</a> *mtr, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, ulint *<a class="el" href="innodb__memcache_2cache-src_2hash_8h.html#a1c12edaae63f2e86a5b276a18475f863">hash</a>, ulint size, lint *n_recs)</td></tr>
<tr class="memdesc:abbef0dffd86255a66dc584c75cccbfc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the estimate of the number of records on a page, and get the space taken by merging the buffered record to the index page.  <a href="#abbef0dffd86255a66dc584c75cccbfc7">More...</a><br /></td></tr>
<tr class="separator:abbef0dffd86255a66dc584c75cccbfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3be6378cdc6182bbbe8b8daa84c81f"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a2c3be6378cdc6182bbbe8b8daa84c81f">ibuf_get_volume_buffered</a> (const <a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space, <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> page_no, lint *n_recs, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a2c3be6378cdc6182bbbe8b8daa84c81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an upper limit for the combined size of entries buffered in the insert buffer for a given page.  <a href="#a2c3be6378cdc6182bbbe8b8daa84c81f">More...</a><br /></td></tr>
<tr class="separator:a2c3be6378cdc6182bbbe8b8daa84c81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8227b1333c61aa9a528d63ee46814ea1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a8227b1333c61aa9a528d63ee46814ea1">ibuf_update_max_tablespace_id</a> (void)</td></tr>
<tr class="memdesc:a8227b1333c61aa9a528d63ee46814ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the biggest tablespace id from the high end of the insert buffer tree and updates the counter in fil_system.  <a href="#a8227b1333c61aa9a528d63ee46814ea1">More...</a><br /></td></tr>
<tr class="separator:a8227b1333c61aa9a528d63ee46814ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38f23e667b7b426fa1213ae45d95990"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#aa38f23e667b7b426fa1213ae45d95990">ibuf_get_entry_counter_low_func</a> (<a class="el" href="structmtr__t.html">mtr_t</a> *mtr, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space, <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> page_no)</td></tr>
<tr class="memdesc:aa38f23e667b7b426fa1213ae45d95990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for ibuf_get_entry_counter_func.  <a href="#aa38f23e667b7b426fa1213ae45d95990">More...</a><br /></td></tr>
<tr class="separator:aa38f23e667b7b426fa1213ae45d95990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4192f98ff206c7d4925386cca3cc3c18"><td class="memItemLeft" align="right" valign="top">static ulint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a4192f98ff206c7d4925386cca3cc3c18">ibuf_get_entry_counter_func</a> (<a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space, <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> page_no, const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *rec, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, ibool only_leaf)</td></tr>
<tr class="memdesc:a4192f98ff206c7d4925386cca3cc3c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the counter field for an entry based on the current last record in ibuf for (space, page_no).  <a href="#a4192f98ff206c7d4925386cca3cc3c18">More...</a><br /></td></tr>
<tr class="separator:a4192f98ff206c7d4925386cca3cc3c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6ef2b7afd2df097b54479cbdcca0cf3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#ae6ef2b7afd2df097b54479cbdcca0cf3">ibuf_insert_low</a> (ulint mode, <a class="el" href="ibuf0ibuf_8h.html#ae8116a402f0f6229af7671129bfab686">ibuf_op_t</a> op, ibool no_counter, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, ulint entry_size, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:ae6ef2b7afd2df097b54479cbdcca0cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer an operation in the insert/delete buffer, instead of doing it directly to the disk page, if this is possible.  <a href="#ae6ef2b7afd2df097b54479cbdcca0cf3">More...</a><br /></td></tr>
<tr class="separator:ae6ef2b7afd2df097b54479cbdcca0cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ba829a2d7b03f54871e9b56404122e"><td class="memItemLeft" align="right" valign="top">ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a65ba829a2d7b03f54871e9b56404122e">ibuf_insert</a> (<a class="el" href="ibuf0ibuf_8h.html#ae8116a402f0f6229af7671129bfab686">ibuf_op_t</a> op, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;page_size, <a class="el" href="structque__thr__t.html">que_thr_t</a> *thr)</td></tr>
<tr class="memdesc:a65ba829a2d7b03f54871e9b56404122e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffer an operation in the insert/delete buffer, instead of doing it directly to the disk page, if this is possible.  <a href="#a65ba829a2d7b03f54871e9b56404122e">More...</a><br /></td></tr>
<tr class="separator:a65ba829a2d7b03f54871e9b56404122e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3e0c2302d71dcd05f94c03d9da4227"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#aad3e0c2302d71dcd05f94c03d9da4227">ibuf_insert_to_index_page_low</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, ulint **offsets, <a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *heap, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr, <a class="el" href="structpage__cur__t.html">page_cur_t</a> *page_cur)</td></tr>
<tr class="memdesc:aad3e0c2302d71dcd05f94c03d9da4227"><td class="mdescLeft">&#160;</td><td class="mdescRight">During merge, inserts to an index page a secondary index entry extracted from the insert buffer.  <a href="#aad3e0c2302d71dcd05f94c03d9da4227">More...</a><br /></td></tr>
<tr class="separator:aad3e0c2302d71dcd05f94c03d9da4227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b0a670dfaa0d2a262ff188820f0196"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a93b0a670dfaa0d2a262ff188820f0196">ibuf_insert_to_index_page</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="separator:a93b0a670dfaa0d2a262ff188820f0196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617b109d2ad55ec23b143344d012884c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a617b109d2ad55ec23b143344d012884c">ibuf_set_del_mark</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a617b109d2ad55ec23b143344d012884c"><td class="mdescLeft">&#160;</td><td class="mdescRight">During merge, sets the delete mark on a record for a secondary index entry.  <a href="#a617b109d2ad55ec23b143344d012884c">More...</a><br /></td></tr>
<tr class="separator:a617b109d2ad55ec23b143344d012884c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000edb55b121bb49d494df6ce9fcef68"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a000edb55b121bb49d494df6ce9fcef68">ibuf_delete</a> (const <a class="el" href="structdtuple__t.html">dtuple_t</a> *<a class="el" href="completion__hash_8h.html#aea3abbd5a90d07f8abee93d6c28bce9a">entry</a>, <a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="structdict__index__t.html">dict_index_t</a> *<a class="el" href="mysql_8cc.html#adfa69ae672499b1037123a1f17c5552b">index</a>, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a000edb55b121bb49d494df6ce9fcef68"><td class="mdescLeft">&#160;</td><td class="mdescRight">During merge, delete a record for a secondary index entry.  <a href="#a000edb55b121bb49d494df6ce9fcef68">More...</a><br /></td></tr>
<tr class="separator:a000edb55b121bb49d494df6ce9fcef68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc7eed99f5f594c480576e6c0939f90"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a9cc7eed99f5f594c480576e6c0939f90">ibuf_restore_pos</a> (<a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space, <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> page_no, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *search_tuple, ulint mode, <a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:a9cc7eed99f5f594c480576e6c0939f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restores insert buffer tree cursor position.  <a href="#a9cc7eed99f5f594c480576e6c0939f90">More...</a><br /></td></tr>
<tr class="separator:a9cc7eed99f5f594c480576e6c0939f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae002c79f05f8353fe3e2a94b60c0cd83"><td class="memItemLeft" align="right" valign="top">static ibool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#ae002c79f05f8353fe3e2a94b60c0cd83">ibuf_delete_rec</a> (<a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space, <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> page_no, <a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *pcur, const <a class="el" href="structdtuple__t.html">dtuple_t</a> *search_tuple, <a class="el" href="structmtr__t.html">mtr_t</a> *mtr)</td></tr>
<tr class="memdesc:ae002c79f05f8353fe3e2a94b60c0cd83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes from ibuf the record on which pcur is positioned.  <a href="#ae002c79f05f8353fe3e2a94b60c0cd83">More...</a><br /></td></tr>
<tr class="separator:ae002c79f05f8353fe3e2a94b60c0cd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956e28f116e79795c5bbc31b5754ff7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a956e28f116e79795c5bbc31b5754ff7a">ibuf_merge_or_delete_for_page</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;page_id, const <a class="el" href="classpage__size__t.html">page_size_t</a> *page_size, ibool update_ibuf_bitmap)</td></tr>
<tr class="memdesc:a956e28f116e79795c5bbc31b5754ff7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">When an index page is read from a disk to the buffer pool, this function applies any buffered operations to the page and deletes the entries from the insert buffer.  <a href="#a956e28f116e79795c5bbc31b5754ff7a">More...</a><br /></td></tr>
<tr class="separator:a956e28f116e79795c5bbc31b5754ff7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a9a124765e3ab17356036cbac4a164"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a23a9a124765e3ab17356036cbac4a164">ibuf_delete_for_discarded_space</a> (<a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space)</td></tr>
<tr class="memdesc:a23a9a124765e3ab17356036cbac4a164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all entries in the insert buffer for a given space id.  <a href="#a23a9a124765e3ab17356036cbac4a164">More...</a><br /></td></tr>
<tr class="separator:a23a9a124765e3ab17356036cbac4a164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1589bf7f2ff732a87180289979a2e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a3d1589bf7f2ff732a87180289979a2e9">ibuf_is_empty</a> (void)</td></tr>
<tr class="memdesc:a3d1589bf7f2ff732a87180289979a2e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks if the insert buffer is empty.  <a href="#a3d1589bf7f2ff732a87180289979a2e9">More...</a><br /></td></tr>
<tr class="separator:a3d1589bf7f2ff732a87180289979a2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0bcad932876fb85796d1254979361f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a1e0bcad932876fb85796d1254979361f">ibuf_print</a> (FILE *file)</td></tr>
<tr class="memdesc:a1e0bcad932876fb85796d1254979361f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints info of ibuf.  <a href="#a1e0bcad932876fb85796d1254979361f">More...</a><br /></td></tr>
<tr class="separator:a1e0bcad932876fb85796d1254979361f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854d7acb5bfb6d09dbfe0f8f3c3c63fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a854d7acb5bfb6d09dbfe0f8f3c3c63fc">ibuf_check_bitmap_on_import</a> (const <a class="el" href="structtrx__t.html">trx_t</a> *trx, <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> space_id)</td></tr>
<tr class="memdesc:a854d7acb5bfb6d09dbfe0f8f3c3c63fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the insert buffer bitmaps on IMPORT TABLESPACE.  <a href="#a854d7acb5bfb6d09dbfe0f8f3c3c63fc">More...</a><br /></td></tr>
<tr class="separator:a854d7acb5bfb6d09dbfe0f8f3c3c63fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e0e5917788111d16a1aa2a76a205af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ibuf0ibuf_8cc.html#a86e0e5917788111d16a1aa2a76a205af">ibuf_set_bitmap_for_bulk_load</a> (<a class="el" href="structbuf__block__t.html">buf_block_t</a> *block, <a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> reset)</td></tr>
<tr class="memdesc:a86e0e5917788111d16a1aa2a76a205af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates free bits and buffered bits for bulk loaded page.  <a href="#a86e0e5917788111d16a1aa2a76a205af">More...</a><br /></td></tr>
<tr class="separator:a86e0e5917788111d16a1aa2a76a205af"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Insert buffer. </p>
<p>Created 7/19/1997 Heikki Tuuri </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8d9103d66d35eb0fc3c7dbe33f312fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9103d66d35eb0fc3c7dbe33f312fe1">&#9670;&nbsp;</a></span>IBUF_BITMAP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IBUF_BITMAP&#160;&#160;&#160;<a class="el" href="page0types_8h.html#a204eb2227c76883f72599d6cdedd2aee">PAGE_DATA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The start address for an insert buffer bitmap page bitmap. </p>

</div>
</div>
<a id="a0e4819e161ef97e76e73672bc860d655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4819e161ef97e76e73672bc860d655">&#9670;&nbsp;</a></span>IBUF_BITMAP_BUFFERED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IBUF_BITMAP_BUFFERED&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE if there are buffered \ changes for the page. </p>

</div>
</div>
<a id="a7c1f39462a9aad416f0161cdbbc30a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c1f39462a9aad416f0161cdbbc30a8a">&#9670;&nbsp;</a></span>IBUF_BITMAP_FREE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IBUF_BITMAP_FREE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bits indicating the \ amount of free space. </p>

</div>
</div>
<a id="a0102886f292905ba29c155e24e3badb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0102886f292905ba29c155e24e3badb4">&#9670;&nbsp;</a></span>ibuf_bitmap_get_map_page</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ibuf_bitmap_get_map_page</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#ac35248751026f3714370ee97c3d59e81">ibuf_bitmap_get_map_page_func</a>(page_id, page_size, __FILE__, __LINE__, mtr)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the ibuf bitmap page where the bits describing a given file page are stored. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>Page id of the file page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Page size of the file page </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bitmap page where the file page is mapped, that is, the bitmap page containing the descriptor bits for the file page; the bitmap page is x-latched </dd></dl>

</div>
</div>
<a id="a8b1a14e603f223cb79a9468d7c104860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1a14e603f223cb79a9468d7c104860">&#9670;&nbsp;</a></span>IBUF_BITMAP_IBUF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IBUF_BITMAP_IBUF&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TRUE if page is a part of \ the ibuf tree, excluding the \ root page, or is in the free \ list of the ibuf. </p>

</div>
</div>
<a id="a84b4b4d8057e074044c7b7d1d1b7ca21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b4b4d8057e074044c7b7d1d1b7ca21">&#9670;&nbsp;</a></span>ibuf_bitmap_page_get_bits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ibuf_bitmap_page_get_bits</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_id, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bit, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><a class="code" href="ibuf0ibuf_8cc.html#a30dc465081bffe82e76883e8a1c7a93c">ibuf_bitmap_page_get_bits_low</a>(<a class="code" href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a>, page_id, page_size, <a class="code" href="mtr0types_8h.html#ae8bcc01a7143e0c3a836c8941f386c3aa391f8cac34f924ff19fc059643d97e52">MTR_MEMO_PAGE_X_FIX</a>, \</div><div class="line">                                mtr, bit)</div><div class="ttc" id="mtr0types_8h_html_ae8bcc01a7143e0c3a836c8941f386c3aa391f8cac34f924ff19fc059643d97e52"><div class="ttname"><a href="mtr0types_8h.html#ae8bcc01a7143e0c3a836c8941f386c3aa391f8cac34f924ff19fc059643d97e52">MTR_MEMO_PAGE_X_FIX</a></div><div class="ttdef"><b>Definition:</b> mtr0types.h:261</div></div>
<div class="ttc" id="ibuf0ibuf_8cc_html_a30dc465081bffe82e76883e8a1c7a93c"><div class="ttname"><a href="ibuf0ibuf_8cc.html#a30dc465081bffe82e76883e8a1c7a93c">ibuf_bitmap_page_get_bits_low</a></div><div class="ttdeci">UNIV_INLINE ulint ibuf_bitmap_page_get_bits_low(const page_t *page, const page_id_t &amp;page_id, const page_size_t &amp;page_size, ulint latch_type, mtr_t *mtr, ulint bit)</div><div class="ttdoc">Gets the desired bits for a given page from a bitmap page. </div><div class="ttdef"><b>Definition:</b> ibuf0ibuf.cc:642</div></div>
<div class="ttc" id="ctype-mb_8cc_html_adf406aa6822ceac22d62ef63cc2879c0"><div class="ttname"><a href="ctype-mb_8cc.html#adf406aa6822ceac22d62ef63cc2879c0">page</a></div><div class="ttdeci">int page</div><div class="ttdef"><b>Definition:</b> ctype-mb.cc:1234</div></div>
</div><!-- fragment -->
<p>Gets the desired bits for a given page from a bitmap page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page</td><td>Bitmap page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>Page id whose bits to get </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Page id whose bits to get </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit</td><td>IBUF_BITMAP_FREE, IBUF_BITMAP_BUFFERED, ... </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction holding an x-latch on the bitmap page </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of bits </dd></dl>

</div>
</div>
<a id="a17808e98a8b20c598184d422c9265ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17808e98a8b20c598184d422c9265ab7">&#9670;&nbsp;</a></span>IBUF_BITS_PER_PAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IBUF_BITS_PER_PAGE&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bits describing a single page. </p>

</div>
</div>
<a id="abd7df5e3277df1e00e035a79f2f225cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7df5e3277df1e00e035a79f2f225cb">&#9670;&nbsp;</a></span>ibuf_build_entry_from_ibuf_rec</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ibuf_build_entry_from_ibuf_rec</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ibuf_rec, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">heap, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pindex&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#a3b5bd1833b7e52a65481a65faf85671e">ibuf_build_entry_from_ibuf_rec_func</a>(mtr, ibuf_rec, heap, pindex)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a089b2d45875fa59b5fe800366aec2a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a089b2d45875fa59b5fe800366aec2a98">&#9670;&nbsp;</a></span>ibuf_get_entry_counter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ibuf_get_entry_counter</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">space, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_no, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rec, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">exact_leaf&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#a4192f98ff206c7d4925386cca3cc3c18">ibuf_get_entry_counter_func</a>(space, page_no, rec, mtr, exact_leaf)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a562a1bb33b1d1a69bd2809917ac269ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a562a1bb33b1d1a69bd2809917ac269ee">&#9670;&nbsp;</a></span>ibuf_get_entry_counter_low</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ibuf_get_entry_counter_low</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rec, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">space, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">page_no&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#aa38f23e667b7b426fa1213ae45d95990">ibuf_get_entry_counter_low_func</a>(mtr, rec, space, page_no)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af53cb04f2c2f8c9b83d327bf8b6a3b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af53cb04f2c2f8c9b83d327bf8b6a3b35">&#9670;&nbsp;</a></span>ibuf_get_merge_page_nos</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ibuf_get_merge_page_nos</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">contract, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rec, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ids, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">pages, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n_stored&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#a44ef4556f064501b89e6192320d80b14">ibuf_get_merge_page_nos_func</a>(contract, rec, mtr, ids, pages, n_stored)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac419ae0d7d2d2c22fc453c7e17905c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac419ae0d7d2d2c22fc453c7e17905c65">&#9670;&nbsp;</a></span>ibuf_get_volume_buffered_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ibuf_get_volume_buffered_count</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rec, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="innodb__memcache_2cache-src_2hash_8h.html#a1c12edaae63f2e86a5b276a18475f863">hash</a>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n_recs&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#abbef0dffd86255a66dc584c75cccbfc7">ibuf_get_volume_buffered_count_func</a>(mtr, rec, <a class="el" href="innodb__memcache_2cache-src_2hash_8h.html#a1c12edaae63f2e86a5b276a18475f863">hash</a>, size, n_recs)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acdab890fac60d88850e79ae98b3524e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdab890fac60d88850e79ae98b3524e0">&#9670;&nbsp;</a></span>IBUF_REC_COMPACT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IBUF_REC_COMPACT&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set in \ IBUF_REC_OFFSET_FLAGS if the \ user index is in COMPACT \ format or later. </p>

</div>
</div>
<a id="a62c7c9b80323c3124888a83a9577617a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c7c9b80323c3124888a83a9577617a">&#9670;&nbsp;</a></span>IBUF_REC_FIELD_MARKER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IBUF_REC_FIELD_MARKER&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>starting with 4.1, a marker \ consisting of 1 byte that is 0 </p>

</div>
</div>
<a id="ad164859cdab41469a353810b2d23996c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad164859cdab41469a353810b2d23996c">&#9670;&nbsp;</a></span>IBUF_REC_FIELD_METADATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IBUF_REC_FIELD_METADATA&#160;&#160;&#160;3 /* the <a class="el" href="persisted__variable_8cc.html#a17632c4b396fac52c8df4d4f83af6923">metadata</a> field */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74c557cef1cf638059f102b2970ebdce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c557cef1cf638059f102b2970ebdce">&#9670;&nbsp;</a></span>IBUF_REC_FIELD_PAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IBUF_REC_FIELD_PAGE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>starting with 4.1, the \ page number </p>

</div>
</div>
<a id="aae06bec555ffbe7821e5a38e7360f9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae06bec555ffbe7821e5a38e7360f9e7">&#9670;&nbsp;</a></span>IBUF_REC_FIELD_SPACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IBUF_REC_FIELD_SPACE&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>in the pre-4.1 format, \ the page number. </p>
<p>later, the space_id </p>

</div>
</div>
<a id="a92218dd6ae616a26ff51ea90c76f64aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92218dd6ae616a26ff51ea90c76f64aa">&#9670;&nbsp;</a></span>IBUF_REC_FIELD_USER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IBUF_REC_FIELD_USER&#160;&#160;&#160;4     /* first <a class="el" href="persisted__variable_8cc.html#a8b83cc1a954492359ecbdba847d13e53">user</a> field */</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af14427b15c9f8763893a7faf81d3be94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14427b15c9f8763893a7faf81d3be94">&#9670;&nbsp;</a></span>ibuf_rec_get_info</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ibuf_rec_get_info</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rec, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">comp, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">info_len, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><a class="el" href="mysqlimport_8cc.html#ac15184336d5157ee1c2da1b78d0aa343">counter</a>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#aaffb8192226fceb60a1ad65ffb0e292c">ibuf_rec_get_info_func</a>(mtr, rec, op, comp, info_len, <a class="el" href="mysqlimport_8cc.html#ac15184336d5157ee1c2da1b78d0aa343">counter</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a392959af1347659b86825ef81c30c6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392959af1347659b86825ef81c30c6f2">&#9670;&nbsp;</a></span>ibuf_rec_get_op_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ibuf_rec_get_op_type</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rec&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#a47a6081aec3b583cad21368758e5fb28">ibuf_rec_get_op_type_func</a>(mtr, rec)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32fca7d56175dfb2c0c362d31e83e805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fca7d56175dfb2c0c362d31e83e805">&#9670;&nbsp;</a></span>ibuf_rec_get_page_no</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ibuf_rec_get_page_no</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rec&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#afb0c13f0bc79a9c4d3b7c0cf549a21a3">ibuf_rec_get_page_no_func</a>(mtr, rec)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93a533d7db8eb51b83790a0a65d175b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a533d7db8eb51b83790a0a65d175b2">&#9670;&nbsp;</a></span>ibuf_rec_get_space</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ibuf_rec_get_space</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rec&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#ad3f209b632ddd945f888861fccbffc4f">ibuf_rec_get_space_func</a>(mtr, rec)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a48ae4e80d89acb30784c575c96b96ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ae4e80d89acb30784c575c96b96ede">&#9670;&nbsp;</a></span>ibuf_rec_get_volume</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ibuf_rec_get_volume</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mtr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rec&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="ibuf0ibuf_8cc.html#a18f40a7ec90f149244bbfe95c8fc2137">ibuf_rec_get_volume_func</a>(mtr, rec)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a795987ff8076e14de070c2a454d70664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795987ff8076e14de070c2a454d70664">&#9670;&nbsp;</a></span>IBUF_REC_INFO_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IBUF_REC_INFO_SIZE&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Combined size of info fields at \ the beginning of the fourth field. </p>

</div>
</div>
<a id="a413f399b3b0b242113f6aed6dfe6c7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413f399b3b0b242113f6aed6dfe6c7e2">&#9670;&nbsp;</a></span>IBUF_REC_OFFSET_COUNTER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IBUF_REC_OFFSET_COUNTER&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operation counter. </p>

</div>
</div>
<a id="a492ea64c2d54ba2e17db286440ddebcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a492ea64c2d54ba2e17db286440ddebcd">&#9670;&nbsp;</a></span>IBUF_REC_OFFSET_FLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IBUF_REC_OFFSET_FLAGS&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Additional flags. </p>

</div>
</div>
<a id="a16288a0096c138b0df79212f6bb88fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16288a0096c138b0df79212f6bb88fb8">&#9670;&nbsp;</a></span>IBUF_REC_OFFSET_TYPE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IBUF_REC_OFFSET_TYPE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of operation. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac23bca304f95d63120f8ef8c69ddacc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23bca304f95d63120f8ef8c69ddacc0">&#9670;&nbsp;</a></span>ibuf_add_free_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool ibuf_add_free_page </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates a new page from the ibuf file segment and adds it to the free list. </p>
<dl class="section return"><dt>Returns</dt><dd>true on success, false if no space left </dd></dl>

</div>
</div>
<a id="abc668ee69e9f1abc19883ea01bca3cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc668ee69e9f1abc19883ea01bca3cb5">&#9670;&nbsp;</a></span>ibuf_add_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ibuf_add_ops </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add accumulated operation counts to a permanent array. </p>
<p>Both arrays must be of size IBUF_OP_COUNT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>in/out: array to modify </td></tr>
    <tr><td class="paramname">ops</td><td>in: operation counts </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac35248751026f3714370ee97c3d59e81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35248751026f3714370ee97c3d59e81">&#9670;&nbsp;</a></span>ibuf_bitmap_get_map_page_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a>* ibuf_bitmap_get_map_page_func </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ibuf bitmap page where the bits describing a given file page are stored. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>Page id of the file page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Page size of the file page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>Line where called </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bitmap page where the file page is mapped, that is, the bitmap page containing the descriptor bits for the file page; the bitmap page is x-latched </dd></dl>

</div>
</div>
<a id="a30dc465081bffe82e76883e8a1c7a93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30dc465081bffe82e76883e8a1c7a93c">&#9670;&nbsp;</a></span>ibuf_bitmap_page_get_bits_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint ibuf_bitmap_page_get_bits_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>latch_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the desired bits for a given page from a bitmap page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page</td><td>Bitmap page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>Page id whose bits to get </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>Page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">latch_type</td><td>MTR_MEMO_PAGE_X_FIX, MTR_MEMO_BUF_FIX, ... </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>Mini-transaction holding latch_type on the bitmap page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit</td><td>IBUF_BITMAP_FREE, IBUF_BITMAP_BUFFERED, ... </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value of bits </dd></dl>

</div>
</div>
<a id="aae1ad625b86b7d790d3a81d3b07a188a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae1ad625b86b7d790d3a81d3b07a188a">&#9670;&nbsp;</a></span>ibuf_bitmap_page_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibuf_bitmap_page_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an ibuf bitmap page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: bitmap page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a56dec8fa240b0af706d7a8df85f97496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56dec8fa240b0af706d7a8df85f97496">&#9670;&nbsp;</a></span>ibuf_bitmap_page_no_calc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE const <a class="el" href="classpage__id__t.html">page_id_t</a> ibuf_bitmap_page_no_calc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the bitmap page number for a given page number. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bitmap page id where the file page is mapped </dd></dl>

</div>
</div>
<a id="a223980b54495092f6fdcfc554f956630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223980b54495092f6fdcfc554f956630">&#9670;&nbsp;</a></span>ibuf_bitmap_page_set_bits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ibuf_bitmap_page_set_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>page</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the desired bit for a given page in a bitmap page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">page</td><td>bitmap page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id whose bits to set </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bit</td><td>IBUF_BITMAP_FREE, IBUF_BITMAP_BUFFERED, ... </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>value to set </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>mtr containing an x-latch to the bitmap page </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbe02a85792977a0e5817100d58368c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe02a85792977a0e5817100d58368c0">&#9670;&nbsp;</a></span>ibuf_btr_pcur_commit_specify_mtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void ibuf_btr_pcur_commit_specify_mtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commits an insert buffer mini-transaction and sets the persistent cursor latch mode to BTR_NO_LATCHES, that is, detaches the cursor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcur</td><td>in/out: persistent cursor </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b5bd1833b7e52a65481a65faf85671e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5bd1833b7e52a65481a65faf85671e">&#9670;&nbsp;</a></span>ibuf_build_entry_from_ibuf_rec_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdtuple__t.html">dtuple_t</a>* ibuf_build_entry_from_ibuf_rec_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>ibuf_rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> **&#160;</td>
          <td class="paramname"><em>pindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds the entry used to. </p>
<p>1) IBUF_OP_INSERT: insert into a non-clustered index</p>
<p>2) IBUF_OP_DELETE_MARK: find the record whose delete-mark flag we need to activate</p>
<p>3) IBUF_OP_DELETE: find the record we need to delete</p>
<p>when we have the corresponding record in an ibuf index.</p>
<p>NOTE that as we copy pointers to fields in ibuf_rec, the caller must hold a latch to the ibuf_rec page as long as the entry is used!</p>
<dl class="section return"><dt>Returns</dt><dd>own: entry to insert to a non-clustered index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtr</td><td>in: mini-transaction owning rec </td></tr>
    <tr><td class="paramname">ibuf_rec</td><td>in: record in an insert buffer </td></tr>
    <tr><td class="paramname">heap</td><td>in: heap where built </td></tr>
    <tr><td class="paramname">pindex</td><td>out, own: dummy index that describes the entry </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a854d7acb5bfb6d09dbfe0f8f3c3c63fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854d7acb5bfb6d09dbfe0f8f3c3c63fc">&#9670;&nbsp;</a></span>ibuf_check_bitmap_on_import()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> ibuf_check_bitmap_on_import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtrx__t.html">trx_t</a> *&#160;</td>
          <td class="paramname"><em>trx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the insert buffer bitmaps on IMPORT TABLESPACE. </p>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS or error code </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trx</td><td>in: transaction </td></tr>
    <tr><td class="paramname">space_id</td><td>in: tablespace identifier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af92f84210db9d5f5058837d846310617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92f84210db9d5f5058837d846310617">&#9670;&nbsp;</a></span>ibuf_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibuf_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes insert buffer and frees the data structures. </p>

</div>
</div>
<a id="adc33326fce7103283eb802dba77e0977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc33326fce7103283eb802dba77e0977">&#9670;&nbsp;</a></span>ibuf_contract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint ibuf_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sync</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contract the change buffer by reading pages to the buffer pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>whether the caller waits for the issued reads to complete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a lower limit for the combined size in bytes of entries which will be merged from ibuf trees to the pages read, 0 if ibuf is empty </dd></dl>

</div>
</div>
<a id="a78995512377d304729e15123b615a4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78995512377d304729e15123b615a4e6">&#9670;&nbsp;</a></span>ibuf_contract_after_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void ibuf_contract_after_insert </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>entry_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contract insert buffer trees after insert if they are too big. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry_size</td><td>in: size of a record which was inserted into an ibuf tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa868dafa286d2a80ea7d1bae6f3dfbc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa868dafa286d2a80ea7d1bae6f3dfbc9">&#9670;&nbsp;</a></span>ibuf_data_enough_free_for_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool ibuf_data_enough_free_for_insert </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if there are enough pages in the free list of the ibuf tree that we dare to start a pessimistic insert to the insert buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>true if enough free pages in list </dd></dl>

</div>
</div>
<a id="a1bbf77c4c3c12d70f6dbfde46425e5ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bbf77c4c3c12d70f6dbfde46425e5ef">&#9670;&nbsp;</a></span>ibuf_data_too_much_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool ibuf_data_too_much_free </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if there are enough pages in the free list of the ibuf tree that we should remove them and free to the file space management. </p>
<dl class="section return"><dt>Returns</dt><dd>true if enough free pages in list </dd></dl>

</div>
</div>
<a id="a000edb55b121bb49d494df6ce9fcef68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000edb55b121bb49d494df6ce9fcef68">&#9670;&nbsp;</a></span>ibuf_delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ibuf_delete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During merge, delete a record for a secondary index entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>in: entry </td></tr>
    <tr><td class="paramname">block</td><td>in/out: block </td></tr>
    <tr><td class="paramname">index</td><td>in: record descriptor </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mtr; must be committed before latching any further pages </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23a9a124765e3ab17356036cbac4a164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a9a124765e3ab17356036cbac4a164">&#9670;&nbsp;</a></span>ibuf_delete_for_discarded_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibuf_delete_for_discarded_space </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes all entries in the insert buffer for a given space id. </p>
<p>This is used in DISCARD TABLESPACE and IMPORT TABLESPACE. NOTE: this does not update the page free bitmaps in the space. The space will become CORRUPT when you call this function! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae002c79f05f8353fe3e2a94b60c0cd83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae002c79f05f8353fe3e2a94b60c0cd83">&#9670;&nbsp;</a></span>ibuf_delete_rec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool ibuf_delete_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>search_tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes from ibuf the record on which pcur is positioned. </p>
<p>If we have to resort to a pessimistic delete, this function commits mtr and closes the cursor. </p><dl class="section return"><dt>Returns</dt><dd>true if mtr was committed and pcur closed in this operation </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">page_no</td><td>in: index page number that the record should belong to </td></tr>
    <tr><td class="paramname">pcur</td><td>in: pcur positioned on the record to delete, having latch mode BTR_MODIFY_LEAF </td></tr>
    <tr><td class="paramname">search_tuple</td><td>in: search tuple for entries of page_no </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d20bc5b7e2c1547cf52589dfa554d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d20bc5b7e2c1547cf52589dfa554d34">&#9670;&nbsp;</a></span>ibuf_dummy_index_add_col()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ibuf_dummy_index_add_col </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtype__t.html">dtype_t</a> *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a column to the dummy index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in: dummy index </td></tr>
    <tr><td class="paramname">type</td><td>in: the data type of the column </td></tr>
    <tr><td class="paramname">len</td><td>in: length of the column </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f39419dcd8a85fb85785e9e4113ad18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f39419dcd8a85fb85785e9e4113ad18">&#9670;&nbsp;</a></span>ibuf_dummy_index_create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdict__index__t.html">dict_index_t</a>* ibuf_dummy_index_create </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a dummy index for inserting a record to a non-clustered index. </p>
<dl class="section return"><dt>Returns</dt><dd>dummy index </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>in: number of fields </td></tr>
    <tr><td class="paramname">comp</td><td>in: TRUE=use compact record format </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1197b3bb03784fdef7c976db48c3cd34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1197b3bb03784fdef7c976db48c3cd34">&#9670;&nbsp;</a></span>ibuf_dummy_index_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ibuf_dummy_index_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deallocates a dummy index for inserting a record to a non-clustered index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>in, own: dummy index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae83e6df705b87c1a60cb5b288e5ba221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83e6df705b87c1a60cb5b288e5ba221">&#9670;&nbsp;</a></span>ibuf_enter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void ibuf_enter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the flag in the current mini-transaction record indicating we're inside an insert buffer routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0114d9fea86e42c2d5b04b09ee015eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0114d9fea86e42c2d5b04b09ee015eea">&#9670;&nbsp;</a></span>ibuf_entry_build()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdtuple__t.html">dtuple_t</a>* ibuf_entry_build </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ibuf0ibuf_8h.html#ae8116a402f0f6229af7671129bfab686">ibuf_op_t</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds the tuple to insert to an ibuf tree when we have an entry for a non-clustered index. </p>
<p>NOTE that the original entry must be kept because we copy pointers to its fields.</p>
<dl class="section return"><dt>Returns</dt><dd>own: entry to insert into an ibuf index tree </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>in: operation type </td></tr>
    <tr><td class="paramname">index</td><td>in: non-clustered index </td></tr>
    <tr><td class="paramname">entry</td><td>in: entry for a non-clustered index </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">page_no</td><td>in: index page number where entry should be inserted </td></tr>
    <tr><td class="paramname">counter</td><td>in: counter value; ULINT_UNDEFINED=not used </td></tr>
    <tr><td class="paramname">heap</td><td>in: heap into which to build </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88081990d05b0e3ca5b7d47e577a69b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88081990d05b0e3ca5b7d47e577a69b3">&#9670;&nbsp;</a></span>ibuf_exit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void ibuf_exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the flag in the current mini-transaction record indicating we're exiting an insert buffer routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ee79c09530b7b843a05694f37f4b618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee79c09530b7b843a05694f37f4b618">&#9670;&nbsp;</a></span>ibuf_fixed_addr_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ibool ibuf_fixed_addr_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns TRUE if the page is one of the fixed address ibuf pages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a fixed address ibuf i/o page </dd></dl>

</div>
</div>
<a id="a9e5a27a1178804f1c39b94ae7a15380e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5a27a1178804f1c39b94ae7a15380e">&#9670;&nbsp;</a></span>ibuf_free_excess_pages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibuf_free_excess_pages </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees excess pages from the ibuf free list. </p>
<p>This function is called when an OS thread calls fsp services to allocate a new file segment, or a new page to a file segment, and the thread did not own the fsp latch before this call. </p>

</div>
</div>
<a id="a4192f98ff206c7d4925386cca3cc3c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4192f98ff206c7d4925386cca3cc3c18">&#9670;&nbsp;</a></span>ibuf_get_entry_counter_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint ibuf_get_entry_counter_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>only_leaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate the counter field for an entry based on the current last record in ibuf for (space, page_no). </p>
<dl class="section return"><dt>Returns</dt><dd>the counter field, or ULINT_UNDEFINED if we should abort this insertion to ibuf </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id of entry </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number of entry </td></tr>
    <tr><td class="paramname">rec</td><td>in: the record preceding the insertion point </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction </td></tr>
    <tr><td class="paramname">only_leaf</td><td>in: TRUE if this is the only leaf page that can contain entries for (space,page_no), that is, there was no exact match for (space,page_no) in the node pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa38f23e667b7b426fa1213ae45d95990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38f23e667b7b426fa1213ae45d95990">&#9670;&nbsp;</a></span>ibuf_get_entry_counter_low_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint ibuf_get_entry_counter_low_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td>
          <td class="paramname"><em>page_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for ibuf_get_entry_counter_func. </p>
<p>Checks if rec is for (space, page_no), and if so, reads counter value from it and returns that + 1. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ULINT_UNDEFINED</td><td>if the record does not contain any counter </td></tr>
    <tr><td class="paramname">0</td><td>if the record is not for (space, page_no) </td></tr>
    <tr><td class="paramname">1</td><td>+ previous counter value, otherwise </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtr</td><td>in: mini-transaction of rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: insert buffer record </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44ef4556f064501b89e6192320d80b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ef4556f064501b89e6192320d80b14">&#9670;&nbsp;</a></span>ibuf_get_merge_page_nos_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint ibuf_get_merge_page_nos_func </td>
          <td>(</td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>contract</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> *&#160;</td>
          <td class="paramname"><em>space_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> *&#160;</td>
          <td class="paramname"><em>page_nos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_stored</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads page numbers from a leaf in an ibuf tree. </p>
<dl class="section return"><dt>Returns</dt><dd>a lower limit for the combined volume of records which will be merged </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contract</td><td>in: TRUE if this function is called to contract the tree, FALSE if this is called when a single page becomes full and we look if it pays to read also nearby pages </td></tr>
    <tr><td class="paramname">rec</td><td>in: insert buffer record </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction holding rec </td></tr>
    <tr><td class="paramname">space_ids</td><td>in/out: space id's of the pages </td></tr>
    <tr><td class="paramname">page_nos</td><td>in/out: buffer for at least IBUF_MAX_N_PAGES_MERGED many page numbers; the page numbers are in an ascending order </td></tr>
    <tr><td class="paramname">n_stored</td><td>out: number of page numbers stored to page_nos in this function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b282bb334d6d96ffd33d5aafbeec531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b282bb334d6d96ffd33d5aafbeec531">&#9670;&nbsp;</a></span>ibuf_get_merge_pages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint ibuf_get_merge_pages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> *&#160;</td>
          <td class="paramname"><em>pages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> *&#160;</td>
          <td class="paramname"><em>spaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_pages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads page numbers for a space id from an ibuf tree. </p>
<dl class="section return"><dt>Returns</dt><dd>a lower limit for the combined volume of records which will be merged </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcur</td><td>in/out: cursor </td></tr>
    <tr><td class="paramname">space</td><td>in: space for which to merge </td></tr>
    <tr><td class="paramname">limit</td><td>in: max page numbers to read </td></tr>
    <tr><td class="paramname">pages</td><td>out: pages read </td></tr>
    <tr><td class="paramname">spaces</td><td>out: spaces read </td></tr>
    <tr><td class="paramname">n_pages</td><td>out: number of pages read </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7bf96b35c7b7402b897397f28912ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7bf96b35c7b7402b897397f28912ed7">&#9670;&nbsp;</a></span>ibuf_get_user_rec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a>* ibuf_get_user_rec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the matching records for space id. </p>
<dl class="section return"><dt>Returns</dt><dd>current rec or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcur</td><td>in: the current cursor </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c3be6378cdc6182bbbe8b8daa84c81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3be6378cdc6182bbbe8b8daa84c81f">&#9670;&nbsp;</a></span>ibuf_get_volume_buffered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint ibuf_get_volume_buffered </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lint *&#160;</td>
          <td class="paramname"><em>n_recs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets an upper limit for the combined size of entries buffered in the insert buffer for a given page. </p>
<dl class="section return"><dt>Returns</dt><dd>upper limit for the volume of buffered inserts for the index page, in bytes; UNIV_PAGE_SIZE, if the entries for the index page span several pages in the insert buffer </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pcur</td><td>in: pcur positioned at a place in an insert buffer tree where we would insert an entry for the index page whose number is page_no, latch mode has to be BTR_MODIFY_PREV or BTR_MODIFY_TREE </td></tr>
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">page_no</td><td>in: page number of an index page </td></tr>
    <tr><td class="paramname">n_recs</td><td>in/out: minimum number of records on the page after the buffered changes have been applied, or NULL to disable the counting </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mini-transaction of pcur </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbef0dffd86255a66dc584c75cccbfc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbef0dffd86255a66dc584c75cccbfc7">&#9670;&nbsp;</a></span>ibuf_get_volume_buffered_count_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint ibuf_get_volume_buffered_count_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lint *&#160;</td>
          <td class="paramname"><em>n_recs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update the estimate of the number of records on a page, and get the space taken by merging the buffered record to the index page. </p>
<dl class="section return"><dt>Returns</dt><dd>size of index record in bytes + an upper limit of the space taken in the page directory </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtr</td><td>in: mini-transaction owning rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: insert buffer record </td></tr>
    <tr><td class="paramname">hash</td><td>in/out: hash array </td></tr>
    <tr><td class="paramname">size</td><td>in: number of elements in hash array </td></tr>
    <tr><td class="paramname">n_recs</td><td>in/out: estimated number of records on the page that rec points to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4698955ceaa52dafaf4252da26085680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4698955ceaa52dafaf4252da26085680">&#9670;&nbsp;</a></span>ibuf_get_volume_buffered_hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool ibuf_get_volume_buffered_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if an insert buffer record has been encountered already. </p>
<dl class="section return"><dt>Returns</dt><dd>true if a new record, false if possible duplicate </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: ibuf record in post-4.1 format </td></tr>
    <tr><td class="paramname">types</td><td>in: fields </td></tr>
    <tr><td class="paramname">data</td><td>in: start of user record data </td></tr>
    <tr><td class="paramname">comp</td><td>in: 0=ROW_FORMAT=REDUNDANT, nonzero=ROW_FORMAT=COMPACT </td></tr>
    <tr><td class="paramname">hash</td><td>in/out: hash array </td></tr>
    <tr><td class="paramname">size</td><td>in: number of elements in hash array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9ea9526304807774ce29c698d623580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ea9526304807774ce29c698d623580">&#9670;&nbsp;</a></span>ibuf_header_page_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a>* ibuf_header_page_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ibuf header page and x-latches it. </p>
<dl class="section return"><dt>Returns</dt><dd>insert buffer header page </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e48beeba32c00c6843836063eba6d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e48beeba32c00c6843836063eba6d57">&#9670;&nbsp;</a></span>ibuf_init_at_db_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibuf_init_at_db_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the insert buffer data structure at a database startup and initializes the data structures for the insert buffer. </p>
<p>Creates the insert buffer data structure at a database startup.</p>

</div>
</div>
<a id="a65ba829a2d7b03f54871e9b56404122e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ba829a2d7b03f54871e9b56404122e">&#9670;&nbsp;</a></span>ibuf_insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool ibuf_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ibuf0ibuf_8h.html#ae8116a402f0f6229af7671129bfab686">ibuf_op_t</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffer an operation in the insert/delete buffer, instead of doing it directly to the disk page, if this is possible. </p>
<p>Does not do it if the index is clustered or unique. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>operation type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>index entry to insert </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>index where to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id where to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thr</td><td>query thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if success </dd></dl>

</div>
</div>
<a id="ae6ef2b7afd2df097b54479cbdcca0cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6ef2b7afd2df097b54479cbdcca0cf3">&#9670;&nbsp;</a></span>ibuf_insert_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="db0err_8h.html#a6fdd08971b32ee513b20967238f1654d">dberr_t</a> ibuf_insert_low </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ibuf0ibuf_8h.html#ae8116a402f0f6229af7671129bfab686">ibuf_op_t</a>&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>no_counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>entry_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structque__thr__t.html">que_thr_t</a> *&#160;</td>
          <td class="paramname"><em>thr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Buffer an operation in the insert/delete buffer, instead of doing it directly to the disk page, if this is possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>BTR_MODIFY_PREV or BTR_MODIFY_TREE </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">op</td><td>operation type </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">no_counter</td><td>TRUE=use 5.0.3 format; FALSE=allow delete buffering </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>index entry to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">entry_size</td><td>rec_get_converted_size(index, entry) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">index</td><td>index where to insert; must not be unique or clustered </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id where to insert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">thr</td><td>query thread </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>DB_SUCCESS, DB_STRONG_FAIL or other error </dd></dl>

</div>
</div>
<a id="a93b0a670dfaa0d2a262ff188820f0196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b0a670dfaa0d2a262ff188820f0196">&#9670;&nbsp;</a></span>ibuf_insert_to_index_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ibuf_insert_to_index_page </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>in: buffered entry to insert </td></tr>
    <tr><td class="paramname">block</td><td>in/out: index page where the buffered entry should be placed </td></tr>
    <tr><td class="paramname">index</td><td>in: record descriptor </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad3e0c2302d71dcd05f94c03d9da4227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad3e0c2302d71dcd05f94c03d9da4227">&#9670;&nbsp;</a></span>ibuf_insert_to_index_page_low()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a>* ibuf_insert_to_index_page_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint **&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpage__cur__t.html">page_cur_t</a> *&#160;</td>
          <td class="paramname"><em>page_cur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During merge, inserts to an index page a secondary index entry extracted from the insert buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>newly inserted record </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>in: buffered entry to insert </td></tr>
    <tr><td class="paramname">block</td><td>in/out: index page where the buffered entry should be placed </td></tr>
    <tr><td class="paramname">index</td><td>in: record descriptor </td></tr>
    <tr><td class="paramname">offsets</td><td>out: offsets on *rec </td></tr>
    <tr><td class="paramname">heap</td><td>in/out: memory heap </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mtr </td></tr>
    <tr><td class="paramname">page_cur</td><td>in/out: cursor positioned on the record after which to insert the buffered entry </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d1589bf7f2ff732a87180289979a2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1589bf7f2ff732a87180289979a2e9">&#9670;&nbsp;</a></span>ibuf_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ibuf_is_empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks if the insert buffer is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>true if empty </dd></dl>

</div>
</div>
<a id="a57a2e5e0dc11ead78fff74deecf3aa8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a2e5e0dc11ead78fff74deecf3aa8e">&#9670;&nbsp;</a></span>ibuf_max_size_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibuf_max_size_update </td>
          <td>(</td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>new_val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the max_size value for ibuf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_val</td><td>in: new value in terms of percentage of the buffer pool size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a716b77fbee3e9df98df99b678f10fc9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716b77fbee3e9df98df99b678f10fc9a">&#9670;&nbsp;</a></span>ibuf_merge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint ibuf_merge </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_pages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contract the change buffer by reading pages to the buffer pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">n_pages</td><td>number of pages merged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sync</td><td>whether the caller waits for the issued reads to complete </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a lower limit for the combined size in bytes of entries which will be merged from ibuf trees to the pages read, 0 if ibuf is empty </dd></dl>

</div>
</div>
<a id="a1378650a92f0fe8f198b74cd46fa929c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1378650a92f0fe8f198b74cd46fa929c">&#9670;&nbsp;</a></span>ibuf_merge_in_background()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint ibuf_merge_in_background </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>full</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contract the change buffer by reading pages to the buffer pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">full</td><td>If true, do a full contraction based on PCT_IO(100). If false, the size of contract batch is determined based on the current size of the change buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a lower limit for the combined size in bytes of entries which will be merged from ibuf trees to the pages read, 0 if ibuf is empty </dd></dl>

</div>
</div>
<a id="a956e28f116e79795c5bbc31b5754ff7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956e28f116e79795c5bbc31b5754ff7a">&#9670;&nbsp;</a></span>ibuf_merge_or_delete_for_page()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibuf_merge_or_delete_for_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> *&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>update_ibuf_bitmap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When an index page is read from a disk to the buffer pool, this function applies any buffered operations to the page and deletes the entries from the insert buffer. </p>
<p>If the page is not read, but created in the buffer pool, this function deletes its buffered entries from the insert buffer; there can exist entries for such a page if the page belonged to an index which subsequently was dropped. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">block</td><td>if page has been read from disk, pointer to the page x-latched, else NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id of the index page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">update_ibuf_bitmap</td><td>normally this is set to TRUE, but if we have deleted or are deleting the tablespace, then we naturally do not want to update a non-existent bitmap page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1bcbac56d9985cf098dab57150bfa69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1bcbac56d9985cf098dab57150bfa69">&#9670;&nbsp;</a></span>ibuf_merge_pages()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint ibuf_merge_pages </td>
          <td>(</td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>n_pages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>sync</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Contracts insert buffer trees by reading pages to the buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>a lower limit for the combined size in bytes of entries which will be merged from ibuf trees to the pages read, 0 if ibuf is empty </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_pages</td><td>out: number of pages to which merged </td></tr>
    <tr><td class="paramname">sync</td><td>in: true if the caller wants to wait for the issued read with the highest tablespace address to complete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab01ef8c893530efd9a6f0a5f392f69fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01ef8c893530efd9a6f0a5f392f69fe">&#9670;&nbsp;</a></span>ibuf_merge_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint ibuf_merge_space </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Contracts insert buffer trees by reading pages referring to space_id to the buffer pool. </p>
<dl class="section return"><dt>Returns</dt><dd>number of pages merged. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: tablespace id to merge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e38f2eaacffba888471173d6a900b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e38f2eaacffba888471173d6a900b00">&#9670;&nbsp;</a></span>ibuf_page_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibool ibuf_page_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpage__id__t.html">page_id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpage__size__t.html">page_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>page_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool&#160;</td>
          <td class="paramname"><em>x_latch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a page is a level 2 or 3 page in the ibuf hierarchy of pages. </p>
<p>Must not be called when recv_no_ibuf_operations==true. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">page_id</td><td>page id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_size</td><td>page size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x_latch</td><td>FALSE if relaxed check (avoid latching the bitmap page) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>file name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">line</td><td>line where called </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">mtr</td><td>mtr which will contain an x-latch to the bitmap page if the page is not one of the fixed address ibuf pages, or NULL, in which case a new transaction is created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if level 2 or level 3 page </dd></dl>

</div>
</div>
<a id="a311721976f8324336bb73f36f36cf7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311721976f8324336bb73f36f36cf7a9">&#9670;&nbsp;</a></span>ibuf_parse_bitmap_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a>* ibuf_parse_bitmap_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>end_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a redo log record of an ibuf bitmap page init. </p>
<dl class="section return"><dt>Returns</dt><dd>end of log record or NULL </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>in: buffer </td></tr>
    <tr><td class="paramname">end_ptr</td><td>in: buffer end </td></tr>
    <tr><td class="paramname">block</td><td>in: block or NULL </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e0bcad932876fb85796d1254979361f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0bcad932876fb85796d1254979361f">&#9670;&nbsp;</a></span>ibuf_print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibuf_print </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints info of ibuf. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcd2b194355b9e387369545701f17a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd2b194355b9e387369545701f17a4a">&#9670;&nbsp;</a></span>ibuf_print_ops()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ibuf_print_ops </td>
          <td>(</td>
          <td class="paramtype">const ulint *&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print operation counts. </p>
<p>The array must be of size IBUF_OP_COUNT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ops</td><td>in: operation counts </td></tr>
    <tr><td class="paramname">file</td><td>in: file where to print </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abad3605b1be9adb3c066befe5a5978e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad3605b1be9adb3c066befe5a5978e3">&#9670;&nbsp;</a></span>ibuf_rec_get_counter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ulint ibuf_rec_get_counter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the first two bytes from a record's fourth field (counter field in new records; something else in older records). </p>
<p>in: ibuf record</p>
<dl class="section return"><dt>Returns</dt><dd>"counter" field, or ULINT_UNDEFINED if for some reason it can't be read </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: ibuf record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaffb8192226fceb60a1ad65ffb0e292c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaffb8192226fceb60a1ad65ffb0e292c">&#9670;&nbsp;</a></span>ibuf_rec_get_info_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ibuf_rec_get_info_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ibuf0ibuf_8h.html#ae8116a402f0f6229af7671129bfab686">ibuf_op_t</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ibool *&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>info_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint *&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get various information about an ibuf record in &gt;= 4.1.x format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mtr</td><td>Mini-transaction owning rec, or nullptr if this is called from ibuf_rec_has_multi_value(). Because it's from page_validate() which doesn't have mtr at hand </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>Ibuf record </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">op</td><td>Operation type, or NULL </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">comp</td><td>Compact flag, or NULL </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">info_len</td><td>Length of info fields at the start of the fourth field, or NULL </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counter</td><td>Counter value, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47a6081aec3b583cad21368758e5fb28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a6081aec3b583cad21368758e5fb28">&#9670;&nbsp;</a></span>ibuf_rec_get_op_type_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="ibuf0ibuf_8h.html#ae8116a402f0f6229af7671129bfab686">ibuf_op_t</a> ibuf_rec_get_op_type_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the operation type field of an ibuf record. </p>
<dl class="section return"><dt>Returns</dt><dd>operation type </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtr</td><td>in: mini-transaction owning rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: ibuf record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb0c13f0bc79a9c4d3b7c0cf549a21a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0c13f0bc79a9c4d3b7c0cf549a21a3">&#9670;&nbsp;</a></span>ibuf_rec_get_page_no_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a> ibuf_rec_get_page_no_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the page number field of an ibuf record. </p>
<dl class="section return"><dt>Returns</dt><dd>page number </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtr</td><td>in: mini-transaction owning rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: ibuf record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79a870fd57d93e5caee740bf83e2a5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a870fd57d93e5caee740bf83e2a5a7">&#9670;&nbsp;</a></span>ibuf_rec_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE ulint ibuf_rec_get_size </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="libmysql_2authentication__win_2common_8h.html#a0c8186d9b9b7880309c27230bbb5e69d">byte</a> *&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>n_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the data size. </p>
<dl class="section return"><dt>Returns</dt><dd>size of fields </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rec</td><td>in: ibuf record </td></tr>
    <tr><td class="paramname">types</td><td>in: fields </td></tr>
    <tr><td class="paramname">n_fields</td><td>in: number of fields </td></tr>
    <tr><td class="paramname">comp</td><td>in: 0=ROW_FORMAT=REDUNDANT, nonzero=ROW_FORMAT=COMPACT </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3f209b632ddd945f888861fccbffc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f209b632ddd945f888861fccbffc4f">&#9670;&nbsp;</a></span>ibuf_rec_get_space_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a> ibuf_rec_get_space_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the space id field of an ibuf record. </p>
<p>For &lt; 4.1.x format records returns 0. </p><dl class="section return"><dt>Returns</dt><dd>space id </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtr</td><td>in: mini-transaction owning rec </td></tr>
    <tr><td class="paramname">rec</td><td>in: ibuf record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18f40a7ec90f149244bbfe95c8fc2137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f40a7ec90f149244bbfe95c8fc2137">&#9670;&nbsp;</a></span>ibuf_rec_get_volume_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ulint ibuf_rec_get_volume_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>ibuf_rec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the space taken by a stored non-clustered index entry if converted to an index record. </p>
<dl class="section return"><dt>Returns</dt><dd>size of index record in bytes + an upper limit of the space taken in the page directory </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtr</td><td>in: mini-transaction owning rec </td></tr>
    <tr><td class="paramname">ibuf_rec</td><td>in: ibuf record </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33e65b350cf383c7d6ff72217e10b605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e65b350cf383c7d6ff72217e10b605">&#9670;&nbsp;</a></span>ibuf_rec_has_multi_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> ibuf_rec_has_multi_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rem0types_8h.html#a92caeffe2dc2fbe825a54aef9a163435">rec_t</a> *&#160;</td>
          <td class="paramname"><em>rec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if there is any multi-value field data on the change buffer record. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rec</td><td>ibuf record </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is any multi-value field in the record </dd></dl>

</div>
</div>
<a id="a7a89ec4874fba869064f36ce54662010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a89ec4874fba869064f36ce54662010">&#9670;&nbsp;</a></span>ibuf_remove_free_page()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ibuf_remove_free_page </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a page from the free list and frees it to the fsp system. </p>

</div>
</div>
<a id="ad70b118022336ffdce6188d3582b8460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70b118022336ffdce6188d3582b8460">&#9670;&nbsp;</a></span>ibuf_reset_free_bits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibuf_reset_free_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the free bits of the page in the ibuf bitmap. </p>
<p>This is done in a separate mini-transaction, hence this operation does not restrict further work to only ibuf bitmap operations, which would result if the latch to the bitmap page were kept. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is safe to decrement or reset the bits in the bitmap in a mini-transaction that is committed before the mini-transaction that affects the free space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: index page; free bits are set to 0 if the index is a non-clustered non-unique, and page level is 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cc7eed99f5f594c480576e6c0939f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc7eed99f5f594c480576e6c0939f90">&#9670;&nbsp;</a></span>ibuf_restore_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ibool ibuf_restore_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>search_tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtr__pcur__t.html">btr_pcur_t</a> *&#160;</td>
          <td class="paramname"><em>pcur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Restores insert buffer tree cursor position. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the position was restored; false if not </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">page_no</td><td>in: index page number where the record should belong </td></tr>
    <tr><td class="paramname">search_tuple</td><td>in: search tuple for entries of page_no </td></tr>
    <tr><td class="paramname">mode</td><td>in: BTR_MODIFY_LEAF or BTR_MODIFY_TREE </td></tr>
    <tr><td class="paramname">pcur</td><td>in/out: persistent cursor whose position is to be restored </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mini-transaction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6512ef909a7d0326ba7c31aaa28c211d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6512ef909a7d0326ba7c31aaa28c211d">&#9670;&nbsp;</a></span>ibuf_search_tuple_build()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structdtuple__t.html">dtuple_t</a>* ibuf_search_tuple_build </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a02e9c11b4a9783f4b0b89fcf060f8f28">space_id_t</a>&#160;</td>
          <td class="paramname"><em>space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="api0api_8h.html#a3a920291a017c14a72331c818adf2265">page_no_t</a>&#160;</td>
          <td class="paramname"><em>page_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mem0mem_8h.html#a29a10a74bdb0acc8a530dd6ec3c8538a">mem_heap_t</a> *&#160;</td>
          <td class="paramname"><em>heap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builds a search tuple used to search buffered inserts for an index page. </p>
<p>This is for &gt;= 4.1.x format records. </p><dl class="section return"><dt>Returns</dt><dd>own: search tuple </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">space</td><td>in: space id </td></tr>
    <tr><td class="paramname">page_no</td><td>in: index page number </td></tr>
    <tr><td class="paramname">heap</td><td>in: heap into which to build </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86e0e5917788111d16a1aa2a76a205af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e0e5917788111d16a1aa2a76a205af">&#9670;&nbsp;</a></span>ibuf_set_bitmap_for_bulk_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibuf_set_bitmap_for_bulk_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a>&#160;</td>
          <td class="paramname"><em>reset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates free bits and buffered bits for bulk loaded page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>index page </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">reset</td><td>flag if reset free val </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a617b109d2ad55ec23b143344d012884c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617b109d2ad55ec23b143344d012884c">&#9670;&nbsp;</a></span>ibuf_set_del_mark()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ibuf_set_del_mark </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structdtuple__t.html">dtuple_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structdict__index__t.html">dict_index_t</a> *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During merge, sets the delete mark on a record for a secondary index entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entry</td><td>in: entry </td></tr>
    <tr><td class="paramname">block</td><td>in/out: block </td></tr>
    <tr><td class="paramname">index</td><td>in: record descriptor </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2efdf8e91e2ceae7820cfa3196aa3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2efdf8e91e2ceae7820cfa3196aa3c2">&#9670;&nbsp;</a></span>ibuf_set_free_bits_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibuf_set_free_bits_func </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the free bit of the page in the ibuf bitmap. </p>
<p>This is done in a separate mini-transaction, hence this operation does not restrict further work to only ibuf bitmap operations, which would result if the latch to the bitmap page were kept. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: index page of a non-clustered index; free bit is reset if page level is 0 </td></tr>
    <tr><td class="paramname">val</td><td>in: value to set: &lt; 4 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad182ff93c99b4fd4fdcc7bb01e08920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad182ff93c99b4fd4fdcc7bb01e08920">&#9670;&nbsp;</a></span>ibuf_set_free_bits_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UNIV_INLINE void ibuf_set_free_bits_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the free bits of the page in the ibuf bitmap. </p>
<p>This is done in a separate mini-transaction, hence this operation does not restrict further work to only ibuf bitmap operations, which would result if the latch to the bitmap page were kept. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: index page; free bits are set if the index is non-clustered and page level is 0 </td></tr>
    <tr><td class="paramname">val</td><td>in: value to set: &lt; 4 </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6db9ba14887bee3c7f73289c8115849f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db9ba14887bee3c7f73289c8115849f">&#9670;&nbsp;</a></span>ibuf_size_update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ibuf_size_update </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the size information of the ibuf, assuming the segment size has not changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>in: ibuf tree root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a093e4377121e636de579e5053e4369cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093e4377121e636de579e5053e4369cc">&#9670;&nbsp;</a></span>ibuf_tree_root_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="page0types_8h.html#ac84908ddc97c37107986280aa8f37897">page_t</a>* ibuf_tree_root_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the root page and sx-latches it. </p>
<dl class="section return"><dt>Returns</dt><dd>insert buffer tree root page </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9078834fb41a289c431d7ad15ae76c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9078834fb41a289c431d7ad15ae76c9">&#9670;&nbsp;</a></span>ibuf_update_free_bits_for_two_pages_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibuf_update_free_bits_for_two_pages_low </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the free bits for the two pages to reflect the present state. </p>
<p>Does this in the mtr given, which means that the latching order rules virtually prevent any further operations until mtr is committed. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is safe to set the free bits in the same mini-transaction that updated the pages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block1</td><td>in: index page </td></tr>
    <tr><td class="paramname">block2</td><td>in: index page </td></tr>
    <tr><td class="paramname">mtr</td><td>in: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5134025f7c9d02218eff1f7f9303b912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5134025f7c9d02218eff1f7f9303b912">&#9670;&nbsp;</a></span>ibuf_update_free_bits_low()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibuf_update_free_bits_low </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ulint&#160;</td>
          <td class="paramname"><em>max_ins_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the free bits for an uncompressed page to reflect the present state. </p>
<p>Does this in the mtr given, which means that the latching order rules virtually prevent any further operations for this OS thread until mtr is committed. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is safe to set the free bits in the same mini-transaction that updated the page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in: index page </td></tr>
    <tr><td class="paramname">max_ins_size</td><td>in: value of maximum insert size with reorganize before the latest operation performed to the page </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6d5afb4398250d474837a0493aa419f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d5afb4398250d474837a0493aa419f">&#9670;&nbsp;</a></span>ibuf_update_free_bits_zip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibuf_update_free_bits_zip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbuf__block__t.html">buf_block_t</a> *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmtr__t.html">mtr_t</a> *&#160;</td>
          <td class="paramname"><em>mtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the free bits for a compressed page to reflect the present state. </p>
<p>Does this in the mtr given, which means that the latching order rules virtually prevent any further operations for this OS thread until mtr is committed. NOTE: The free bits in the insert buffer bitmap must never exceed the free space on a page. It is safe to set the free bits in the same mini-transaction that updated the page. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>in/out: index page </td></tr>
    <tr><td class="paramname">mtr</td><td>in/out: mtr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8227b1333c61aa9a528d63ee46814ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8227b1333c61aa9a528d63ee46814ea1">&#9670;&nbsp;</a></span>ibuf_update_max_tablespace_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ibuf_update_max_tablespace_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the biggest tablespace id from the high end of the insert buffer tree and updates the counter in fil_system. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="acc138f660c81dccfb4179744e640a50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc138f660c81dccfb4179744e640a50d">&#9670;&nbsp;</a></span>ibuf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ibuf_t* ibuf = <a class="el" href="auth__ldap__sasl__client_8cc.html#ae7bd12bd7c9e418a420087971d0a7e31">nullptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The insert buffer control structure. </p>

</div>
</div>
<a id="ae503e7c47210cc6888ebe98e160a114c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae503e7c47210cc6888ebe98e160a114c">&#9670;&nbsp;</a></span>ibuf_bitmap_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t ibuf_bitmap_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The mutex protecting the insert buffer bitmaps. </p>

</div>
</div>
<a id="a51df412c1f9e8c379dc45c0c75c60e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51df412c1f9e8c379dc45c0c75c60e27">&#9670;&nbsp;</a></span>IBUF_CONTRACT_DO_NOT_INSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ulint IBUF_CONTRACT_DO_NOT_INSERT = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the combined size of the ibuf trees exceeds ibuf-&gt;max_size by this many pages, we start to contract it synchronous contract, but do not insert. </p>

</div>
</div>
<a id="af1b7f0ba72053cd9b7cb46bbdc2f5676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b7f0ba72053cd9b7cb46bbdc2f5676">&#9670;&nbsp;</a></span>IBUF_CONTRACT_ON_INSERT_NON_SYNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ulint IBUF_CONTRACT_ON_INSERT_NON_SYNC = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the combined size of the ibuf trees exceeds ibuf-&gt;max_size by this many pages, we start to contract it in connection to inserts there, using non-synchronous contract. </p>

</div>
</div>
<a id="a28d441560d233aba40ee87c6dfcf7e4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d441560d233aba40ee87c6dfcf7e4a">&#9670;&nbsp;</a></span>IBUF_CONTRACT_ON_INSERT_SYNC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ulint IBUF_CONTRACT_ON_INSERT_SYNC = 5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the combined size of the ibuf trees exceeds ibuf-&gt;max_size by this many pages, we start to contract it in connection to inserts there, using synchronous contract. </p>

</div>
</div>
<a id="a2dc741f0194ac361f6ca5c75ac319d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc741f0194ac361f6ca5c75ac319d92">&#9670;&nbsp;</a></span>ibuf_debug</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uca-dump_8cc.html#a91ad9478d81a7aaf2593e8d9c3d06a14">uint</a> ibuf_debug</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flag to control insert buffer debugging. </p>

</div>
</div>
<a id="a90f30ffcb65b17eb8ca32b907b0bf3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f30ffcb65b17eb8ca32b907b0bf3b6">&#9670;&nbsp;</a></span>IBUF_MAX_N_PAGES_MERGED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ulint IBUF_MAX_N_PAGES_MERGED = <a class="el" href="ibuf0ibuf_8cc.html#a523cdb37299ccf373906c7e19d4ac26b">IBUF_MERGE_AREA</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In ibuf_contract at most this number of pages is read to memory in one batch, in order to merge the entries for them in the insert buffer. </p>

</div>
</div>
<a id="a523cdb37299ccf373906c7e19d4ac26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523cdb37299ccf373906c7e19d4ac26b">&#9670;&nbsp;</a></span>IBUF_MERGE_AREA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ulint IBUF_MERGE_AREA = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The area in pages from which contract looks for page numbers for merge. </p>

</div>
</div>
<a id="ab5faeabeebb7a4a74ecf25f36ee354da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5faeabeebb7a4a74ecf25f36ee354da">&#9670;&nbsp;</a></span>IBUF_MERGE_THRESHOLD</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const ulint IBUF_MERGE_THRESHOLD = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inside the merge area, pages which have at most 1 per this number less buffered entries compared to maximum volume that can buffered for a single page are merged along with the page whose buffer became full. </p>

</div>
</div>
<a id="a81b2e6051ea83358e3fd922aab96bacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b2e6051ea83358e3fd922aab96bacb">&#9670;&nbsp;</a></span>ibuf_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t ibuf_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The mutex protecting the insert buffer structs. </p>

</div>
</div>
<a id="abd85f1f591eddefcd597b102649b3e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd85f1f591eddefcd597b102649b3e94">&#9670;&nbsp;</a></span>ibuf_pessimistic_insert_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ib_mutex_t ibuf_pessimistic_insert_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The mutex used to block pessimistic inserts to ibuf trees. </p>

</div>
</div>
<a id="a85568eec4e8ee0e177b036e654e8ac71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85568eec4e8ee0e177b036e654e8ac71">&#9670;&nbsp;</a></span>innodb_change_buffering</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="my__inttypes_8h.html#a718b4eb2652c286f4d42dc18a8e71a1a">ulong</a> innodb_change_buffering = <a class="el" href="ibuf0ibuf_8h.html#aaee299ba777e430d36fe90fd2ecb54e0a5080241bc703b62ff5e5680dc48d00d5">IBUF_USE_ALL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Operations that can currently be buffered. </p>

</div>
</div>
<a id="a331cbeb660f476370ac711f7b7320e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331cbeb660f476370ac711f7b7320e75">&#9670;&nbsp;</a></span>srv_ibuf_disable_background_merge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="innodb__memcache_2util-src_2config__parser_8c.html#abb452686968e48b67397da5f97445f5b">bool</a> srv_ibuf_disable_background_merge</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_70f20ecf11358dff00a0daf546d3147e.html">storage</a></li><li class="navelem"><a class="el" href="dir_3fec0aa9607ea05e0bb1c96aee1a8c4e.html">innobase</a></li><li class="navelem"><a class="el" href="dir_832f590932a52dc3cd352d66daa31b07.html">ibuf</a></li><li class="navelem"><a class="el" href="ibuf0ibuf_8cc.html">ibuf0ibuf.cc</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
